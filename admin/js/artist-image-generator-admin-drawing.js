!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).Konva = e() }(this, (function () {
    "use strict";
    /*
       * Konva JavaScript Framework v9.1.0
       * http://konvajs.org/
       * Licensed under the MIT
       * Date: Fri Jun 02 2023
       *
       * Original work Copyright (C) 2011 - 2013 by Eric Rowell (KineticJS)
       * Modified work Copyright (C) 2014 - present by Anton Lavrenov (Konva)
       *
       * @license
       */
    var t = Math.PI / 180; const e = "undefined" != typeof global ? global : "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope ? self : {}, i = { _global: e, version: "9.1.0", isBrowser: "undefined" != typeof window && ("[object Window]" === {}.toString.call(window) || "[object global]" === {}.toString.call(window)), isUnminified: /param/.test(function (t) { }.toString()), dblClickWindow: 400, getAngle: e => i.angleDeg ? e * t : e, enableTrace: !1, pointerEventsEnabled: !0, autoDrawEnabled: !0, hitOnDragEnabled: !1, capturePointerEventsEnabled: !1, _mouseListenClick: !1, _touchListenClick: !1, _pointerListenClick: !1, _mouseInDblClickWindow: !1, _touchInDblClickWindow: !1, _pointerInDblClickWindow: !1, _mouseDblClickPointerId: null, _touchDblClickPointerId: null, _pointerDblClickPointerId: null, pixelRatio: "undefined" != typeof window && window.devicePixelRatio || 1, dragDistance: 3, angleDeg: !0, showWarnings: !0, dragButtons: [0, 1], isDragging: () => i.DD.isDragging, isDragReady: () => !!i.DD.node, releaseCanvasOnDestroy: !0, document: e.document, _injectGlobal(t) { e.Konva = t } }, r = t => { i[t.prototype.getClassName()] = t }; i._injectGlobal(i); class a { constructor(t = [1, 0, 0, 1, 0, 0]) { this.dirty = !1, this.m = t && t.slice() || [1, 0, 0, 1, 0, 0] } reset() { this.m[0] = 1, this.m[1] = 0, this.m[2] = 0, this.m[3] = 1, this.m[4] = 0, this.m[5] = 0 } copy() { return new a(this.m) } copyInto(t) { t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5] } point(t) { var e = this.m; return { x: e[0] * t.x + e[2] * t.y + e[4], y: e[1] * t.x + e[3] * t.y + e[5] } } translate(t, e) { return this.m[4] += this.m[0] * t + this.m[2] * e, this.m[5] += this.m[1] * t + this.m[3] * e, this } scale(t, e) { return this.m[0] *= t, this.m[1] *= t, this.m[2] *= e, this.m[3] *= e, this } rotate(t) { var e = Math.cos(t), i = Math.sin(t), r = this.m[0] * e + this.m[2] * i, a = this.m[1] * e + this.m[3] * i, n = this.m[0] * -i + this.m[2] * e, s = this.m[1] * -i + this.m[3] * e; return this.m[0] = r, this.m[1] = a, this.m[2] = n, this.m[3] = s, this } getTranslation() { return { x: this.m[4], y: this.m[5] } } skew(t, e) { var i = this.m[0] + this.m[2] * e, r = this.m[1] + this.m[3] * e, a = this.m[2] + this.m[0] * t, n = this.m[3] + this.m[1] * t; return this.m[0] = i, this.m[1] = r, this.m[2] = a, this.m[3] = n, this } multiply(t) { var e = this.m[0] * t.m[0] + this.m[2] * t.m[1], i = this.m[1] * t.m[0] + this.m[3] * t.m[1], r = this.m[0] * t.m[2] + this.m[2] * t.m[3], a = this.m[1] * t.m[2] + this.m[3] * t.m[3], n = this.m[0] * t.m[4] + this.m[2] * t.m[5] + this.m[4], s = this.m[1] * t.m[4] + this.m[3] * t.m[5] + this.m[5]; return this.m[0] = e, this.m[1] = i, this.m[2] = r, this.m[3] = a, this.m[4] = n, this.m[5] = s, this } invert() { var t = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]), e = this.m[3] * t, i = -this.m[1] * t, r = -this.m[2] * t, a = this.m[0] * t, n = t * (this.m[2] * this.m[5] - this.m[3] * this.m[4]), s = t * (this.m[1] * this.m[4] - this.m[0] * this.m[5]); return this.m[0] = e, this.m[1] = i, this.m[2] = r, this.m[3] = a, this.m[4] = n, this.m[5] = s, this } getMatrix() { return this.m } decompose() { var t = this.m[0], e = this.m[1], i = this.m[2], r = this.m[3], a = t * r - e * i; let n = { x: this.m[4], y: this.m[5], rotation: 0, scaleX: 0, scaleY: 0, skewX: 0, skewY: 0 }; if (0 != t || 0 != e) { var s = Math.sqrt(t * t + e * e); n.rotation = e > 0 ? Math.acos(t / s) : -Math.acos(t / s), n.scaleX = s, n.scaleY = a / s, n.skewX = (t * i + e * r) / a, n.skewY = 0 } else if (0 != i || 0 != r) { var o = Math.sqrt(i * i + r * r); n.rotation = Math.PI / 2 - (r > 0 ? Math.acos(-i / o) : -Math.acos(i / o)), n.scaleX = a / o, n.scaleY = o, n.skewX = 0, n.skewY = (t * i + e * r) / a } return n.rotation = g._getRotation(n.rotation), n } } var n = Math.PI / 180, s = 180 / Math.PI, o = "Konva error: ", h = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 132, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 255, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 203], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [119, 128, 144], slategrey: [119, 128, 144], snow: [255, 255, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], transparent: [255, 255, 255, 0], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 5] }, l = /rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/, d = []; const c = "undefined" != typeof requestAnimationFrame && requestAnimationFrame || function (t) { setTimeout(t, 60) }, g = { _isElement: t => !(!t || 1 != t.nodeType), _isFunction: t => !!(t && t.constructor && t.call && t.apply), _isPlainObject: t => !!t && t.constructor === Object, _isArray: t => "[object Array]" === Object.prototype.toString.call(t), _isNumber: t => "[object Number]" === Object.prototype.toString.call(t) && !isNaN(t) && isFinite(t), _isString: t => "[object String]" === Object.prototype.toString.call(t), _isBoolean: t => "[object Boolean]" === Object.prototype.toString.call(t), isObject: t => t instanceof Object, isValidSelector(t) { if ("string" != typeof t) return !1; var e = t[0]; return "#" === e || "." === e || e === e.toUpperCase() }, _sign: t => 0 === t || t > 0 ? 1 : -1, requestAnimFrame(t) { d.push(t), 1 === d.length && c((function () { const t = d; d = [], t.forEach((function (t) { t() })) })) }, createCanvasElement() { var t = document.createElement("canvas"); try { t.style = t.style || {} } catch (t) { } return t }, createImageElement: () => document.createElement("img"), _isInDocument(t) { for (; t = t.parentNode;)if (t == document) return !0; return !1 }, _urlToImage(t, e) { var i = g.createImageElement(); i.onload = function () { e(i) }, i.src = t }, _rgbToHex: (t, e, i) => ((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1), _hexToRgb(t) { t = t.replace("#", ""); var e = parseInt(t, 16); return { r: e >> 16 & 255, g: e >> 8 & 255, b: 255 & e } }, getRandomColor() { for (var t = (16777215 * Math.random() << 0).toString(16); t.length < 6;)t = "0" + t; return "#" + t }, getRGB(t) { var e; return t in h ? { r: (e = h[t])[0], g: e[1], b: e[2] } : "#" === t[0] ? this._hexToRgb(t.substring(1)) : "rgb(" === t.substr(0, 4) ? (e = l.exec(t.replace(/ /g, "")), { r: parseInt(e[1], 10), g: parseInt(e[2], 10), b: parseInt(e[3], 10) }) : { r: 0, g: 0, b: 0 } }, colorToRGBA: t => (t = t || "black", g._namedColorToRBA(t) || g._hex3ColorToRGBA(t) || g._hex4ColorToRGBA(t) || g._hex6ColorToRGBA(t) || g._hex8ColorToRGBA(t) || g._rgbColorToRGBA(t) || g._rgbaColorToRGBA(t) || g._hslColorToRGBA(t)), _namedColorToRBA(t) { var e = h[t.toLowerCase()]; return e ? { r: e[0], g: e[1], b: e[2], a: 1 } : null }, _rgbColorToRGBA(t) { if (0 === t.indexOf("rgb(")) { var e = (t = t.match(/rgb\(([^)]+)\)/)[1]).split(/ *, */).map(Number); return { r: e[0], g: e[1], b: e[2], a: 1 } } }, _rgbaColorToRGBA(t) { if (0 === t.indexOf("rgba(")) { var e = (t = t.match(/rgba\(([^)]+)\)/)[1]).split(/ *, */).map(((t, e) => "%" === t.slice(-1) ? 3 === e ? parseInt(t) / 100 : parseInt(t) / 100 * 255 : Number(t))); return { r: e[0], g: e[1], b: e[2], a: e[3] } } }, _hex8ColorToRGBA(t) { if ("#" === t[0] && 9 === t.length) return { r: parseInt(t.slice(1, 3), 16), g: parseInt(t.slice(3, 5), 16), b: parseInt(t.slice(5, 7), 16), a: parseInt(t.slice(7, 9), 16) / 255 } }, _hex6ColorToRGBA(t) { if ("#" === t[0] && 7 === t.length) return { r: parseInt(t.slice(1, 3), 16), g: parseInt(t.slice(3, 5), 16), b: parseInt(t.slice(5, 7), 16), a: 1 } }, _hex4ColorToRGBA(t) { if ("#" === t[0] && 5 === t.length) return { r: parseInt(t[1] + t[1], 16), g: parseInt(t[2] + t[2], 16), b: parseInt(t[3] + t[3], 16), a: parseInt(t[4] + t[4], 16) / 255 } }, _hex3ColorToRGBA(t) { if ("#" === t[0] && 4 === t.length) return { r: parseInt(t[1] + t[1], 16), g: parseInt(t[2] + t[2], 16), b: parseInt(t[3] + t[3], 16), a: 1 } }, _hslColorToRGBA(t) { if (/hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.test(t)) { const [e, ...i] = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(t), r = Number(i[0]) / 360, a = Number(i[1]) / 100, n = Number(i[2]) / 100; let s, o, h; if (0 === a) return h = 255 * n, { r: Math.round(h), g: Math.round(h), b: Math.round(h), a: 1 }; s = n < .5 ? n * (1 + a) : n + a - n * a; const l = 2 * n - s, d = [0, 0, 0]; for (let t = 0; t < 3; t++)o = r + 1 / 3 * -(t - 1), o < 0 && o++, o > 1 && o--, h = 6 * o < 1 ? l + 6 * (s - l) * o : 2 * o < 1 ? s : 3 * o < 2 ? l + (s - l) * (2 / 3 - o) * 6 : l, d[t] = 255 * h; return { r: Math.round(d[0]), g: Math.round(d[1]), b: Math.round(d[2]), a: 1 } } }, haveIntersection: (t, e) => !(e.x > t.x + t.width || e.x + e.width < t.x || e.y > t.y + t.height || e.y + e.height < t.y), cloneObject(t) { var e = {}; for (var i in t) this._isPlainObject(t[i]) ? e[i] = this.cloneObject(t[i]) : this._isArray(t[i]) ? e[i] = this.cloneArray(t[i]) : e[i] = t[i]; return e }, cloneArray: t => t.slice(0), degToRad: t => t * n, radToDeg: t => t * s, _degToRad: t => (g.warn("Util._degToRad is removed. Please use public Util.degToRad instead."), g.degToRad(t)), _radToDeg: t => (g.warn("Util._radToDeg is removed. Please use public Util.radToDeg instead."), g.radToDeg(t)), _getRotation: t => i.angleDeg ? g.radToDeg(t) : t, _capitalize: t => t.charAt(0).toUpperCase() + t.slice(1), throw(t) { throw new Error(o + t) }, error(t) { console.error(o + t) }, warn(t) { i.showWarnings && console.warn("Konva warning: " + t) }, each(t, e) { for (var i in t) e(i, t[i]) }, _inRange: (t, e, i) => e <= t && t < i, _getProjectionToSegment(t, e, i, r, a, n) { var s, o, h, l = (t - i) * (t - i) + (e - r) * (e - r); if (0 == l) s = t, o = e, h = (a - i) * (a - i) + (n - r) * (n - r); else { var d = ((a - t) * (i - t) + (n - e) * (r - e)) / l; d < 0 ? (s = t, o = e, h = (t - a) * (t - a) + (e - n) * (e - n)) : d > 1 ? (s = i, o = r, h = (i - a) * (i - a) + (r - n) * (r - n)) : h = ((s = t + d * (i - t)) - a) * (s - a) + ((o = e + d * (r - e)) - n) * (o - n) } return [s, o, h] }, _getProjectionToLine(t, e, i) { var r = g.cloneObject(t), a = Number.MAX_VALUE; return e.forEach((function (n, s) { if (i || s !== e.length - 1) { var o = e[(s + 1) % e.length], h = g._getProjectionToSegment(n.x, n.y, o.x, o.y, t.x, t.y), l = h[0], d = h[1], c = h[2]; c < a && (r.x = l, r.y = d, a = c) } })), r }, _prepareArrayForTween(t, e, i) { var r, a = [], n = []; if (t.length > e.length) { var s = e; e = t, t = s } for (r = 0; r < t.length; r += 2)a.push({ x: t[r], y: t[r + 1] }); for (r = 0; r < e.length; r += 2)n.push({ x: e[r], y: e[r + 1] }); var o = []; return n.forEach((function (t) { var e = g._getProjectionToLine(t, a, i); o.push(e.x), o.push(e.y) })), o }, _prepareToStringify(t) { var e; for (var i in t.visitedByCircularReferenceRemoval = !0, t) if (t.hasOwnProperty(i) && t[i] && "object" == typeof t[i]) if (e = Object.getOwnPropertyDescriptor(t, i), t[i].visitedByCircularReferenceRemoval || g._isElement(t[i])) { if (!e.configurable) return null; delete t[i] } else if (null === g._prepareToStringify(t[i])) { if (!e.configurable) return null; delete t[i] } return delete t.visitedByCircularReferenceRemoval, t }, _assign(t, e) { for (var i in e) t[i] = e[i]; return t }, _getFirstPointerId: t => t.touches ? t.changedTouches[0].identifier : t.pointerId || 999, releaseCanvas(...t) { i.releaseCanvasOnDestroy && t.forEach((t => { t.width = 0, t.height = 0 })) }, drawRoundedRectPath(t, e, i, r) { let a = 0, n = 0, s = 0, o = 0; "number" == typeof r ? a = n = s = o = Math.min(r, e / 2, i / 2) : (a = Math.min(r[0] || 0, e / 2, i / 2), n = Math.min(r[1] || 0, e / 2, i / 2), o = Math.min(r[2] || 0, e / 2, i / 2), s = Math.min(r[3] || 0, e / 2, i / 2)), t.moveTo(a, 0), t.lineTo(e - n, 0), t.arc(e - n, n, n, 3 * Math.PI / 2, 0, !1), t.lineTo(e, i - o), t.arc(e - o, i - o, o, 0, Math.PI / 2, !1), t.lineTo(s, i), t.arc(s, i - s, s, Math.PI / 2, Math.PI, !1), t.lineTo(0, a), t.arc(a, a, a, Math.PI, 3 * Math.PI / 2, !1) } }; function u(t) { return g._isString(t) ? '"' + t + '"' : "[object Number]" === Object.prototype.toString.call(t) || g._isBoolean(t) ? t : Object.prototype.toString.call(t) } function f(t) { return t > 255 ? 255 : t < 0 ? 0 : Math.round(t) } function p() { if (i.isUnminified) return function (t, e) { return g._isNumber(t) || g.warn(u(t) + ' is a not valid value for "' + e + '" attribute. The value should be a number.'), t } } function v(t) { if (i.isUnminified) return function (e, i) { let r = g._isNumber(e), a = g._isArray(e) && e.length == t; return r || a || g.warn(u(e) + ' is a not valid value for "' + i + '" attribute. The value should be a number or Array<number>(' + t + ")"), e } } function m() { if (i.isUnminified) return function (t, e) { return g._isNumber(t) || "auto" === t || g.warn(u(t) + ' is a not valid value for "' + e + '" attribute. The value should be a number or "auto".'), t } } function _() { if (i.isUnminified) return function (t, e) { return g._isString(t) || g.warn(u(t) + ' is a not valid value for "' + e + '" attribute. The value should be a string.'), t } } function y() { if (i.isUnminified) return function (t, e) { const i = g._isString(t), r = "[object CanvasGradient]" === Object.prototype.toString.call(t) || t && t.addColorStop; return i || r || g.warn(u(t) + ' is a not valid value for "' + e + '" attribute. The value should be a string or a native gradient.'), t } } function x() { if (i.isUnminified) return function (t, e) { return !0 === t || !1 === t || g.warn(u(t) + ' is a not valid value for "' + e + '" attribute. The value should be a boolean.'), t } } var b = "get", S = "set"; const w = { addGetterSetter(t, e, i, r, a) { w.addGetter(t, e, i), w.addSetter(t, e, r, a), w.addOverloadedGetterSetter(t, e) }, addGetter(t, e, i) { var r = b + g._capitalize(e); t.prototype[r] = t.prototype[r] || function () { var t = this.attrs[e]; return void 0 === t ? i : t } }, addSetter(t, e, i, r) { var a = S + g._capitalize(e); t.prototype[a] || w.overWriteSetter(t, e, i, r) }, overWriteSetter(t, e, i, r) { var a = S + g._capitalize(e); t.prototype[a] = function (t) { return i && null != t && (t = i.call(this, t, e)), this._setAttr(e, t), r && r.call(this), this } }, addComponentsGetterSetter(t, e, r, a, n) { var s, o, h = r.length, l = g._capitalize, d = b + l(e), c = S + l(e); t.prototype[d] = function () { var t = {}; for (s = 0; s < h; s++)t[o = r[s]] = this.getAttr(e + l(o)); return t }; var f = function (t) { if (i.isUnminified) return function (e, i) { return null == e || g.isObject(e) || g.warn(u(e) + ' is a not valid value for "' + i + '" attribute. The value should be an object with properties ' + t), e } }(r); t.prototype[c] = function (t) { var i, s = this.attrs[e]; for (i in a && (t = a.call(this, t)), f && f.call(this, t, e), t) t.hasOwnProperty(i) && this._setAttr(e + l(i), t[i]); return t || r.forEach((t => { this._setAttr(e + l(t), void 0) })), this._fireChangeEvent(e, s, t), n && n.call(this), this }, w.addOverloadedGetterSetter(t, e) }, addOverloadedGetterSetter(t, e) { var i = g._capitalize(e), r = S + i, a = b + i; t.prototype[e] = function () { return arguments.length ? (this[r](arguments[0]), this) : this[a]() } }, addDeprecatedGetterSetter(t, e, i, r) { g.error("Adding deprecated " + e); var a = b + g._capitalize(e), n = e + " property is deprecated and will be removed soon. Look at Konva change log for more information."; t.prototype[a] = function () { g.error(n); var t = this.attrs[e]; return void 0 === t ? i : t }, w.addSetter(t, e, r, (function () { g.error(n) })), w.addOverloadedGetterSetter(t, e) }, backCompat(t, e) { g.each(e, (function (e, i) { var r = t.prototype[i], a = b + g._capitalize(e), n = S + g._capitalize(e); function s() { r.apply(this, arguments), g.error('"' + e + '" method is deprecated and will be removed soon. Use ""' + i + '" instead.') } t.prototype[e] = s, t.prototype[a] = s, t.prototype[n] = s })) }, afterSetFilter() { this._filterUpToDate = !1 } }; var C = ["arc", "arcTo", "beginPath", "bezierCurveTo", "clearRect", "clip", "closePath", "createLinearGradient", "createPattern", "createRadialGradient", "drawImage", "ellipse", "fill", "fillText", "getImageData", "createImageData", "lineTo", "moveTo", "putImageData", "quadraticCurveTo", "rect", "restore", "rotate", "save", "scale", "setLineDash", "setTransform", "stroke", "strokeText", "transform", "translate"]; class P { constructor(t) { this.canvas = t, i.enableTrace && (this.traceArr = [], this._enableTrace()) } fillShape(t) { t.fillEnabled() && this._fill(t) } _fill(t) { } strokeShape(t) { t.hasStroke() && this._stroke(t) } _stroke(t) { } fillStrokeShape(t) { t.attrs.fillAfterStrokeEnabled ? (this.strokeShape(t), this.fillShape(t)) : (this.fillShape(t), this.strokeShape(t)) } getTrace(t, e) { var i, r, a, n, s = this.traceArr, o = s.length, h = ""; for (i = 0; i < o; i++)(a = (r = s[i]).method) ? (n = r.args, h += a, t ? h += "()" : g._isArray(n[0]) ? h += "([" + n.join(",") + "])" : (e && (n = n.map((t => "number" == typeof t ? Math.floor(t) : t))), h += "(" + n.join(",") + ")")) : (h += r.property, t || (h += "=" + r.val)), h += ";"; return h } clearTrace() { this.traceArr = [] } _trace(t) { var e = this.traceArr; e.push(t), e.length >= 100 && e.shift() } reset() { var t = this.getCanvas().getPixelRatio(); this.setTransform(1 * t, 0, 0, 1 * t, 0, 0) } getCanvas() { return this.canvas } clear(t) { var e = this.getCanvas(); t ? this.clearRect(t.x || 0, t.y || 0, t.width || 0, t.height || 0) : this.clearRect(0, 0, e.getWidth() / e.pixelRatio, e.getHeight() / e.pixelRatio) } _applyLineCap(t) { const e = t.attrs.lineCap; e && this.setAttr("lineCap", e) } _applyOpacity(t) { var e = t.getAbsoluteOpacity(); 1 !== e && this.setAttr("globalAlpha", e) } _applyLineJoin(t) { const e = t.attrs.lineJoin; e && this.setAttr("lineJoin", e) } setAttr(t, e) { this._context[t] = e } arc(t, e, i, r, a, n) { this._context.arc(t, e, i, r, a, n) } arcTo(t, e, i, r, a) { this._context.arcTo(t, e, i, r, a) } beginPath() { this._context.beginPath() } bezierCurveTo(t, e, i, r, a, n) { this._context.bezierCurveTo(t, e, i, r, a, n) } clearRect(t, e, i, r) { this._context.clearRect(t, e, i, r) } clip() { this._context.clip() } closePath() { this._context.closePath() } createImageData(t, e) { var i = arguments; return 2 === i.length ? this._context.createImageData(t, e) : 1 === i.length ? this._context.createImageData(t) : void 0 } createLinearGradient(t, e, i, r) { return this._context.createLinearGradient(t, e, i, r) } createPattern(t, e) { return this._context.createPattern(t, e) } createRadialGradient(t, e, i, r, a, n) { return this._context.createRadialGradient(t, e, i, r, a, n) } drawImage(t, e, i, r, a, n, s, o, h) { var l = arguments, d = this._context; 3 === l.length ? d.drawImage(t, e, i) : 5 === l.length ? d.drawImage(t, e, i, r, a) : 9 === l.length && d.drawImage(t, e, i, r, a, n, s, o, h) } ellipse(t, e, i, r, a, n, s, o) { this._context.ellipse(t, e, i, r, a, n, s, o) } isPointInPath(t, e, i, r) { return i ? this._context.isPointInPath(i, t, e, r) : this._context.isPointInPath(t, e, r) } fill(t) { t ? this._context.fill(t) : this._context.fill() } fillRect(t, e, i, r) { this._context.fillRect(t, e, i, r) } strokeRect(t, e, i, r) { this._context.strokeRect(t, e, i, r) } fillText(t, e, i, r) { r ? this._context.fillText(t, e, i, r) : this._context.fillText(t, e, i) } measureText(t) { return this._context.measureText(t) } getImageData(t, e, i, r) { return this._context.getImageData(t, e, i, r) } lineTo(t, e) { this._context.lineTo(t, e) } moveTo(t, e) { this._context.moveTo(t, e) } rect(t, e, i, r) { this._context.rect(t, e, i, r) } putImageData(t, e, i) { this._context.putImageData(t, e, i) } quadraticCurveTo(t, e, i, r) { this._context.quadraticCurveTo(t, e, i, r) } restore() { this._context.restore() } rotate(t) { this._context.rotate(t) } save() { this._context.save() } scale(t, e) { this._context.scale(t, e) } setLineDash(t) { this._context.setLineDash ? this._context.setLineDash(t) : "mozDash" in this._context ? this._context.mozDash = t : "webkitLineDash" in this._context && (this._context.webkitLineDash = t) } getLineDash() { return this._context.getLineDash() } setTransform(t, e, i, r, a, n) { this._context.setTransform(t, e, i, r, a, n) } stroke(t) { t ? this._context.stroke(t) : this._context.stroke() } strokeText(t, e, i, r) { this._context.strokeText(t, e, i, r) } transform(t, e, i, r, a, n) { this._context.transform(t, e, i, r, a, n) } translate(t, e) { this._context.translate(t, e) } _enableTrace() { var t, e, i = this, r = C.length, a = this.setAttr, n = function (t) { var r, a = i[t]; i[t] = function () { return e = function (t) { var e, i, r = [], a = t.length, n = g; for (e = 0; e < a; e++)i = t[e], n._isNumber(i) ? i = Math.round(1e3 * i) / 1e3 : n._isString(i) || (i += ""), r.push(i); return r }(Array.prototype.slice.call(arguments, 0)), r = a.apply(i, arguments), i._trace({ method: t, args: e }), r } }; for (t = 0; t < r; t++)n(C[t]); i.setAttr = function () { a.apply(i, arguments); var t = arguments[0], e = arguments[1]; "shadowOffsetX" !== t && "shadowOffsetY" !== t && "shadowBlur" !== t || (e /= this.canvas.getPixelRatio()), i._trace({ property: t, val: e }) } } _applyGlobalCompositeOperation(t) { const e = t.attrs.globalCompositeOperation; !e || "source-over" === e || this.setAttr("globalCompositeOperation", e) } } ["fillStyle", "strokeStyle", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "lineCap", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "font", "textAlign", "textBaseline", "globalAlpha", "globalCompositeOperation", "imageSmoothingEnabled"].forEach((function (t) { Object.defineProperty(P.prototype, t, { get() { return this._context[t] }, set(e) { this._context[t] = e } }) })); class k extends P { constructor(t, { willReadFrequently: e = !1 } = {}) { super(t), this._context = t._canvas.getContext("2d", { willReadFrequently: e }) } _fillColor(t) { var e = t.fill(); this.setAttr("fillStyle", e), t._fillFunc(this) } _fillPattern(t) { this.setAttr("fillStyle", t._getFillPattern()), t._fillFunc(this) } _fillLinearGradient(t) { var e = t._getLinearGradient(); e && (this.setAttr("fillStyle", e), t._fillFunc(this)) } _fillRadialGradient(t) { const e = t._getRadialGradient(); e && (this.setAttr("fillStyle", e), t._fillFunc(this)) } _fill(t) { const e = t.fill(), i = t.getFillPriority(); if (e && "color" === i) return void this._fillColor(t); const r = t.getFillPatternImage(); if (r && "pattern" === i) return void this._fillPattern(t); const a = t.getFillLinearGradientColorStops(); if (a && "linear-gradient" === i) return void this._fillLinearGradient(t); const n = t.getFillRadialGradientColorStops(); n && "radial-gradient" === i ? this._fillRadialGradient(t) : e ? this._fillColor(t) : r ? this._fillPattern(t) : a ? this._fillLinearGradient(t) : n && this._fillRadialGradient(t) } _strokeLinearGradient(t) { const e = t.getStrokeLinearGradientStartPoint(), i = t.getStrokeLinearGradientEndPoint(), r = t.getStrokeLinearGradientColorStops(), a = this.createLinearGradient(e.x, e.y, i.x, i.y); if (r) { for (var n = 0; n < r.length; n += 2)a.addColorStop(r[n], r[n + 1]); this.setAttr("strokeStyle", a) } } _stroke(t) { var e = t.dash(), i = t.getStrokeScaleEnabled(); if (t.hasStroke()) { if (!i) { this.save(); var r = this.getCanvas().getPixelRatio(); this.setTransform(r, 0, 0, r, 0, 0) } this._applyLineCap(t), e && t.dashEnabled() && (this.setLineDash(e), this.setAttr("lineDashOffset", t.dashOffset())), this.setAttr("lineWidth", t.strokeWidth()), t.getShadowForStrokeEnabled() || this.setAttr("shadowColor", "rgba(0,0,0,0)"), t.getStrokeLinearGradientColorStops() ? this._strokeLinearGradient(t) : this.setAttr("strokeStyle", t.stroke()), t._strokeFunc(this), i || this.restore() } } _applyShadow(t) { var e, i, r, a = null !== (e = t.getShadowRGBA()) && void 0 !== e ? e : "black", n = null !== (i = t.getShadowBlur()) && void 0 !== i ? i : 5, s = null !== (r = t.getShadowOffset()) && void 0 !== r ? r : { x: 0, y: 0 }, o = t.getAbsoluteScale(), h = this.canvas.getPixelRatio(), l = o.x * h, d = o.y * h; this.setAttr("shadowColor", a), this.setAttr("shadowBlur", n * Math.min(Math.abs(l), Math.abs(d))), this.setAttr("shadowOffsetX", s.x * l), this.setAttr("shadowOffsetY", s.y * d) } } class T extends P { constructor(t) { super(t), this._context = t._canvas.getContext("2d", { willReadFrequently: !0 }) } _fill(t) { this.save(), this.setAttr("fillStyle", t.colorKey), t._fillFuncHit(this), this.restore() } strokeShape(t) { t.hasHitStroke() && this._stroke(t) } _stroke(t) { if (t.hasHitStroke()) { const a = t.getStrokeScaleEnabled(); if (!a) { this.save(); var e = this.getCanvas().getPixelRatio(); this.setTransform(e, 0, 0, e, 0, 0) } this._applyLineCap(t); var i = t.hitStrokeWidth(), r = "auto" === i ? t.strokeWidth() : i; this.setAttr("lineWidth", r), this.setAttr("strokeStyle", t.colorKey), t._strokeFuncHit(this), a || this.restore() } } } var A; class M { constructor(t) { this.pixelRatio = 1, this.width = 0, this.height = 0, this.isCache = !1; var e = (t || {}).pixelRatio || i.pixelRatio || function () { if (A) return A; var t = g.createCanvasElement(), e = t.getContext("2d"); return A = (i._global.devicePixelRatio || 1) / (e.webkitBackingStorePixelRatio || e.mozBackingStorePixelRatio || e.msBackingStorePixelRatio || e.oBackingStorePixelRatio || e.backingStorePixelRatio || 1), g.releaseCanvas(t), A }(); this.pixelRatio = e, this._canvas = g.createCanvasElement(), this._canvas.style.padding = "0", this._canvas.style.margin = "0", this._canvas.style.border = "0", this._canvas.style.background = "transparent", this._canvas.style.position = "absolute", this._canvas.style.top = "0", this._canvas.style.left = "0" } getContext() { return this.context } getPixelRatio() { return this.pixelRatio } setPixelRatio(t) { var e = this.pixelRatio; this.pixelRatio = t, this.setSize(this.getWidth() / e, this.getHeight() / e) } setWidth(t) { this.width = this._canvas.width = t * this.pixelRatio, this._canvas.style.width = t + "px"; var e = this.pixelRatio; this.getContext()._context.scale(e, e) } setHeight(t) { this.height = this._canvas.height = t * this.pixelRatio, this._canvas.style.height = t + "px"; var e = this.pixelRatio; this.getContext()._context.scale(e, e) } getWidth() { return this.width } getHeight() { return this.height } setSize(t, e) { this.setWidth(t || 0), this.setHeight(e || 0) } toDataURL(t, e) { try { return this._canvas.toDataURL(t, e) } catch (t) { try { return this._canvas.toDataURL() } catch (t) { return g.error("Unable to get data URL. " + t.message + " For more info read https://konvajs.org/docs/posts/Tainted_Canvas.html."), "" } } } } w.addGetterSetter(M, "pixelRatio", void 0, p()); class G extends M { constructor(t = { width: 0, height: 0, willReadFrequently: !1 }) { super(t), this.context = new k(this, { willReadFrequently: t.willReadFrequently }), this.setSize(t.width, t.height) } } class R extends M { constructor(t = { width: 0, height: 0 }) { super(t), this.hitCanvas = !0, this.context = new T(this), this.setSize(t.width, t.height) } } const E = { get isDragging() { var t = !1; return E._dragElements.forEach((e => { "dragging" === e.dragStatus && (t = !0) })), t }, justDragged: !1, get node() { var t; return E._dragElements.forEach((e => { t = e.node })), t }, _dragElements: new Map, _drag(t) { const e = []; E._dragElements.forEach(((i, r) => { const { node: a } = i, n = a.getStage(); n.setPointersPositions(t), void 0 === i.pointerId && (i.pointerId = g._getFirstPointerId(t)); const s = n._changedPointerPositions.find((t => t.id === i.pointerId)); if (s) { if ("dragging" !== i.dragStatus) { var o = a.dragDistance(); if (Math.max(Math.abs(s.x - i.startPointerPos.x), Math.abs(s.y - i.startPointerPos.y)) < o) return; if (a.startDrag({ evt: t }), !a.isDragging()) return } a._setDragPosition(t, i), e.push(a) } })), e.forEach((e => { e.fire("dragmove", { type: "dragmove", target: e, evt: t }, !0) })) }, _endDragBefore(t) { const e = []; E._dragElements.forEach((r => { const { node: a } = r, n = a.getStage(); t && n.setPointersPositions(t); if (!n._changedPointerPositions.find((t => t.id === r.pointerId))) return; "dragging" !== r.dragStatus && "stopped" !== r.dragStatus || (E.justDragged = !0, i._mouseListenClick = !1, i._touchListenClick = !1, i._pointerListenClick = !1, r.dragStatus = "stopped"); const s = r.node.getLayer() || r.node instanceof i.Stage && r.node; s && -1 === e.indexOf(s) && e.push(s) })), e.forEach((t => { t.draw() })) }, _endDragAfter(t) { E._dragElements.forEach(((e, i) => { "stopped" === e.dragStatus && e.node.fire("dragend", { type: "dragend", target: e.node, evt: t }, !0), "dragging" !== e.dragStatus && E._dragElements.delete(i) })) } }; i.isBrowser && (window.addEventListener("mouseup", E._endDragBefore, !0), window.addEventListener("touchend", E._endDragBefore, !0), window.addEventListener("mousemove", E._drag), window.addEventListener("touchmove", E._drag), window.addEventListener("mouseup", E._endDragAfter, !1), window.addEventListener("touchend", E._endDragAfter, !1)); var D = "absoluteOpacity", L = "allEventListeners", O = "absoluteTransform", I = "absoluteScale", F = "canvas", N = "listening", B = "mouseenter", H = "mouseleave", W = "Shape", z = " ", Y = "stage", X = "transform", j = "visible", q = ["xChange.konva", "yChange.konva", "scaleXChange.konva", "scaleYChange.konva", "skewXChange.konva", "skewYChange.konva", "rotationChange.konva", "offsetXChange.konva", "offsetYChange.konva", "transformsEnabledChange.konva"].join(z); let U = 1; class K { constructor(t) { this._id = U++, this.eventListeners = {}, this.attrs = {}, this.index = 0, this._allEventListeners = null, this.parent = null, this._cache = new Map, this._attachedDepsListeners = new Map, this._lastPos = null, this._batchingTransformChange = !1, this._needClearTransformCache = !1, this._filterUpToDate = !1, this._isUnderCache = !1, this._dragEventId = null, this._shouldFireChangeEvents = !1, this.setAttrs(t), this._shouldFireChangeEvents = !0 } hasChildren() { return !1 } _clearCache(t) { t !== X && t !== O || !this._cache.get(t) ? t ? this._cache.delete(t) : this._cache.clear() : this._cache.get(t).dirty = !0 } _getCache(t, e) { var i = this._cache.get(t); return (void 0 === i || (t === X || t === O) && !0 === i.dirty) && (i = e.call(this), this._cache.set(t, i)), i } _calculate(t, e, i) { if (!this._attachedDepsListeners.get(t)) { const i = e.map((t => t + "Change.konva")).join(z); this.on(i, (() => { this._clearCache(t) })), this._attachedDepsListeners.set(t, !0) } return this._getCache(t, i) } _getCanvasCache() { return this._cache.get(F) } _clearSelfAndDescendantCache(t) { this._clearCache(t), t === O && this.fire("absoluteTransformChange") } clearCache() { if (this._cache.has(F)) { const { scene: t, filter: e, hit: i } = this._cache.get(F); g.releaseCanvas(t, e, i), this._cache.delete(F) } return this._clearSelfAndDescendantCache(), this._requestDraw(), this } cache(t) { var e = t || {}, i = {}; void 0 !== e.x && void 0 !== e.y && void 0 !== e.width && void 0 !== e.height || (i = this.getClientRect({ skipTransform: !0, relativeTo: this.getParent() })); var r = Math.ceil(e.width || i.width), a = Math.ceil(e.height || i.height), n = e.pixelRatio, s = void 0 === e.x ? Math.floor(i.x) : e.x, o = void 0 === e.y ? Math.floor(i.y) : e.y, h = e.offset || 0, l = e.drawBorder || !1, d = e.hitCanvasPixelRatio || 1; if (r && a) { s -= h, o -= h; var c = new G({ pixelRatio: n, width: r += 2 * h + 1, height: a += 2 * h + 1 }), u = new G({ pixelRatio: n, width: 0, height: 0, willReadFrequently: !0 }), f = new R({ pixelRatio: d, width: r, height: a }), p = c.getContext(), v = f.getContext(); return f.isCache = !0, c.isCache = !0, this._cache.delete(F), this._filterUpToDate = !1, !1 === e.imageSmoothingEnabled && (c.getContext()._context.imageSmoothingEnabled = !1, u.getContext()._context.imageSmoothingEnabled = !1), p.save(), v.save(), p.translate(-s, -o), v.translate(-s, -o), this._isUnderCache = !0, this._clearSelfAndDescendantCache(D), this._clearSelfAndDescendantCache(I), this.drawScene(c, this), this.drawHit(f, this), this._isUnderCache = !1, p.restore(), v.restore(), l && (p.save(), p.beginPath(), p.rect(0, 0, r, a), p.closePath(), p.setAttr("strokeStyle", "red"), p.setAttr("lineWidth", 5), p.stroke(), p.restore()), this._cache.set(F, { scene: c, filter: u, hit: f, x: s, y: o }), this._requestDraw(), this } g.error("Can not cache the node. Width or height of the node equals 0. Caching is skipped.") } isCached() { return this._cache.has(F) } getClientRect(t) { throw new Error('abstract "getClientRect" method call') } _transformedRect(t, e) { var i, r, a, n, s = [{ x: t.x, y: t.y }, { x: t.x + t.width, y: t.y }, { x: t.x + t.width, y: t.y + t.height }, { x: t.x, y: t.y + t.height }], o = this.getAbsoluteTransform(e); return s.forEach((function (t) { var e = o.point(t); void 0 === i && (i = a = e.x, r = n = e.y), i = Math.min(i, e.x), r = Math.min(r, e.y), a = Math.max(a, e.x), n = Math.max(n, e.y) })), { x: i, y: r, width: a - i, height: n - r } } _drawCachedSceneCanvas(t) { t.save(), t._applyOpacity(this), t._applyGlobalCompositeOperation(this); const e = this._getCanvasCache(); t.translate(e.x, e.y); var i = this._getCachedSceneCanvas(), r = i.pixelRatio; t.drawImage(i._canvas, 0, 0, i.width / r, i.height / r), t.restore() } _drawCachedHitCanvas(t) { var e = this._getCanvasCache(), i = e.hit; t.save(), t.translate(e.x, e.y), t.drawImage(i._canvas, 0, 0, i.width / i.pixelRatio, i.height / i.pixelRatio), t.restore() } _getCachedSceneCanvas() { var t, e, i, r, a = this.filters(), n = this._getCanvasCache(), s = n.scene, o = n.filter, h = o.getContext(); if (a) { if (!this._filterUpToDate) { var l = s.pixelRatio; o.setSize(s.width / s.pixelRatio, s.height / s.pixelRatio); try { for (t = a.length, h.clear(), h.drawImage(s._canvas, 0, 0, s.getWidth() / l, s.getHeight() / l), e = h.getImageData(0, 0, o.getWidth(), o.getHeight()), i = 0; i < t; i++)"function" == typeof (r = a[i]) ? (r.call(this, e), h.putImageData(e, 0, 0)) : g.error("Filter should be type of function, but got " + typeof r + " instead. Please check correct filters") } catch (t) { g.error("Unable to apply filter. " + t.message + " This post my help you https://konvajs.org/docs/posts/Tainted_Canvas.html.") } this._filterUpToDate = !0 } return o } return s } on(t, e) { if (this._cache && this._cache.delete(L), 3 === arguments.length) return this._delegate.apply(this, arguments); var i, r, a, n, s = t.split(z), o = s.length; for (i = 0; i < o; i++)a = (r = s[i].split("."))[0], n = r[1] || "", this.eventListeners[a] || (this.eventListeners[a] = []), this.eventListeners[a].push({ name: n, handler: e }); return this } off(t, e) { var i, r, a, n, s, o = (t || "").split(z), h = o.length; if (this._cache && this._cache.delete(L), !t) for (r in this.eventListeners) this._off(r); for (i = 0; i < h; i++)if (n = (a = o[i].split("."))[0], s = a[1], n) this.eventListeners[n] && this._off(n, s, e); else for (r in this.eventListeners) this._off(r, s, e); return this } dispatchEvent(t) { var e = { target: this, type: t.type, evt: t }; return this.fire(t.type, e), this } addEventListener(t, e) { return this.on(t, (function (t) { e.call(this, t.evt) })), this } removeEventListener(t) { return this.off(t), this } _delegate(t, e, i) { var r = this; this.on(t, (function (t) { for (var a = t.target.findAncestors(e, !0, r), n = 0; n < a.length; n++)(t = g.cloneObject(t)).currentTarget = a[n], i.call(a[n], t) })) } remove() { return this.isDragging() && this.stopDrag(), E._dragElements.delete(this._id), this._remove(), this } _clearCaches() { this._clearSelfAndDescendantCache(O), this._clearSelfAndDescendantCache(D), this._clearSelfAndDescendantCache(I), this._clearSelfAndDescendantCache(Y), this._clearSelfAndDescendantCache(j), this._clearSelfAndDescendantCache(N) } _remove() { this._clearCaches(); var t = this.getParent(); t && t.children && (t.children.splice(this.index, 1), t._setChildrenIndices(), this.parent = null) } destroy() { return this.remove(), this.clearCache(), this } getAttr(t) { var e = "get" + g._capitalize(t); return g._isFunction(this[e]) ? this[e]() : this.attrs[t] } getAncestors() { for (var t = this.getParent(), e = []; t;)e.push(t), t = t.getParent(); return e } getAttrs() { return this.attrs || {} } setAttrs(t) { return this._batchTransformChanges((() => { var e, i; if (!t) return this; for (e in t) "children" !== e && (i = "set" + g._capitalize(e), g._isFunction(this[i]) ? this[i](t[e]) : this._setAttr(e, t[e])) })), this } isListening() { return this._getCache(N, this._isListening) } _isListening(t) { if (!this.listening()) return !1; const e = this.getParent(); return !e || e === t || this === t || e._isListening(t) } isVisible() { return this._getCache(j, this._isVisible) } _isVisible(t) { if (!this.visible()) return !1; const e = this.getParent(); return !e || e === t || this === t || e._isVisible(t) } shouldDrawHit(t, e = !1) { if (t) return this._isVisible(t) && this._isListening(t); var r = this.getLayer(), a = !1; E._dragElements.forEach((t => { "dragging" === t.dragStatus && ("Stage" === t.node.nodeType || t.node.getLayer() === r) && (a = !0) })); var n = !e && !i.hitOnDragEnabled && a; return this.isListening() && this.isVisible() && !n } show() { return this.visible(!0), this } hide() { return this.visible(!1), this } getZIndex() { return this.index || 0 } getAbsoluteZIndex() { var t, e, i, r, a = this.getDepth(), n = this, s = 0; return "Stage" !== n.nodeType && function o(h) { for (t = [], e = h.length, i = 0; i < e; i++)r = h[i], s++, r.nodeType !== W && (t = t.concat(r.getChildren().slice())), r._id === n._id && (i = e); t.length > 0 && t[0].getDepth() <= a && o(t) }(n.getStage().getChildren()), s } getDepth() { for (var t = 0, e = this.parent; e;)t++, e = e.parent; return t } _batchTransformChanges(t) { this._batchingTransformChange = !0, t(), this._batchingTransformChange = !1, this._needClearTransformCache && (this._clearCache(X), this._clearSelfAndDescendantCache(O)), this._needClearTransformCache = !1 } setPosition(t) { return this._batchTransformChanges((() => { this.x(t.x), this.y(t.y) })), this } getPosition() { return { x: this.x(), y: this.y() } } getRelativePointerPosition() { if (!this.getStage()) return null; var t = this.getStage().getPointerPosition(); if (!t) return null; var e = this.getAbsoluteTransform().copy(); return e.invert(), e.point(t) } getAbsolutePosition(t) { let e = !1, i = this.parent; for (; i;) { if (i.isCached()) { e = !0; break } i = i.parent } e && !t && (t = !0); var r = this.getAbsoluteTransform(t).getMatrix(), n = new a, s = this.offset(); return n.m = r.slice(), n.translate(s.x, s.y), n.getTranslation() } setAbsolutePosition(t) { var e = this._clearTransform(); this.attrs.x = e.x, this.attrs.y = e.y, delete e.x, delete e.y, this._clearCache(X); var i = this._getAbsoluteTransform().copy(); return i.invert(), i.translate(t.x, t.y), t = { x: this.attrs.x + i.getTranslation().x, y: this.attrs.y + i.getTranslation().y }, this._setTransform(e), this.setPosition({ x: t.x, y: t.y }), this._clearCache(X), this._clearSelfAndDescendantCache(O), this } _setTransform(t) { var e; for (e in t) this.attrs[e] = t[e] } _clearTransform() { var t = { x: this.x(), y: this.y(), rotation: this.rotation(), scaleX: this.scaleX(), scaleY: this.scaleY(), offsetX: this.offsetX(), offsetY: this.offsetY(), skewX: this.skewX(), skewY: this.skewY() }; return this.attrs.x = 0, this.attrs.y = 0, this.attrs.rotation = 0, this.attrs.scaleX = 1, this.attrs.scaleY = 1, this.attrs.offsetX = 0, this.attrs.offsetY = 0, this.attrs.skewX = 0, this.attrs.skewY = 0, t } move(t) { var e = t.x, i = t.y, r = this.x(), a = this.y(); return void 0 !== e && (r += e), void 0 !== i && (a += i), this.setPosition({ x: r, y: a }), this } _eachAncestorReverse(t, e) { var i, r, a = [], n = this.getParent(); if (!e || e._id !== this._id) { for (a.unshift(this); n && (!e || n._id !== e._id);)a.unshift(n), n = n.parent; for (i = a.length, r = 0; r < i; r++)t(a[r]) } } rotate(t) { return this.rotation(this.rotation() + t), this } moveToTop() { if (!this.parent) return g.warn("Node has no parent. moveToTop function is ignored."), !1; var t = this.index; return t < this.parent.getChildren().length - 1 && (this.parent.children.splice(t, 1), this.parent.children.push(this), this.parent._setChildrenIndices(), !0) } moveUp() { if (!this.parent) return g.warn("Node has no parent. moveUp function is ignored."), !1; var t = this.index; return t < this.parent.getChildren().length - 1 && (this.parent.children.splice(t, 1), this.parent.children.splice(t + 1, 0, this), this.parent._setChildrenIndices(), !0) } moveDown() { if (!this.parent) return g.warn("Node has no parent. moveDown function is ignored."), !1; var t = this.index; return t > 0 && (this.parent.children.splice(t, 1), this.parent.children.splice(t - 1, 0, this), this.parent._setChildrenIndices(), !0) } moveToBottom() { if (!this.parent) return g.warn("Node has no parent. moveToBottom function is ignored."), !1; var t = this.index; return t > 0 && (this.parent.children.splice(t, 1), this.parent.children.unshift(this), this.parent._setChildrenIndices(), !0) } setZIndex(t) { if (!this.parent) return g.warn("Node has no parent. zIndex parameter is ignored."), this; (t < 0 || t >= this.parent.children.length) && g.warn("Unexpected value " + t + " for zIndex property. zIndex is just index of a node in children of its parent. Expected value is from 0 to " + (this.parent.children.length - 1) + "."); var e = this.index; return this.parent.children.splice(e, 1), this.parent.children.splice(t, 0, this), this.parent._setChildrenIndices(), this } getAbsoluteOpacity() { return this._getCache(D, this._getAbsoluteOpacity) } _getAbsoluteOpacity() { var t = this.opacity(), e = this.getParent(); return e && !e._isUnderCache && (t *= e.getAbsoluteOpacity()), t } moveTo(t) { return this.getParent() !== t && (this._remove(), t.add(this)), this } toObject() { var t, e, i, r, a = {}, n = this.getAttrs(); for (t in a.attrs = {}, n) e = n[t], g.isObject(e) && !g._isPlainObject(e) && !g._isArray(e) || (i = "function" == typeof this[t] && this[t], delete n[t], r = i ? i.call(this) : null, n[t] = e, r !== e && (a.attrs[t] = e)); return a.className = this.getClassName(), g._prepareToStringify(a) } toJSON() { return JSON.stringify(this.toObject()) } getParent() { return this.parent } findAncestors(t, e, i) { var r = []; e && this._isMatch(t) && r.push(this); for (var a = this.parent; a;) { if (a === i) return r; a._isMatch(t) && r.push(a), a = a.parent } return r } isAncestorOf(t) { return !1 } findAncestor(t, e, i) { return this.findAncestors(t, e, i)[0] } _isMatch(t) { if (!t) return !1; if ("function" == typeof t) return t(this); var e, i, r = t.replace(/ /g, "").split(","), a = r.length; for (e = 0; e < a; e++)if (i = r[e], g.isValidSelector(i) || (g.warn('Selector "' + i + '" is invalid. Allowed selectors examples are "#foo", ".bar" or "Group".'), g.warn('If you have a custom shape with such className, please change it to start with upper letter like "Triangle".'), g.warn("Konva is awesome, right?")), "#" === i.charAt(0)) { if (this.id() === i.slice(1)) return !0 } else if ("." === i.charAt(0)) { if (this.hasName(i.slice(1))) return !0 } else if (this.className === i || this.nodeType === i) return !0; return !1 } getLayer() { var t = this.getParent(); return t ? t.getLayer() : null } getStage() { return this._getCache(Y, this._getStage) } _getStage() { var t = this.getParent(); return t ? t.getStage() : void 0 } fire(t, e = {}, i) { return e.target = e.target || this, i ? this._fireAndBubble(t, e) : this._fire(t, e), this } getAbsoluteTransform(t) { return t ? this._getAbsoluteTransform(t) : this._getCache(O, this._getAbsoluteTransform) } _getAbsoluteTransform(t) { var e; if (t) return e = new a, this._eachAncestorReverse((function (t) { var i = t.transformsEnabled(); "all" === i ? e.multiply(t.getTransform()) : "position" === i && e.translate(t.x() - t.offsetX(), t.y() - t.offsetY()) }), t), e; e = this._cache.get(O) || new a, this.parent ? this.parent.getAbsoluteTransform().copyInto(e) : e.reset(); var i = this.transformsEnabled(); if ("all" === i) e.multiply(this.getTransform()); else if ("position" === i) { const t = this.attrs.x || 0, i = this.attrs.y || 0, r = this.attrs.offsetX || 0, a = this.attrs.offsetY || 0; e.translate(t - r, i - a) } return e.dirty = !1, e } getAbsoluteScale(t) { for (var e = this; e;)e._isUnderCache && (t = e), e = e.getParent(); const i = this.getAbsoluteTransform(t).decompose(); return { x: i.scaleX, y: i.scaleY } } getAbsoluteRotation() { return this.getAbsoluteTransform().decompose().rotation } getTransform() { return this._getCache(X, this._getTransform) } _getTransform() { var t, e, r = this._cache.get(X) || new a; r.reset(); var n = this.x(), s = this.y(), o = i.getAngle(this.rotation()), h = null !== (t = this.attrs.scaleX) && void 0 !== t ? t : 1, l = null !== (e = this.attrs.scaleY) && void 0 !== e ? e : 1, d = this.attrs.skewX || 0, c = this.attrs.skewY || 0, g = this.attrs.offsetX || 0, u = this.attrs.offsetY || 0; return 0 === n && 0 === s || r.translate(n, s), 0 !== o && r.rotate(o), 0 === d && 0 === c || r.skew(d, c), 1 === h && 1 === l || r.scale(h, l), 0 === g && 0 === u || r.translate(-1 * g, -1 * u), r.dirty = !1, r } clone(t) { var e, i, r, a, n, s = g.cloneObject(this.attrs); for (e in t) s[e] = t[e]; var o = new this.constructor(s); for (e in this.eventListeners) for (r = (i = this.eventListeners[e]).length, a = 0; a < r; a++)(n = i[a]).name.indexOf("konva") < 0 && (o.eventListeners[e] || (o.eventListeners[e] = []), o.eventListeners[e].push(n)); return o } _toKonvaCanvas(t) { t = t || {}; var e = this.getClientRect(), i = this.getStage(), r = void 0 !== t.x ? t.x : Math.floor(e.x), a = void 0 !== t.y ? t.y : Math.floor(e.y), n = t.pixelRatio || 1, s = new G({ width: t.width || Math.ceil(e.width) || (i ? i.width() : 0), height: t.height || Math.ceil(e.height) || (i ? i.height() : 0), pixelRatio: n }), o = s.getContext(); return !1 === t.imageSmoothingEnabled && (o._context.imageSmoothingEnabled = !1), o.save(), (r || a) && o.translate(-1 * r, -1 * a), this.drawScene(s), o.restore(), s } toCanvas(t) { return this._toKonvaCanvas(t)._canvas } toDataURL(t) { var e = (t = t || {}).mimeType || null, i = t.quality || null, r = this._toKonvaCanvas(t).toDataURL(e, i); return t.callback && t.callback(r), r } toImage(t) { return new Promise(((e, i) => { try { const i = null == t ? void 0 : t.callback; i && delete t.callback, g._urlToImage(this.toDataURL(t), (function (t) { e(t), null == i || i(t) })) } catch (t) { i(t) } })) } toBlob(t) { return new Promise(((e, i) => { try { const i = null == t ? void 0 : t.callback; i && delete t.callback, this.toCanvas(t).toBlob((t => { e(t), null == i || i(t) })) } catch (t) { i(t) } })) } setSize(t) { return this.width(t.width), this.height(t.height), this } getSize() { return { width: this.width(), height: this.height() } } getClassName() { return this.className || this.nodeType } getType() { return this.nodeType } getDragDistance() { return void 0 !== this.attrs.dragDistance ? this.attrs.dragDistance : this.parent ? this.parent.getDragDistance() : i.dragDistance } _off(t, e, i) { var r, a, n, s = this.eventListeners[t]; for (r = 0; r < s.length; r++)if (a = s[r].name, n = s[r].handler, !("konva" === a && "konva" !== e || e && a !== e || i && i !== n)) { if (s.splice(r, 1), 0 === s.length) { delete this.eventListeners[t]; break } r-- } } _fireChangeEvent(t, e, i) { this._fire(t + "Change", { oldVal: e, newVal: i }) } addName(t) { if (!this.hasName(t)) { var e = this.name(), i = e ? e + " " + t : t; this.name(i) } return this } hasName(t) { if (!t) return !1; const e = this.name(); return !!e && -1 !== (e || "").split(/\s/g).indexOf(t) } removeName(t) { var e = (this.name() || "").split(/\s/g), i = e.indexOf(t); return -1 !== i && (e.splice(i, 1), this.name(e.join(" "))), this } setAttr(t, e) { var i = this["set" + g._capitalize(t)]; return g._isFunction(i) ? i.call(this, e) : this._setAttr(t, e), this } _requestDraw() { if (i.autoDrawEnabled) { const t = this.getLayer() || this.getStage(); null == t || t.batchDraw() } } _setAttr(t, e) { var i = this.attrs[t]; (i !== e || g.isObject(e)) && (null == e ? delete this.attrs[t] : this.attrs[t] = e, this._shouldFireChangeEvents && this._fireChangeEvent(t, i, e), this._requestDraw()) } _setComponentAttr(t, e, i) { var r; void 0 !== i && ((r = this.attrs[t]) || (this.attrs[t] = this.getAttr(t)), this.attrs[t][e] = i, this._fireChangeEvent(t, r, i)) } _fireAndBubble(t, e, i) { if (e && this.nodeType === W && (e.target = this), !((t === B || t === H) && (i && (this === i || this.isAncestorOf && this.isAncestorOf(i)) || "Stage" === this.nodeType && !i))) { this._fire(t, e); var r = (t === B || t === H) && i && i.isAncestorOf && i.isAncestorOf(this) && !i.isAncestorOf(this.parent); (e && !e.cancelBubble || !e) && this.parent && this.parent.isListening() && !r && (i && i.parent ? this._fireAndBubble.call(this.parent, t, e, i) : this._fireAndBubble.call(this.parent, t, e)) } } _getProtoListeners(t) { var e, i, r; const a = null !== (e = this._cache.get(L)) && void 0 !== e ? e : {}; let n = null == a ? void 0 : a[t]; if (void 0 === n) { n = []; let e = Object.getPrototypeOf(this); for (; e;) { const a = null !== (r = null === (i = e.eventListeners) || void 0 === i ? void 0 : i[t]) && void 0 !== r ? r : []; n.push(...a), e = Object.getPrototypeOf(e) } a[t] = n, this._cache.set(L, a) } return n } _fire(t, e) { (e = e || {}).currentTarget = this, e.type = t; const i = this._getProtoListeners(t); if (i) for (var r = 0; r < i.length; r++)i[r].handler.call(this, e); const a = this.eventListeners[t]; if (a) for (r = 0; r < a.length; r++)a[r].handler.call(this, e) } draw() { return this.drawScene(), this.drawHit(), this } _createDragElement(t) { var e = t ? t.pointerId : void 0, i = this.getStage(), r = this.getAbsolutePosition(), a = i._getPointerById(e) || i._changedPointerPositions[0] || r; E._dragElements.set(this._id, { node: this, startPointerPos: a, offset: { x: a.x - r.x, y: a.y - r.y }, dragStatus: "ready", pointerId: e }) } startDrag(t, e = !0) { E._dragElements.has(this._id) || this._createDragElement(t); E._dragElements.get(this._id).dragStatus = "dragging", this.fire("dragstart", { type: "dragstart", target: this, evt: t && t.evt }, e) } _setDragPosition(t, e) { const i = this.getStage()._getPointerById(e.pointerId); if (i) { var r = { x: i.x - e.offset.x, y: i.y - e.offset.y }, a = this.dragBoundFunc(); if (void 0 !== a) { const e = a.call(this, r, t); e ? r = e : g.warn("dragBoundFunc did not return any value. That is unexpected behavior. You must return new absolute position from dragBoundFunc.") } this._lastPos && this._lastPos.x === r.x && this._lastPos.y === r.y || (this.setAbsolutePosition(r), this._requestDraw()), this._lastPos = r } } stopDrag(t) { const e = E._dragElements.get(this._id); e && (e.dragStatus = "stopped"), E._endDragBefore(t), E._endDragAfter(t) } setDraggable(t) { this._setAttr("draggable", t), this._dragChange() } isDragging() { const t = E._dragElements.get(this._id); return !!t && "dragging" === t.dragStatus } _listenDrag() { this._dragCleanup(), this.on("mousedown.konva touchstart.konva", (function (t) { if ((!(void 0 !== t.evt.button) || i.dragButtons.indexOf(t.evt.button) >= 0) && !this.isDragging()) { var e = !1; E._dragElements.forEach((t => { this.isAncestorOf(t.node) && (e = !0) })), e || this._createDragElement(t) } })) } _dragChange() { if (this.attrs.draggable) this._listenDrag(); else { if (this._dragCleanup(), !this.getStage()) return; const t = E._dragElements.get(this._id), e = t && "dragging" === t.dragStatus, i = t && "ready" === t.dragStatus; e ? this.stopDrag() : i && E._dragElements.delete(this._id) } } _dragCleanup() { this.off("mousedown.konva"), this.off("touchstart.konva") } isClientRectOnScreen(t = { x: 0, y: 0 }) { const e = this.getStage(); if (!e) return !1; const i = { x: -t.x, y: -t.y, width: e.width() + 2 * t.x, height: e.height() + 2 * t.y }; return g.haveIntersection(i, this.getClientRect()) } static create(t, e) { return g._isString(t) && (t = JSON.parse(t)), this._createNode(t, e) } static _createNode(t, e) { var r, a, n, s = K.prototype.getClassName.call(t), o = t.children; e && (t.attrs.container = e), i[s] || (g.warn('Can not find a node with class name "' + s + '". Fallback to "Shape".'), s = "Shape"); if (r = new (0, i[s])(t.attrs), o) for (a = o.length, n = 0; n < a; n++)r.add(K._createNode(o[n])); return r } } K.prototype.nodeType = "Node", K.prototype._attrsAffectingSize = [], K.prototype.eventListeners = {}, K.prototype.on.call(K.prototype, q, (function () { this._batchingTransformChange ? this._needClearTransformCache = !0 : (this._clearCache(X), this._clearSelfAndDescendantCache(O)) })), K.prototype.on.call(K.prototype, "visibleChange.konva", (function () { this._clearSelfAndDescendantCache(j) })), K.prototype.on.call(K.prototype, "listeningChange.konva", (function () { this._clearSelfAndDescendantCache(N) })), K.prototype.on.call(K.prototype, "opacityChange.konva", (function () { this._clearSelfAndDescendantCache(D) })); const V = w.addGetterSetter; V(K, "zIndex"), V(K, "absolutePosition"), V(K, "position"), V(K, "x", 0, p()), V(K, "y", 0, p()), V(K, "globalCompositeOperation", "source-over", _()), V(K, "opacity", 1, p()), V(K, "name", "", _()), V(K, "id", "", _()), V(K, "rotation", 0, p()), w.addComponentsGetterSetter(K, "scale", ["x", "y"]), V(K, "scaleX", 1, p()), V(K, "scaleY", 1, p()), w.addComponentsGetterSetter(K, "skew", ["x", "y"]), V(K, "skewX", 0, p()), V(K, "skewY", 0, p()), w.addComponentsGetterSetter(K, "offset", ["x", "y"]), V(K, "offsetX", 0, p()), V(K, "offsetY", 0, p()), V(K, "dragDistance", null, p()), V(K, "width", 0, p()), V(K, "height", 0, p()), V(K, "listening", !0, x()), V(K, "preventDefault", !0, x()), V(K, "filters", null, (function (t) { return this._filterUpToDate = !1, t })), V(K, "visible", !0, x()), V(K, "transformsEnabled", "all", _()), V(K, "size"), V(K, "dragBoundFunc"), V(K, "draggable", !1, x()), w.backCompat(K, { rotateDeg: "rotate", setRotationDeg: "setRotation", getRotationDeg: "getRotation" }); class Q extends K { constructor() { super(...arguments), this.children = [] } getChildren(t) { if (!t) return this.children || []; const e = this.children || []; var i = []; return e.forEach((function (e) { t(e) && i.push(e) })), i } hasChildren() { return this.getChildren().length > 0 } removeChildren() { return this.getChildren().forEach((t => { t.parent = null, t.index = 0, t.remove() })), this.children = [], this._requestDraw(), this } destroyChildren() { return this.getChildren().forEach((t => { t.parent = null, t.index = 0, t.destroy() })), this.children = [], this._requestDraw(), this } add(...t) { if (0 === t.length) return this; if (t.length > 1) { for (var e = 0; e < t.length; e++)this.add(t[e]); return this } const i = t[0]; return i.getParent() ? (i.moveTo(this), this) : (this._validateAdd(i), i.index = this.getChildren().length, i.parent = this, i._clearCaches(), this.getChildren().push(i), this._fire("add", { child: i }), this._requestDraw(), this) } destroy() { return this.hasChildren() && this.destroyChildren(), super.destroy(), this } find(t) { return this._generalFind(t, !1) } findOne(t) { var e = this._generalFind(t, !0); return e.length > 0 ? e[0] : void 0 } _generalFind(t, e) { var i = []; return this._descendants((r => { const a = r._isMatch(t); return a && i.push(r), !(!a || !e) })), i } _descendants(t) { let e = !1; const i = this.getChildren(); for (const r of i) { if (e = t(r), e) return !0; if (r.hasChildren() && (e = r._descendants(t), e)) return !0 } return !1 } toObject() { var t = K.prototype.toObject.call(this); return t.children = [], this.getChildren().forEach((e => { t.children.push(e.toObject()) })), t } isAncestorOf(t) { for (var e = t.getParent(); e;) { if (e._id === this._id) return !0; e = e.getParent() } return !1 } clone(t) { var e = K.prototype.clone.call(this, t); return this.getChildren().forEach((function (t) { e.add(t.clone()) })), e } getAllIntersections(t) { var e = []; return this.find("Shape").forEach((function (i) { i.isVisible() && i.intersects(t) && e.push(i) })), e } _clearSelfAndDescendantCache(t) { var e; super._clearSelfAndDescendantCache(t), this.isCached() || null === (e = this.children) || void 0 === e || e.forEach((function (e) { e._clearSelfAndDescendantCache(t) })) } _setChildrenIndices() { var t; null === (t = this.children) || void 0 === t || t.forEach((function (t, e) { t.index = e })), this._requestDraw() } drawScene(t, e) { var i = this.getLayer(), r = t || i && i.getCanvas(), a = r && r.getContext(), n = this._getCanvasCache(), s = n && n.scene, o = r && r.isCache; if (!this.isVisible() && !o) return this; if (s) { a.save(); var h = this.getAbsoluteTransform(e).getMatrix(); a.transform(h[0], h[1], h[2], h[3], h[4], h[5]), this._drawCachedSceneCanvas(a), a.restore() } else this._drawChildren("drawScene", r, e); return this } drawHit(t, e) { if (!this.shouldDrawHit(e)) return this; var i = this.getLayer(), r = t || i && i.hitCanvas, a = r && r.getContext(), n = this._getCanvasCache(); if (n && n.hit) { a.save(); var s = this.getAbsoluteTransform(e).getMatrix(); a.transform(s[0], s[1], s[2], s[3], s[4], s[5]), this._drawCachedHitCanvas(a), a.restore() } else this._drawChildren("drawHit", r, e); return this } _drawChildren(t, e, i) { var r, a = e && e.getContext(), n = this.clipWidth(), s = this.clipHeight(), o = this.clipFunc(), h = n && s || o; const l = i === this; if (h) { a.save(); var d = this.getAbsoluteTransform(i), c = d.getMatrix(); if (a.transform(c[0], c[1], c[2], c[3], c[4], c[5]), a.beginPath(), o) o.call(this, a, this); else { var g = this.clipX(), u = this.clipY(); a.rect(g, u, n, s) } a.clip(), c = d.copy().invert().getMatrix(), a.transform(c[0], c[1], c[2], c[3], c[4], c[5]) } var f = !l && "source-over" !== this.globalCompositeOperation() && "drawScene" === t; f && (a.save(), a._applyGlobalCompositeOperation(this)), null === (r = this.children) || void 0 === r || r.forEach((function (r) { r[t](e, i) })), f && a.restore(), h && a.restore() } getClientRect(t) { var e, i, r, a, n, s = (t = t || {}).skipTransform, o = t.relativeTo, h = { x: 1 / 0, y: 1 / 0, width: 0, height: 0 }, l = this; null === (e = this.children) || void 0 === e || e.forEach((function (e) { if (e.visible()) { var s = e.getClientRect({ relativeTo: l, skipShadow: t.skipShadow, skipStroke: t.skipStroke }); 0 === s.width && 0 === s.height || (void 0 === i ? (i = s.x, r = s.y, a = s.x + s.width, n = s.y + s.height) : (i = Math.min(i, s.x), r = Math.min(r, s.y), a = Math.max(a, s.x + s.width), n = Math.max(n, s.y + s.height))) } })); for (var d = this.find("Shape"), c = !1, g = 0; g < d.length; g++) { if (d[g]._isVisible(this)) { c = !0; break } } return h = c && void 0 !== i ? { x: i, y: r, width: a - i, height: n - r } : { x: 0, y: 0, width: 0, height: 0 }, s ? h : this._transformedRect(h, o) } } w.addComponentsGetterSetter(Q, "clip", ["x", "y", "width", "height"]), w.addGetterSetter(Q, "clipX", void 0, p()), w.addGetterSetter(Q, "clipY", void 0, p()), w.addGetterSetter(Q, "clipWidth", void 0, p()), w.addGetterSetter(Q, "clipHeight", void 0, p()), w.addGetterSetter(Q, "clipFunc"); const J = new Map, Z = void 0 !== i._global.PointerEvent; function $(t) { return J.get(t) } function tt(t) { return { evt: t, pointerId: t.pointerId } } function et(t, e) { return J.get(t) === e } function it(t, e) { rt(t); e.getStage() && (J.set(t, e), Z && e._fire("gotpointercapture", tt(new PointerEvent("gotpointercapture")))) } function rt(t, e) { const i = J.get(t); if (!i) return; const r = i.getStage(); r && r.content, J.delete(t), Z && i._fire("lostpointercapture", tt(new PointerEvent("lostpointercapture"))) } var at = "mouseleave", nt = "mouseover", st = "mouseenter", ot = "mousemove", ht = "mousedown", lt = "mouseup", dt = "pointermove", ct = "pointerdown", gt = "pointerup", ut = "pointercancel", ft = "pointerout", pt = "pointerleave", vt = "pointerover", mt = "pointerenter", _t = "contextmenu", yt = "touchstart", xt = "touchend", bt = "touchmove", St = "touchcancel", wt = "wheel", Ct = [[st, "_pointerenter"], [ht, "_pointerdown"], [ot, "_pointermove"], [lt, "_pointerup"], [at, "_pointerleave"], [yt, "_pointerdown"], [bt, "_pointermove"], [xt, "_pointerup"], [St, "_pointercancel"], [nt, "_pointerover"], [wt, "_wheel"], [_t, "_contextmenu"], [ct, "_pointerdown"], [dt, "_pointermove"], [gt, "_pointerup"], [ut, "_pointercancel"], ["lostpointercapture", "_lostpointercapture"]]; const Pt = { mouse: { [ft]: "mouseout", [pt]: at, [vt]: nt, [mt]: st, [dt]: ot, [ct]: ht, [gt]: lt, [ut]: "mousecancel", pointerclick: "click", pointerdblclick: "dblclick" }, touch: { [ft]: "touchout", [pt]: "touchleave", [vt]: "touchover", [mt]: "touchenter", [dt]: bt, [ct]: yt, [gt]: xt, [ut]: St, pointerclick: "tap", pointerdblclick: "dbltap" }, pointer: { [ft]: ft, [pt]: pt, [vt]: vt, [mt]: mt, [dt]: dt, [ct]: ct, [gt]: gt, [ut]: ut, pointerclick: "pointerclick", pointerdblclick: "pointerdblclick" } }, kt = t => t.indexOf("pointer") >= 0 ? "pointer" : t.indexOf("touch") >= 0 ? "touch" : "mouse", Tt = t => { const e = kt(t); return "pointer" === e ? i.pointerEventsEnabled && Pt.pointer : "touch" === e ? Pt.touch : "mouse" === e ? Pt.mouse : void 0 }; function At(t = {}) { return (t.clipFunc || t.clipWidth || t.clipHeight) && g.warn("Stage does not support clipping. Please use clip for Layers or Groups."), t } const Mt = []; class Gt extends Q { constructor(t) { super(At(t)), this._pointerPositions = [], this._changedPointerPositions = [], this._buildDOM(), this._bindContentEvents(), Mt.push(this), this.on("widthChange.konva heightChange.konva", this._resizeDOM), this.on("visibleChange.konva", this._checkVisibility), this.on("clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva", (() => { At(this.attrs) })), this._checkVisibility() } _validateAdd(t) { const e = "Layer" === t.getType(), i = "FastLayer" === t.getType(); e || i || g.throw("You may only add layers to the stage.") } _checkVisibility() { if (!this.content) return; const t = this.visible() ? "" : "none"; this.content.style.display = t } setContainer(t) { if ("string" == typeof t) { if ("." === t.charAt(0)) { var e = t.slice(1); t = document.getElementsByClassName(e)[0] } else { var i; i = "#" !== t.charAt(0) ? t : t.slice(1), t = document.getElementById(i) } if (!t) throw "Can not find container in document with id " + i } return this._setAttr("container", t), this.content && (this.content.parentElement && this.content.parentElement.removeChild(this.content), t.appendChild(this.content)), this } shouldDrawHit() { return !0 } clear() { var t, e = this.children, i = e.length; for (t = 0; t < i; t++)e[t].clear(); return this } clone(t) { return t || (t = {}), t.container = "undefined" != typeof document && document.createElement("div"), Q.prototype.clone.call(this, t) } destroy() { super.destroy(); var t = this.content; t && g._isInDocument(t) && this.container().removeChild(t); var e = Mt.indexOf(this); return e > -1 && Mt.splice(e, 1), g.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas), this } getPointerPosition() { const t = this._pointerPositions[0] || this._changedPointerPositions[0]; return t ? { x: t.x, y: t.y } : (g.warn("Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);"), null) } _getPointerById(t) { return this._pointerPositions.find((e => e.id === t)) } getPointersPositions() { return this._pointerPositions } getStage() { return this } getContent() { return this.content } _toKonvaCanvas(t) { (t = t || {}).x = t.x || 0, t.y = t.y || 0, t.width = t.width || this.width(), t.height = t.height || this.height(); var e = new G({ width: t.width, height: t.height, pixelRatio: t.pixelRatio || 1 }), i = e.getContext()._context, r = this.children; return (t.x || t.y) && i.translate(-1 * t.x, -1 * t.y), r.forEach((function (e) { if (e.isVisible()) { var r = e._toKonvaCanvas(t); i.drawImage(r._canvas, t.x, t.y, r.getWidth() / r.getPixelRatio(), r.getHeight() / r.getPixelRatio()) } })), e } getIntersection(t) { if (!t) return null; var e, i = this.children; for (e = i.length - 1; e >= 0; e--) { const r = i[e].getIntersection(t); if (r) return r } return null } _resizeDOM() { var t = this.width(), e = this.height(); this.content && (this.content.style.width = t + "px", this.content.style.height = e + "px"), this.bufferCanvas.setSize(t, e), this.bufferHitCanvas.setSize(t, e), this.children.forEach((i => { i.setSize({ width: t, height: e }), i.draw() })) } add(t, ...e) { if (arguments.length > 1) { for (var r = 0; r < arguments.length; r++)this.add(arguments[r]); return this } super.add(t); var a = this.children.length; return a > 5 && g.warn("The stage has " + a + " layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group."), t.setSize({ width: this.width(), height: this.height() }), t.draw(), i.isBrowser && this.content.appendChild(t.canvas._canvas), this } getParent() { return null } getLayer() { return null } hasPointerCapture(t) { return et(t, this) } setPointerCapture(t) { it(t, this) } releaseCapture(t) { rt(t) } getLayers() { return this.children } _bindContentEvents() { i.isBrowser && Ct.forEach((([t, e]) => { this.content.addEventListener(t, (t => { this[e](t) }), { passive: !1 }) })) } _pointerenter(t) { this.setPointersPositions(t); const e = Tt(t.type); this._fire(e.pointerenter, { evt: t, target: this, currentTarget: this }) } _pointerover(t) { this.setPointersPositions(t); const e = Tt(t.type); this._fire(e.pointerover, { evt: t, target: this, currentTarget: this }) } _getTargetShape(t) { let e = this[t + "targetShape"]; return e && !e.getStage() && (e = null), e } _pointerleave(t) { const e = Tt(t.type), r = kt(t.type); if (e) { this.setPointersPositions(t); var a = this._getTargetShape(r), n = !E.isDragging || i.hitOnDragEnabled; a && n ? (a._fireAndBubble(e.pointerout, { evt: t }), a._fireAndBubble(e.pointerleave, { evt: t }), this._fire(e.pointerleave, { evt: t, target: this, currentTarget: this }), this[r + "targetShape"] = null) : n && (this._fire(e.pointerleave, { evt: t, target: this, currentTarget: this }), this._fire(e.pointerout, { evt: t, target: this, currentTarget: this })), this.pointerPos = void 0, this._pointerPositions = [] } } _pointerdown(t) { const e = Tt(t.type), r = kt(t.type); if (e) { this.setPointersPositions(t); var a = !1; this._changedPointerPositions.forEach((n => { var s = this.getIntersection(n); E.justDragged = !1, i["_" + r + "ListenClick"] = !0; if (!(s && s.isListening())) return; i.capturePointerEventsEnabled && s.setPointerCapture(n.id), this[r + "ClickStartShape"] = s, s._fireAndBubble(e.pointerdown, { evt: t, pointerId: n.id }), a = !0; const o = t.type.indexOf("touch") >= 0; s.preventDefault() && t.cancelable && o && t.preventDefault() })), a || this._fire(e.pointerdown, { evt: t, target: this, currentTarget: this, pointerId: this._pointerPositions[0].id }) } } _pointermove(t) { const e = Tt(t.type), r = kt(t.type); if (!e) return; if (E.isDragging && E.node.preventDefault() && t.cancelable && t.preventDefault(), this.setPointersPositions(t), !(!E.isDragging || i.hitOnDragEnabled)) return; var a = {}; let n = !1; var s = this._getTargetShape(r); this._changedPointerPositions.forEach((i => { const o = $(i.id) || this.getIntersection(i), h = i.id, l = { evt: t, pointerId: h }; var d = s !== o; if (d && s && (s._fireAndBubble(e.pointerout, Object.assign({}, l), o), s._fireAndBubble(e.pointerleave, Object.assign({}, l), o)), o) { if (a[o._id]) return; a[o._id] = !0 } o && o.isListening() ? (n = !0, d && (o._fireAndBubble(e.pointerover, Object.assign({}, l), s), o._fireAndBubble(e.pointerenter, Object.assign({}, l), s), this[r + "targetShape"] = o), o._fireAndBubble(e.pointermove, Object.assign({}, l))) : s && (this._fire(e.pointerover, { evt: t, target: this, currentTarget: this, pointerId: h }), this[r + "targetShape"] = null) })), n || this._fire(e.pointermove, { evt: t, target: this, currentTarget: this, pointerId: this._changedPointerPositions[0].id }) } _pointerup(t) { const e = Tt(t.type), r = kt(t.type); if (!e) return; this.setPointersPositions(t); const a = this[r + "ClickStartShape"], n = this[r + "ClickEndShape"]; var s = {}; let o = !1; this._changedPointerPositions.forEach((h => { const l = $(h.id) || this.getIntersection(h); if (l) { if (l.releaseCapture(h.id), s[l._id]) return; s[l._id] = !0 } const d = h.id, c = { evt: t, pointerId: d }; let g = !1; i["_" + r + "InDblClickWindow"] ? (g = !0, clearTimeout(this[r + "DblTimeout"])) : E.justDragged || (i["_" + r + "InDblClickWindow"] = !0, clearTimeout(this[r + "DblTimeout"])), this[r + "DblTimeout"] = setTimeout((function () { i["_" + r + "InDblClickWindow"] = !1 }), i.dblClickWindow), l && l.isListening() ? (o = !0, this[r + "ClickEndShape"] = l, l._fireAndBubble(e.pointerup, Object.assign({}, c)), i["_" + r + "ListenClick"] && a && a === l && (l._fireAndBubble(e.pointerclick, Object.assign({}, c)), g && n && n === l && l._fireAndBubble(e.pointerdblclick, Object.assign({}, c)))) : (this[r + "ClickEndShape"] = null, i["_" + r + "ListenClick"] && this._fire(e.pointerclick, { evt: t, target: this, currentTarget: this, pointerId: d }), g && this._fire(e.pointerdblclick, { evt: t, target: this, currentTarget: this, pointerId: d })) })), o || this._fire(e.pointerup, { evt: t, target: this, currentTarget: this, pointerId: this._changedPointerPositions[0].id }), i["_" + r + "ListenClick"] = !1, t.cancelable && "touch" !== r && t.preventDefault() } _contextmenu(t) { this.setPointersPositions(t); var e = this.getIntersection(this.getPointerPosition()); e && e.isListening() ? e._fireAndBubble(_t, { evt: t }) : this._fire(_t, { evt: t, target: this, currentTarget: this }) } _wheel(t) { this.setPointersPositions(t); var e = this.getIntersection(this.getPointerPosition()); e && e.isListening() ? e._fireAndBubble(wt, { evt: t }) : this._fire(wt, { evt: t, target: this, currentTarget: this }) } _pointercancel(t) { this.setPointersPositions(t); const e = $(t.pointerId) || this.getIntersection(this.getPointerPosition()); e && e._fireAndBubble(gt, tt(t)), rt(t.pointerId) } _lostpointercapture(t) { rt(t.pointerId) } setPointersPositions(t) { var e = this._getContentPosition(), i = null, r = null; void 0 !== (t = t || window.event).touches ? (this._pointerPositions = [], this._changedPointerPositions = [], Array.prototype.forEach.call(t.touches, (t => { this._pointerPositions.push({ id: t.identifier, x: (t.clientX - e.left) / e.scaleX, y: (t.clientY - e.top) / e.scaleY }) })), Array.prototype.forEach.call(t.changedTouches || t.touches, (t => { this._changedPointerPositions.push({ id: t.identifier, x: (t.clientX - e.left) / e.scaleX, y: (t.clientY - e.top) / e.scaleY }) }))) : (i = (t.clientX - e.left) / e.scaleX, r = (t.clientY - e.top) / e.scaleY, this.pointerPos = { x: i, y: r }, this._pointerPositions = [{ x: i, y: r, id: g._getFirstPointerId(t) }], this._changedPointerPositions = [{ x: i, y: r, id: g._getFirstPointerId(t) }]) } _setPointerPosition(t) { g.warn('Method _setPointerPosition is deprecated. Use "stage.setPointersPositions(event)" instead.'), this.setPointersPositions(t) } _getContentPosition() { if (!this.content || !this.content.getBoundingClientRect) return { top: 0, left: 0, scaleX: 1, scaleY: 1 }; var t = this.content.getBoundingClientRect(); return { top: t.top, left: t.left, scaleX: t.width / this.content.clientWidth || 1, scaleY: t.height / this.content.clientHeight || 1 } } _buildDOM() { if (this.bufferCanvas = new G({ width: this.width(), height: this.height() }), this.bufferHitCanvas = new R({ pixelRatio: 1, width: this.width(), height: this.height() }), i.isBrowser) { var t = this.container(); if (!t) throw "Stage has no container. A container is required."; t.innerHTML = "", this.content = document.createElement("div"), this.content.style.position = "relative", this.content.style.userSelect = "none", this.content.className = "konvajs-content", this.content.setAttribute("role", "presentation"), t.appendChild(this.content), this._resizeDOM() } } cache() { return g.warn("Cache function is not allowed for stage. You may use cache only for layers, groups and shapes."), this } clearCache() { return this } batchDraw() { return this.getChildren().forEach((function (t) { t.batchDraw() })), this } } Gt.prototype.nodeType = "Stage", r(Gt), w.addGetterSetter(Gt, "container"); var Rt = "hasShadow", Et = "shadowRGBA", Dt = "patternImage", Lt = "linearGradient", Ot = "radialGradient"; let It; function Ft() { return It || (It = g.createCanvasElement().getContext("2d"), It) } const Nt = {}; class Bt extends K { constructor(t) { let e; for (super(t); e = g.getRandomColor(), !e || e in Nt;); this.colorKey = e, Nt[e] = this } getContext() { return g.warn("shape.getContext() method is deprecated. Please do not use it."), this.getLayer().getContext() } getCanvas() { return g.warn("shape.getCanvas() method is deprecated. Please do not use it."), this.getLayer().getCanvas() } getSceneFunc() { return this.attrs.sceneFunc || this._sceneFunc } getHitFunc() { return this.attrs.hitFunc || this._hitFunc } hasShadow() { return this._getCache(Rt, this._hasShadow) } _hasShadow() { return this.shadowEnabled() && 0 !== this.shadowOpacity() && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY()) } _getFillPattern() { return this._getCache(Dt, this.__getFillPattern) } __getFillPattern() { if (this.fillPatternImage()) { const t = Ft().createPattern(this.fillPatternImage(), this.fillPatternRepeat() || "repeat"); if (t && t.setTransform) { const e = new a; e.translate(this.fillPatternX(), this.fillPatternY()), e.rotate(i.getAngle(this.fillPatternRotation())), e.scale(this.fillPatternScaleX(), this.fillPatternScaleY()), e.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY()); const r = e.getMatrix(), n = "undefined" == typeof DOMMatrix ? { a: r[0], b: r[1], c: r[2], d: r[3], e: r[4], f: r[5] } : new DOMMatrix(r); t.setTransform(n) } return t } } _getLinearGradient() { return this._getCache(Lt, this.__getLinearGradient) } __getLinearGradient() { var t = this.fillLinearGradientColorStops(); if (t) { for (var e = Ft(), i = this.fillLinearGradientStartPoint(), r = this.fillLinearGradientEndPoint(), a = e.createLinearGradient(i.x, i.y, r.x, r.y), n = 0; n < t.length; n += 2)a.addColorStop(t[n], t[n + 1]); return a } } _getRadialGradient() { return this._getCache(Ot, this.__getRadialGradient) } __getRadialGradient() { var t = this.fillRadialGradientColorStops(); if (t) { for (var e = Ft(), i = this.fillRadialGradientStartPoint(), r = this.fillRadialGradientEndPoint(), a = e.createRadialGradient(i.x, i.y, this.fillRadialGradientStartRadius(), r.x, r.y, this.fillRadialGradientEndRadius()), n = 0; n < t.length; n += 2)a.addColorStop(t[n], t[n + 1]); return a } } getShadowRGBA() { return this._getCache(Et, this._getShadowRGBA) } _getShadowRGBA() { if (this.hasShadow()) { var t = g.colorToRGBA(this.shadowColor()); return t ? "rgba(" + t.r + "," + t.g + "," + t.b + "," + t.a * (this.shadowOpacity() || 1) + ")" : void 0 } } hasFill() { return this._calculate("hasFill", ["fillEnabled", "fill", "fillPatternImage", "fillLinearGradientColorStops", "fillRadialGradientColorStops"], (() => this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops()))) } hasStroke() { return this._calculate("hasStroke", ["strokeEnabled", "strokeWidth", "stroke", "strokeLinearGradientColorStops"], (() => this.strokeEnabled() && this.strokeWidth() && !(!this.stroke() && !this.strokeLinearGradientColorStops()))) } hasHitStroke() { const t = this.hitStrokeWidth(); return "auto" === t ? this.hasStroke() : this.strokeEnabled() && !!t } intersects(t) { var e = this.getStage().bufferHitCanvas; return e.getContext().clear(), this.drawHit(e, null, !0), e.context.getImageData(Math.round(t.x), Math.round(t.y), 1, 1).data[3] > 0 } destroy() { return K.prototype.destroy.call(this), delete Nt[this.colorKey], delete this.colorKey, this } _useBufferCanvas(t) { var e; if (!this.getStage()) return !1; if (!(null === (e = this.attrs.perfectDrawEnabled) || void 0 === e || e)) return !1; const i = t || this.hasFill(), r = this.hasStroke(), a = 1 !== this.getAbsoluteOpacity(); if (i && r && a) return !0; const n = this.hasShadow(), s = this.shadowForStrokeEnabled(); return !!(i && r && n && s) } setStrokeHitEnabled(t) { g.warn("strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead."), t ? this.hitStrokeWidth("auto") : this.hitStrokeWidth(0) } getStrokeHitEnabled() { return 0 !== this.hitStrokeWidth() } getSelfRect() { var t = this.size(); return { x: this._centroid ? -t.width / 2 : 0, y: this._centroid ? -t.height / 2 : 0, width: t.width, height: t.height } } getClientRect(t = {}) { const e = t.skipTransform, i = t.relativeTo, r = this.getSelfRect(), a = !t.skipStroke && this.hasStroke() && this.strokeWidth() || 0, n = r.width + a, s = r.height + a, o = !t.skipShadow && this.hasShadow(), h = o ? this.shadowOffsetX() : 0, l = o ? this.shadowOffsetY() : 0, d = n + Math.abs(h), c = s + Math.abs(l), g = o && this.shadowBlur() || 0, u = { width: d + 2 * g, height: c + 2 * g, x: -(a / 2 + g) + Math.min(h, 0) + r.x, y: -(a / 2 + g) + Math.min(l, 0) + r.y }; return e ? u : this._transformedRect(u, i) } drawScene(t, e) { var i, r, a = this.getLayer(), n = t || a.getCanvas(), s = n.getContext(), o = this._getCanvasCache(), h = this.getSceneFunc(), l = this.hasShadow(), d = n.isCache, c = e === this; if (!this.isVisible() && !c) return this; if (o) { s.save(); var g = this.getAbsoluteTransform(e).getMatrix(); return s.transform(g[0], g[1], g[2], g[3], g[4], g[5]), this._drawCachedSceneCanvas(s), s.restore(), this } if (!h) return this; if (s.save(), this._useBufferCanvas() && !d) { (r = (i = this.getStage().bufferCanvas).getContext()).clear(), r.save(), r._applyLineJoin(this); var u = this.getAbsoluteTransform(e).getMatrix(); r.transform(u[0], u[1], u[2], u[3], u[4], u[5]), h.call(this, r, this), r.restore(); var f = i.pixelRatio; l && s._applyShadow(this), s._applyOpacity(this), s._applyGlobalCompositeOperation(this), s.drawImage(i._canvas, 0, 0, i.width / f, i.height / f) } else { if (s._applyLineJoin(this), !c) { u = this.getAbsoluteTransform(e).getMatrix(); s.transform(u[0], u[1], u[2], u[3], u[4], u[5]), s._applyOpacity(this), s._applyGlobalCompositeOperation(this) } l && s._applyShadow(this), h.call(this, s, this) } return s.restore(), this } drawHit(t, e, i = !1) { if (!this.shouldDrawHit(e, i)) return this; var r = this.getLayer(), a = t || r.hitCanvas, n = a && a.getContext(), s = this.hitFunc() || this.sceneFunc(), o = this._getCanvasCache(), h = o && o.hit; if (this.colorKey || g.warn("Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()"), h) { n.save(); var l = this.getAbsoluteTransform(e).getMatrix(); return n.transform(l[0], l[1], l[2], l[3], l[4], l[5]), this._drawCachedHitCanvas(n), n.restore(), this } if (!s) return this; n.save(), n._applyLineJoin(this); if (!(this === e)) { var d = this.getAbsoluteTransform(e).getMatrix(); n.transform(d[0], d[1], d[2], d[3], d[4], d[5]) } return s.call(this, n, this), n.restore(), this } drawHitFromCache(t = 0) { var e, i, r, a, n, s = this._getCanvasCache(), o = this._getCachedSceneCanvas(), h = s.hit, l = h.getContext(), d = h.getWidth(), c = h.getHeight(); l.clear(), l.drawImage(o._canvas, 0, 0, d, c); try { for (r = (i = (e = l.getImageData(0, 0, d, c)).data).length, a = g._hexToRgb(this.colorKey), n = 0; n < r; n += 4)i[n + 3] > t ? (i[n] = a.r, i[n + 1] = a.g, i[n + 2] = a.b, i[n + 3] = 255) : i[n + 3] = 0; l.putImageData(e, 0, 0) } catch (t) { g.error("Unable to draw hit graph from cached scene canvas. " + t.message) } return this } hasPointerCapture(t) { return et(t, this) } setPointerCapture(t) { it(t, this) } releaseCapture(t) { rt(t) } } Bt.prototype._fillFunc = function (t) { t.fill() }, Bt.prototype._strokeFunc = function (t) { t.stroke() }, Bt.prototype._fillFuncHit = function (t) { t.fill() }, Bt.prototype._strokeFuncHit = function (t) { t.stroke() }, Bt.prototype._centroid = !1, Bt.prototype.nodeType = "Shape", r(Bt), Bt.prototype.eventListeners = {}, Bt.prototype.on.call(Bt.prototype, "shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", (function () { this._clearCache(Rt) })), Bt.prototype.on.call(Bt.prototype, "shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva", (function () { this._clearCache(Et) })), Bt.prototype.on.call(Bt.prototype, "fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva", (function () { this._clearCache(Dt) })), Bt.prototype.on.call(Bt.prototype, "fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva", (function () { this._clearCache(Lt) })), Bt.prototype.on.call(Bt.prototype, "fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva", (function () { this._clearCache(Ot) })), w.addGetterSetter(Bt, "stroke", void 0, y()), w.addGetterSetter(Bt, "strokeWidth", 2, p()), w.addGetterSetter(Bt, "fillAfterStrokeEnabled", !1), w.addGetterSetter(Bt, "hitStrokeWidth", "auto", m()), w.addGetterSetter(Bt, "strokeHitEnabled", !0, x()), w.addGetterSetter(Bt, "perfectDrawEnabled", !0, x()), w.addGetterSetter(Bt, "shadowForStrokeEnabled", !0, x()), w.addGetterSetter(Bt, "lineJoin"), w.addGetterSetter(Bt, "lineCap"), w.addGetterSetter(Bt, "sceneFunc"), w.addGetterSetter(Bt, "hitFunc"), w.addGetterSetter(Bt, "dash"), w.addGetterSetter(Bt, "dashOffset", 0, p()), w.addGetterSetter(Bt, "shadowColor", void 0, _()), w.addGetterSetter(Bt, "shadowBlur", 0, p()), w.addGetterSetter(Bt, "shadowOpacity", 1, p()), w.addComponentsGetterSetter(Bt, "shadowOffset", ["x", "y"]), w.addGetterSetter(Bt, "shadowOffsetX", 0, p()), w.addGetterSetter(Bt, "shadowOffsetY", 0, p()), w.addGetterSetter(Bt, "fillPatternImage"), w.addGetterSetter(Bt, "fill", void 0, y()), w.addGetterSetter(Bt, "fillPatternX", 0, p()), w.addGetterSetter(Bt, "fillPatternY", 0, p()), w.addGetterSetter(Bt, "fillLinearGradientColorStops"), w.addGetterSetter(Bt, "strokeLinearGradientColorStops"), w.addGetterSetter(Bt, "fillRadialGradientStartRadius", 0), w.addGetterSetter(Bt, "fillRadialGradientEndRadius", 0), w.addGetterSetter(Bt, "fillRadialGradientColorStops"), w.addGetterSetter(Bt, "fillPatternRepeat", "repeat"), w.addGetterSetter(Bt, "fillEnabled", !0), w.addGetterSetter(Bt, "strokeEnabled", !0), w.addGetterSetter(Bt, "shadowEnabled", !0), w.addGetterSetter(Bt, "dashEnabled", !0), w.addGetterSetter(Bt, "strokeScaleEnabled", !0), w.addGetterSetter(Bt, "fillPriority", "color"), w.addComponentsGetterSetter(Bt, "fillPatternOffset", ["x", "y"]), w.addGetterSetter(Bt, "fillPatternOffsetX", 0, p()), w.addGetterSetter(Bt, "fillPatternOffsetY", 0, p()), w.addComponentsGetterSetter(Bt, "fillPatternScale", ["x", "y"]), w.addGetterSetter(Bt, "fillPatternScaleX", 1, p()), w.addGetterSetter(Bt, "fillPatternScaleY", 1, p()), w.addComponentsGetterSetter(Bt, "fillLinearGradientStartPoint", ["x", "y"]), w.addComponentsGetterSetter(Bt, "strokeLinearGradientStartPoint", ["x", "y"]), w.addGetterSetter(Bt, "fillLinearGradientStartPointX", 0), w.addGetterSetter(Bt, "strokeLinearGradientStartPointX", 0), w.addGetterSetter(Bt, "fillLinearGradientStartPointY", 0), w.addGetterSetter(Bt, "strokeLinearGradientStartPointY", 0), w.addComponentsGetterSetter(Bt, "fillLinearGradientEndPoint", ["x", "y"]), w.addComponentsGetterSetter(Bt, "strokeLinearGradientEndPoint", ["x", "y"]), w.addGetterSetter(Bt, "fillLinearGradientEndPointX", 0), w.addGetterSetter(Bt, "strokeLinearGradientEndPointX", 0), w.addGetterSetter(Bt, "fillLinearGradientEndPointY", 0), w.addGetterSetter(Bt, "strokeLinearGradientEndPointY", 0), w.addComponentsGetterSetter(Bt, "fillRadialGradientStartPoint", ["x", "y"]), w.addGetterSetter(Bt, "fillRadialGradientStartPointX", 0), w.addGetterSetter(Bt, "fillRadialGradientStartPointY", 0), w.addComponentsGetterSetter(Bt, "fillRadialGradientEndPoint", ["x", "y"]), w.addGetterSetter(Bt, "fillRadialGradientEndPointX", 0), w.addGetterSetter(Bt, "fillRadialGradientEndPointY", 0), w.addGetterSetter(Bt, "fillPatternRotation", 0), w.backCompat(Bt, { dashArray: "dash", getDashArray: "getDash", setDashArray: "getDash", drawFunc: "sceneFunc", getDrawFunc: "getSceneFunc", setDrawFunc: "setSceneFunc", drawHitFunc: "hitFunc", getDrawHitFunc: "getHitFunc", setDrawHitFunc: "setHitFunc" }); var Ht = [{ x: 0, y: 0 }, { x: -1, y: -1 }, { x: 1, y: -1 }, { x: 1, y: 1 }, { x: -1, y: 1 }], Wt = Ht.length; class zt extends Q { constructor(t) { super(t), this.canvas = new G, this.hitCanvas = new R({ pixelRatio: 1 }), this._waitingForDraw = !1, this.on("visibleChange.konva", this._checkVisibility), this._checkVisibility(), this.on("imageSmoothingEnabledChange.konva", this._setSmoothEnabled), this._setSmoothEnabled() } createPNGStream() { return this.canvas._canvas.createPNGStream() } getCanvas() { return this.canvas } getNativeCanvasElement() { return this.canvas._canvas } getHitCanvas() { return this.hitCanvas } getContext() { return this.getCanvas().getContext() } clear(t) { return this.getContext().clear(t), this.getHitCanvas().getContext().clear(t), this } setZIndex(t) { super.setZIndex(t); var e = this.getStage(); return e && e.content && (e.content.removeChild(this.getNativeCanvasElement()), t < e.children.length - 1 ? e.content.insertBefore(this.getNativeCanvasElement(), e.children[t + 1].getCanvas()._canvas) : e.content.appendChild(this.getNativeCanvasElement())), this } moveToTop() { K.prototype.moveToTop.call(this); var t = this.getStage(); return t && t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.appendChild(this.getNativeCanvasElement())), !0 } moveUp() { if (!K.prototype.moveUp.call(this)) return !1; var t = this.getStage(); return !(!t || !t.content) && (t.content.removeChild(this.getNativeCanvasElement()), this.index < t.children.length - 1 ? t.content.insertBefore(this.getNativeCanvasElement(), t.children[this.index + 1].getCanvas()._canvas) : t.content.appendChild(this.getNativeCanvasElement()), !0) } moveDown() { if (K.prototype.moveDown.call(this)) { var t = this.getStage(); if (t) { var e = t.children; t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), e[this.index + 1].getCanvas()._canvas)) } return !0 } return !1 } moveToBottom() { if (K.prototype.moveToBottom.call(this)) { var t = this.getStage(); if (t) { var e = t.children; t.content && (t.content.removeChild(this.getNativeCanvasElement()), t.content.insertBefore(this.getNativeCanvasElement(), e[1].getCanvas()._canvas)) } return !0 } return !1 } getLayer() { return this } remove() { var t = this.getNativeCanvasElement(); return K.prototype.remove.call(this), t && t.parentNode && g._isInDocument(t) && t.parentNode.removeChild(t), this } getStage() { return this.parent } setSize({ width: t, height: e }) { return this.canvas.setSize(t, e), this.hitCanvas.setSize(t, e), this._setSmoothEnabled(), this } _validateAdd(t) { var e = t.getType(); "Group" !== e && "Shape" !== e && g.throw("You may only add groups and shapes to a layer.") } _toKonvaCanvas(t) { return (t = t || {}).width = t.width || this.getWidth(), t.height = t.height || this.getHeight(), t.x = void 0 !== t.x ? t.x : this.x(), t.y = void 0 !== t.y ? t.y : this.y(), K.prototype._toKonvaCanvas.call(this, t) } _checkVisibility() { const t = this.visible(); this.canvas._canvas.style.display = t ? "block" : "none" } _setSmoothEnabled() { this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled() } getWidth() { if (this.parent) return this.parent.width() } setWidth() { g.warn('Can not change width of layer. Use "stage.width(value)" function instead.') } getHeight() { if (this.parent) return this.parent.height() } setHeight() { g.warn('Can not change height of layer. Use "stage.height(value)" function instead.') } batchDraw() { return this._waitingForDraw || (this._waitingForDraw = !0, g.requestAnimFrame((() => { this.draw(), this._waitingForDraw = !1 }))), this } getIntersection(t) { if (!this.isListening() || !this.isVisible()) return null; for (var e = 1, i = !1; ;) { for (let r = 0; r < Wt; r++) { const a = Ht[r], n = this._getIntersection({ x: t.x + a.x * e, y: t.y + a.y * e }), s = n.shape; if (s) return s; if (i = !!n.antialiased, !n.antialiased) break } if (!i) return null; e += 1 } } _getIntersection(t) { const e = this.hitCanvas.pixelRatio, i = this.hitCanvas.context.getImageData(Math.round(t.x * e), Math.round(t.y * e), 1, 1).data, r = i[3]; if (255 === r) { const t = g._rgbToHex(i[0], i[1], i[2]), e = Nt["#" + t]; return e ? { shape: e } : { antialiased: !0 } } return r > 0 ? { antialiased: !0 } : {} } drawScene(t, e) { var i = this.getLayer(), r = t || i && i.getCanvas(); return this._fire("beforeDraw", { node: this }), this.clearBeforeDraw() && r.getContext().clear(), Q.prototype.drawScene.call(this, r, e), this._fire("draw", { node: this }), this } drawHit(t, e) { var i = this.getLayer(), r = t || i && i.hitCanvas; return i && i.clearBeforeDraw() && i.getHitCanvas().getContext().clear(), Q.prototype.drawHit.call(this, r, e), this } enableHitGraph() { return this.hitGraphEnabled(!0), this } disableHitGraph() { return this.hitGraphEnabled(!1), this } setHitGraphEnabled(t) { g.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening(t) } getHitGraphEnabled(t) { return g.warn("hitGraphEnabled method is deprecated. Please use layer.listening() instead."), this.listening() } toggleHitCanvas() { if (this.parent && this.parent.content) { var t = this.parent; !!this.hitCanvas._canvas.parentNode ? t.content.removeChild(this.hitCanvas._canvas) : t.content.appendChild(this.hitCanvas._canvas) } } destroy() { return g.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas), super.destroy() } } zt.prototype.nodeType = "Layer", r(zt), w.addGetterSetter(zt, "imageSmoothingEnabled", !0), w.addGetterSetter(zt, "clearBeforeDraw", !0), w.addGetterSetter(zt, "hitGraphEnabled", !0, x()); class Yt extends zt { constructor(t) { super(t), this.listening(!1), g.warn('Konva.Fast layer is deprecated. Please use "new Konva.Layer({ listening: false })" instead.') } } Yt.prototype.nodeType = "FastLayer", r(Yt); class Xt extends Q { _validateAdd(t) { var e = t.getType(); "Group" !== e && "Shape" !== e && g.throw("You may only add groups and shapes to groups.") } } Xt.prototype.nodeType = "Group", r(Xt); var jt = e.performance && e.performance.now ? function () { return e.performance.now() } : function () { return (new Date).getTime() }; class qt { constructor(t, e) { this.id = qt.animIdCounter++, this.frame = { time: 0, timeDiff: 0, lastTime: jt(), frameRate: 0 }, this.func = t, this.setLayers(e) } setLayers(t) { var e = []; return e = t ? t.length > 0 ? t : [t] : [], this.layers = e, this } getLayers() { return this.layers } addLayer(t) { var e, i = this.layers, r = i.length; for (e = 0; e < r; e++)if (i[e]._id === t._id) return !1; return this.layers.push(t), !0 } isRunning() { var t, e = qt.animations, i = e.length; for (t = 0; t < i; t++)if (e[t].id === this.id) return !0; return !1 } start() { return this.stop(), this.frame.timeDiff = 0, this.frame.lastTime = jt(), qt._addAnimation(this), this } stop() { return qt._removeAnimation(this), this } _updateFrameObject(t) { this.frame.timeDiff = t - this.frame.lastTime, this.frame.lastTime = t, this.frame.time += this.frame.timeDiff, this.frame.frameRate = 1e3 / this.frame.timeDiff } static _addAnimation(t) { this.animations.push(t), this._handleAnimation() } static _removeAnimation(t) { var e, i = t.id, r = this.animations, a = r.length; for (e = 0; e < a; e++)if (r[e].id === i) { this.animations.splice(e, 1); break } } static _runFrames() { var t, e, i, r, a, n, s, o, h = {}, l = this.animations; for (r = 0; r < l.length; r++)if (e = (t = l[r]).layers, i = t.func, t._updateFrameObject(jt()), n = e.length, !i || !1 !== i.call(t, t.frame)) for (a = 0; a < n; a++)void 0 !== (s = e[a])._id && (h[s._id] = s); for (o in h) h.hasOwnProperty(o) && h[o].batchDraw() } static _animationLoop() { var t = qt; t.animations.length ? (t._runFrames(), g.requestAnimFrame(t._animationLoop)) : t.animRunning = !1 } static _handleAnimation() { this.animRunning || (this.animRunning = !0, g.requestAnimFrame(this._animationLoop)) } } qt.animations = [], qt.animIdCounter = 0, qt.animRunning = !1; var Ut = { node: 1, duration: 1, easing: 1, onFinish: 1, yoyo: 1 }, Kt = 0, Vt = ["fill", "stroke", "shadowColor"]; class Qt { constructor(t, e, i, r, a, n, s) { this.prop = t, this.propFunc = e, this.begin = r, this._pos = r, this.duration = n, this._change = 0, this.prevPos = 0, this.yoyo = s, this._time = 0, this._position = 0, this._startTime = 0, this._finish = 0, this.func = i, this._change = a - this.begin, this.pause() } fire(t) { var e = this[t]; e && e() } setTime(t) { t > this.duration ? this.yoyo ? (this._time = this.duration, this.reverse()) : this.finish() : t < 0 ? this.yoyo ? (this._time = 0, this.play()) : this.reset() : (this._time = t, this.update()) } getTime() { return this._time } setPosition(t) { this.prevPos = this._pos, this.propFunc(t), this._pos = t } getPosition(t) { return void 0 === t && (t = this._time), this.func(t, this.begin, this._change, this.duration) } play() { this.state = 2, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onPlay") } reverse() { this.state = 3, this._time = this.duration - this._time, this._startTime = this.getTimer() - this._time, this.onEnterFrame(), this.fire("onReverse") } seek(t) { this.pause(), this._time = t, this.update(), this.fire("onSeek") } reset() { this.pause(), this._time = 0, this.update(), this.fire("onReset") } finish() { this.pause(), this._time = this.duration, this.update(), this.fire("onFinish") } update() { this.setPosition(this.getPosition(this._time)), this.fire("onUpdate") } onEnterFrame() { var t = this.getTimer() - this._startTime; 2 === this.state ? this.setTime(t) : 3 === this.state && this.setTime(this.duration - t) } pause() { this.state = 1, this.fire("onPause") } getTimer() { return (new Date).getTime() } } class Jt { constructor(t) { var e, r, a = this, n = t.node, s = n._id, o = t.easing || Zt.Linear, h = !!t.yoyo; e = void 0 === t.duration ? .3 : 0 === t.duration ? .001 : t.duration, this.node = n, this._id = Kt++; var l = n.getLayer() || (n instanceof i.Stage ? n.getLayers() : null); for (r in l || g.error("Tween constructor have `node` that is not in a layer. Please add node into layer first."), this.anim = new qt((function () { a.tween.onEnterFrame() }), l), this.tween = new Qt(r, (function (t) { a._tweenFunc(t) }), o, 0, 1, 1e3 * e, h), this._addListeners(), Jt.attrs[s] || (Jt.attrs[s] = {}), Jt.attrs[s][this._id] || (Jt.attrs[s][this._id] = {}), Jt.tweens[s] || (Jt.tweens[s] = {}), t) void 0 === Ut[r] && this._addAttr(r, t[r]); this.reset(), this.onFinish = t.onFinish, this.onReset = t.onReset, this.onUpdate = t.onUpdate } _addAttr(t, e) { var i, r, a, n, s, o, h, l, d = this.node, c = d._id; if ((a = Jt.tweens[c][t]) && delete Jt.attrs[c][a][t], i = d.getAttr(t), g._isArray(e)) if (r = [], s = Math.max(e.length, i.length), "points" === t && e.length !== i.length && (e.length > i.length ? (h = i, i = g._prepareArrayForTween(i, e, d.closed())) : (o = e, e = g._prepareArrayForTween(e, i, d.closed()))), 0 === t.indexOf("fill")) for (n = 0; n < s; n++)if (n % 2 == 0) r.push(e[n] - i[n]); else { var u = g.colorToRGBA(i[n]); l = g.colorToRGBA(e[n]), i[n] = u, r.push({ r: l.r - u.r, g: l.g - u.g, b: l.b - u.b, a: l.a - u.a }) } else for (n = 0; n < s; n++)r.push(e[n] - i[n]); else -1 !== Vt.indexOf(t) ? (i = g.colorToRGBA(i), r = { r: (l = g.colorToRGBA(e)).r - i.r, g: l.g - i.g, b: l.b - i.b, a: l.a - i.a }) : r = e - i; Jt.attrs[c][this._id][t] = { start: i, diff: r, end: e, trueEnd: o, trueStart: h }, Jt.tweens[c][t] = this._id } _tweenFunc(t) { var e, i, r, a, n, s, o, h, l = this.node, d = Jt.attrs[l._id][this._id]; for (e in d) { if (r = (i = d[e]).start, a = i.diff, h = i.end, g._isArray(r)) if (n = [], o = Math.max(r.length, h.length), 0 === e.indexOf("fill")) for (s = 0; s < o; s++)s % 2 == 0 ? n.push((r[s] || 0) + a[s] * t) : n.push("rgba(" + Math.round(r[s].r + a[s].r * t) + "," + Math.round(r[s].g + a[s].g * t) + "," + Math.round(r[s].b + a[s].b * t) + "," + (r[s].a + a[s].a * t) + ")"); else for (s = 0; s < o; s++)n.push((r[s] || 0) + a[s] * t); else n = -1 !== Vt.indexOf(e) ? "rgba(" + Math.round(r.r + a.r * t) + "," + Math.round(r.g + a.g * t) + "," + Math.round(r.b + a.b * t) + "," + (r.a + a.a * t) + ")" : r + a * t; l.setAttr(e, n) } } _addListeners() { this.tween.onPlay = () => { this.anim.start() }, this.tween.onReverse = () => { this.anim.start() }, this.tween.onPause = () => { this.anim.stop() }, this.tween.onFinish = () => { var t = this.node, e = Jt.attrs[t._id][this._id]; e.points && e.points.trueEnd && t.setAttr("points", e.points.trueEnd), this.onFinish && this.onFinish.call(this) }, this.tween.onReset = () => { var t = this.node, e = Jt.attrs[t._id][this._id]; e.points && e.points.trueStart && t.points(e.points.trueStart), this.onReset && this.onReset() }, this.tween.onUpdate = () => { this.onUpdate && this.onUpdate.call(this) } } play() { return this.tween.play(), this } reverse() { return this.tween.reverse(), this } reset() { return this.tween.reset(), this } seek(t) { return this.tween.seek(1e3 * t), this } pause() { return this.tween.pause(), this } finish() { return this.tween.finish(), this } destroy() { var t, e = this.node._id, i = this._id, r = Jt.tweens[e]; for (t in this.pause(), r) delete Jt.tweens[e][t]; delete Jt.attrs[e][i] } } Jt.attrs = {}, Jt.tweens = {}, K.prototype.to = function (t) { var e = t.onFinish; t.node = this, t.onFinish = function () { this.destroy(), e && e() }, new Jt(t).play() }; const Zt = { BackEaseIn(t, e, i, r) { var a = 1.70158; return i * (t /= r) * t * ((a + 1) * t - a) + e }, BackEaseOut(t, e, i, r) { var a = 1.70158; return i * ((t = t / r - 1) * t * ((a + 1) * t + a) + 1) + e }, BackEaseInOut(t, e, i, r) { var a = 1.70158; return (t /= r / 2) < 1 ? i / 2 * (t * t * ((1 + (a *= 1.525)) * t - a)) + e : i / 2 * ((t -= 2) * t * ((1 + (a *= 1.525)) * t + a) + 2) + e }, ElasticEaseIn(t, e, i, r, a, n) { var s = 0; return 0 === t ? e : 1 == (t /= r) ? e + i : (n || (n = .3 * r), !a || a < Math.abs(i) ? (a = i, s = n / 4) : s = n / (2 * Math.PI) * Math.asin(i / a), -a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * r - s) * (2 * Math.PI) / n) + e) }, ElasticEaseOut(t, e, i, r, a, n) { var s = 0; return 0 === t ? e : 1 == (t /= r) ? e + i : (n || (n = .3 * r), !a || a < Math.abs(i) ? (a = i, s = n / 4) : s = n / (2 * Math.PI) * Math.asin(i / a), a * Math.pow(2, -10 * t) * Math.sin((t * r - s) * (2 * Math.PI) / n) + i + e) }, ElasticEaseInOut(t, e, i, r, a, n) { var s = 0; return 0 === t ? e : 2 == (t /= r / 2) ? e + i : (n || (n = r * (.3 * 1.5)), !a || a < Math.abs(i) ? (a = i, s = n / 4) : s = n / (2 * Math.PI) * Math.asin(i / a), t < 1 ? a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * r - s) * (2 * Math.PI) / n) * -.5 + e : a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * r - s) * (2 * Math.PI) / n) * .5 + i + e) }, BounceEaseOut: (t, e, i, r) => (t /= r) < 1 / 2.75 ? i * (7.5625 * t * t) + e : t < 2 / 2.75 ? i * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : t < 2.5 / 2.75 ? i * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : i * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e, BounceEaseIn: (t, e, i, r) => i - Zt.BounceEaseOut(r - t, 0, i, r) + e, BounceEaseInOut: (t, e, i, r) => t < r / 2 ? .5 * Zt.BounceEaseIn(2 * t, 0, i, r) + e : .5 * Zt.BounceEaseOut(2 * t - r, 0, i, r) + .5 * i + e, EaseIn: (t, e, i, r) => i * (t /= r) * t + e, EaseOut: (t, e, i, r) => -i * (t /= r) * (t - 2) + e, EaseInOut: (t, e, i, r) => (t /= r / 2) < 1 ? i / 2 * t * t + e : -i / 2 * (--t * (t - 2) - 1) + e, StrongEaseIn: (t, e, i, r) => i * (t /= r) * t * t * t * t + e, StrongEaseOut: (t, e, i, r) => i * ((t = t / r - 1) * t * t * t * t + 1) + e, StrongEaseInOut: (t, e, i, r) => (t /= r / 2) < 1 ? i / 2 * t * t * t * t * t + e : i / 2 * ((t -= 2) * t * t * t * t + 2) + e, Linear: (t, e, i, r) => i * t / r + e }, $t = g._assign(i, { Util: g, Transform: a, Node: K, Container: Q, Stage: Gt, stages: Mt, Layer: zt, FastLayer: Yt, Group: Xt, DD: E, Shape: Bt, shapes: Nt, Animation: qt, Tween: Jt, Easings: Zt, Context: P, Canvas: M }); class te extends Bt { _sceneFunc(t) { var e = i.getAngle(this.angle()), r = this.clockwise(); t.beginPath(), t.arc(0, 0, this.outerRadius(), 0, e, r), t.arc(0, 0, this.innerRadius(), e, 0, !r), t.closePath(), t.fillStrokeShape(this) } getWidth() { return 2 * this.outerRadius() } getHeight() { return 2 * this.outerRadius() } setWidth(t) { this.outerRadius(t / 2) } setHeight(t) { this.outerRadius(t / 2) } getSelfRect() { const t = this.innerRadius(), e = this.outerRadius(), r = this.clockwise(), a = i.getAngle(r ? 360 - this.angle() : this.angle()), n = Math.cos(Math.min(a, Math.PI)), s = Math.sin(Math.min(Math.max(Math.PI, a), 3 * Math.PI / 2)), o = Math.sin(Math.min(a, Math.PI / 2)), h = n * (n > 0 ? t : e), l = s * (s > 0 ? t : e), d = o * (o > 0 ? e : t); return { x: h, y: r ? -1 * d : l, width: 1 * e - h, height: d - l } } } function ee(t, e, i, r, a, n, s) { var o = Math.sqrt(Math.pow(i - t, 2) + Math.pow(r - e, 2)), h = Math.sqrt(Math.pow(a - i, 2) + Math.pow(n - r, 2)), l = s * o / (o + h), d = s * h / (o + h); return [i - l * (a - t), r - l * (n - e), i + d * (a - t), r + d * (n - e)] } function ie(t, e) { var i, r, a = t.length, n = []; for (i = 2; i < a - 2; i += 2)r = ee(t[i - 2], t[i - 1], t[i], t[i + 1], t[i + 2], t[i + 3], e), isNaN(r[0]) || (n.push(r[0]), n.push(r[1]), n.push(t[i]), n.push(t[i + 1]), n.push(r[2]), n.push(r[3])); return n } te.prototype._centroid = !0, te.prototype.className = "Arc", te.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], r(te), w.addGetterSetter(te, "innerRadius", 0, p()), w.addGetterSetter(te, "outerRadius", 0, p()), w.addGetterSetter(te, "angle", 0, p()), w.addGetterSetter(te, "clockwise", !1, x()); class re extends Bt { constructor(t) { super(t), this.on("pointsChange.konva tensionChange.konva closedChange.konva bezierChange.konva", (function () { this._clearCache("tensionPoints") })) } _sceneFunc(t) { var e, i, r, a = this.points(), n = a.length, s = this.tension(), o = this.closed(), h = this.bezier(); if (n) { if (t.beginPath(), t.moveTo(a[0], a[1]), 0 !== s && n > 4) { for (i = (e = this.getTensionPoints()).length, r = o ? 0 : 4, o || t.quadraticCurveTo(e[0], e[1], e[2], e[3]); r < i - 2;)t.bezierCurveTo(e[r++], e[r++], e[r++], e[r++], e[r++], e[r++]); o || t.quadraticCurveTo(e[i - 2], e[i - 1], a[n - 2], a[n - 1]) } else if (h) for (r = 2; r < n;)t.bezierCurveTo(a[r++], a[r++], a[r++], a[r++], a[r++], a[r++]); else for (r = 2; r < n; r += 2)t.lineTo(a[r], a[r + 1]); o ? (t.closePath(), t.fillStrokeShape(this)) : t.strokeShape(this) } } getTensionPoints() { return this._getCache("tensionPoints", this._getTensionPoints) } _getTensionPoints() { return this.closed() ? this._getTensionPointsClosed() : ie(this.points(), this.tension()) } _getTensionPointsClosed() { var t = this.points(), e = t.length, i = this.tension(), r = ee(t[e - 2], t[e - 1], t[0], t[1], t[2], t[3], i), a = ee(t[e - 4], t[e - 3], t[e - 2], t[e - 1], t[0], t[1], i), n = ie(t, i); return [r[2], r[3]].concat(n).concat([a[0], a[1], t[e - 2], t[e - 1], a[2], a[3], r[0], r[1], t[0], t[1]]) } getWidth() { return this.getSelfRect().width } getHeight() { return this.getSelfRect().height } getSelfRect() { var t = this.points(); if (t.length < 4) return { x: t[0] || 0, y: t[1] || 0, width: 0, height: 0 }; for (var e, i, r = (t = 0 !== this.tension() ? [t[0], t[1], ...this._getTensionPoints(), t[t.length - 2], t[t.length - 1]] : this.points())[0], a = t[0], n = t[1], s = t[1], o = 0; o < t.length / 2; o++)e = t[2 * o], i = t[2 * o + 1], r = Math.min(r, e), a = Math.max(a, e), n = Math.min(n, i), s = Math.max(s, i); return { x: r, y: n, width: a - r, height: s - n } } } re.prototype.className = "Line", re.prototype._attrsAffectingSize = ["points", "bezier", "tension"], r(re), w.addGetterSetter(re, "closed", !1), w.addGetterSetter(re, "bezier", !1), w.addGetterSetter(re, "tension", 0, p()), w.addGetterSetter(re, "points", [], function () { if (i.isUnminified) return function (t, e) { const i = Int8Array ? Object.getPrototypeOf(Int8Array) : null; return i && t instanceof i || (g._isArray(t) ? t.forEach((function (t) { g._isNumber(t) || g.warn('"' + e + '" attribute has non numeric element ' + t + ". Make sure that all elements are numbers.") })) : g.warn(u(t) + ' is a not valid value for "' + e + '" attribute. The value should be a array of numbers.')), t } }()); const ae = [[], [], [-.5773502691896257, .5773502691896257], [0, -.7745966692414834, .7745966692414834], [-.33998104358485626, .33998104358485626, -.8611363115940526, .8611363115940526], [0, -.5384693101056831, .5384693101056831, -.906179845938664, .906179845938664], [.6612093864662645, -.6612093864662645, -.2386191860831969, .2386191860831969, -.932469514203152, .932469514203152], [0, .4058451513773972, -.4058451513773972, -.7415311855993945, .7415311855993945, -.9491079123427585, .9491079123427585], [-.1834346424956498, .1834346424956498, -.525532409916329, .525532409916329, -.7966664774136267, .7966664774136267, -.9602898564975363, .9602898564975363], [0, -.8360311073266358, .8360311073266358, -.9681602395076261, .9681602395076261, -.3242534234038089, .3242534234038089, -.6133714327005904, .6133714327005904], [-.14887433898163122, .14887433898163122, -.4333953941292472, .4333953941292472, -.6794095682990244, .6794095682990244, -.8650633666889845, .8650633666889845, -.9739065285171717, .9739065285171717], [0, -.26954315595234496, .26954315595234496, -.5190961292068118, .5190961292068118, -.7301520055740494, .7301520055740494, -.8870625997680953, .8870625997680953, -.978228658146057, .978228658146057], [-.1252334085114689, .1252334085114689, -.3678314989981802, .3678314989981802, -.5873179542866175, .5873179542866175, -.7699026741943047, .7699026741943047, -.9041172563704749, .9041172563704749, -.9815606342467192, .9815606342467192], [0, -.2304583159551348, .2304583159551348, -.44849275103644687, .44849275103644687, -.6423493394403402, .6423493394403402, -.8015780907333099, .8015780907333099, -.9175983992229779, .9175983992229779, -.9841830547185881, .9841830547185881], [-.10805494870734367, .10805494870734367, -.31911236892788974, .31911236892788974, -.5152486363581541, .5152486363581541, -.6872929048116855, .6872929048116855, -.827201315069765, .827201315069765, -.9284348836635735, .9284348836635735, -.9862838086968123, .9862838086968123], [0, -.20119409399743451, .20119409399743451, -.3941513470775634, .3941513470775634, -.5709721726085388, .5709721726085388, -.7244177313601701, .7244177313601701, -.8482065834104272, .8482065834104272, -.937273392400706, .937273392400706, -.9879925180204854, .9879925180204854], [-.09501250983763744, .09501250983763744, -.2816035507792589, .2816035507792589, -.45801677765722737, .45801677765722737, -.6178762444026438, .6178762444026438, -.755404408355003, .755404408355003, -.8656312023878318, .8656312023878318, -.9445750230732326, .9445750230732326, -.9894009349916499, .9894009349916499], [0, -.17848418149584785, .17848418149584785, -.3512317634538763, .3512317634538763, -.5126905370864769, .5126905370864769, -.6576711592166907, .6576711592166907, -.7815140038968014, .7815140038968014, -.8802391537269859, .8802391537269859, -.9506755217687678, .9506755217687678, -.9905754753144174, .9905754753144174], [-.0847750130417353, .0847750130417353, -.2518862256915055, .2518862256915055, -.41175116146284263, .41175116146284263, -.5597708310739475, .5597708310739475, -.6916870430603532, .6916870430603532, -.8037049589725231, .8037049589725231, -.8926024664975557, .8926024664975557, -.9558239495713977, .9558239495713977, -.9915651684209309, .9915651684209309], [0, -.16035864564022537, .16035864564022537, -.31656409996362983, .31656409996362983, -.46457074137596094, .46457074137596094, -.600545304661681, .600545304661681, -.7209661773352294, .7209661773352294, -.8227146565371428, .8227146565371428, -.9031559036148179, .9031559036148179, -.96020815213483, .96020815213483, -.9924068438435844, .9924068438435844], [-.07652652113349734, .07652652113349734, -.22778585114164507, .22778585114164507, -.37370608871541955, .37370608871541955, -.5108670019508271, .5108670019508271, -.636053680726515, .636053680726515, -.7463319064601508, .7463319064601508, -.8391169718222188, .8391169718222188, -.912234428251326, .912234428251326, -.9639719272779138, .9639719272779138, -.9931285991850949, .9931285991850949], [0, -.1455618541608951, .1455618541608951, -.2880213168024011, .2880213168024011, -.4243421202074388, .4243421202074388, -.5516188358872198, .5516188358872198, -.6671388041974123, .6671388041974123, -.7684399634756779, .7684399634756779, -.8533633645833173, .8533633645833173, -.9200993341504008, .9200993341504008, -.9672268385663063, .9672268385663063, -.9937521706203895, .9937521706203895], [-.06973927331972223, .06973927331972223, -.20786042668822127, .20786042668822127, -.34193582089208424, .34193582089208424, -.469355837986757, .469355837986757, -.5876404035069116, .5876404035069116, -.6944872631866827, .6944872631866827, -.7878168059792081, .7878168059792081, -.8658125777203002, .8658125777203002, -.926956772187174, .926956772187174, -.9700604978354287, .9700604978354287, -.9942945854823992, .9942945854823992], [0, -.1332568242984661, .1332568242984661, -.26413568097034495, .26413568097034495, -.3903010380302908, .3903010380302908, -.5095014778460075, .5095014778460075, -.6196098757636461, .6196098757636461, -.7186613631319502, .7186613631319502, -.8048884016188399, .8048884016188399, -.8767523582704416, .8767523582704416, -.9329710868260161, .9329710868260161, -.9725424712181152, .9725424712181152, -.9947693349975522, .9947693349975522], [-.06405689286260563, .06405689286260563, -.1911188674736163, .1911188674736163, -.3150426796961634, .3150426796961634, -.4337935076260451, .4337935076260451, -.5454214713888396, .5454214713888396, -.6480936519369755, .6480936519369755, -.7401241915785544, .7401241915785544, -.820001985973903, .820001985973903, -.8864155270044011, .8864155270044011, -.9382745520027328, .9382745520027328, -.9747285559713095, .9747285559713095, -.9951872199970213, .9951872199970213]], ne = [[], [], [1, 1], [.8888888888888888, .5555555555555556, .5555555555555556], [.6521451548625461, .6521451548625461, .34785484513745385, .34785484513745385], [.5688888888888889, .47862867049936647, .47862867049936647, .23692688505618908, .23692688505618908], [.3607615730481386, .3607615730481386, .46791393457269104, .46791393457269104, .17132449237917036, .17132449237917036], [.4179591836734694, .3818300505051189, .3818300505051189, .27970539148927664, .27970539148927664, .1294849661688697, .1294849661688697], [.362683783378362, .362683783378362, .31370664587788727, .31370664587788727, .22238103445337448, .22238103445337448, .10122853629037626, .10122853629037626], [.3302393550012598, .1806481606948574, .1806481606948574, .08127438836157441, .08127438836157441, .31234707704000286, .31234707704000286, .26061069640293544, .26061069640293544], [.29552422471475287, .29552422471475287, .26926671930999635, .26926671930999635, .21908636251598204, .21908636251598204, .1494513491505806, .1494513491505806, .06667134430868814, .06667134430868814], [.2729250867779006, .26280454451024665, .26280454451024665, .23319376459199048, .23319376459199048, .18629021092773426, .18629021092773426, .1255803694649046, .1255803694649046, .05566856711617366, .05566856711617366], [.24914704581340277, .24914704581340277, .2334925365383548, .2334925365383548, .20316742672306592, .20316742672306592, .16007832854334622, .16007832854334622, .10693932599531843, .10693932599531843, .04717533638651183, .04717533638651183], [.2325515532308739, .22628318026289723, .22628318026289723, .2078160475368885, .2078160475368885, .17814598076194574, .17814598076194574, .13887351021978725, .13887351021978725, .09212149983772845, .09212149983772845, .04048400476531588, .04048400476531588], [.2152638534631578, .2152638534631578, .2051984637212956, .2051984637212956, .18553839747793782, .18553839747793782, .15720316715819355, .15720316715819355, .12151857068790319, .12151857068790319, .08015808715976021, .08015808715976021, .03511946033175186, .03511946033175186], [.2025782419255613, .19843148532711158, .19843148532711158, .1861610000155622, .1861610000155622, .16626920581699392, .16626920581699392, .13957067792615432, .13957067792615432, .10715922046717194, .10715922046717194, .07036604748810812, .07036604748810812, .03075324199611727, .03075324199611727], [.1894506104550685, .1894506104550685, .18260341504492358, .18260341504492358, .16915651939500254, .16915651939500254, .14959598881657674, .14959598881657674, .12462897125553388, .12462897125553388, .09515851168249279, .09515851168249279, .062253523938647894, .062253523938647894, .027152459411754096, .027152459411754096], [.17944647035620653, .17656270536699264, .17656270536699264, .16800410215645004, .16800410215645004, .15404576107681028, .15404576107681028, .13513636846852548, .13513636846852548, .11188384719340397, .11188384719340397, .08503614831717918, .08503614831717918, .0554595293739872, .0554595293739872, .02414830286854793, .02414830286854793], [.1691423829631436, .1691423829631436, .16427648374583273, .16427648374583273, .15468467512626524, .15468467512626524, .14064291467065065, .14064291467065065, .12255520671147846, .12255520671147846, .10094204410628717, .10094204410628717, .07642573025488905, .07642573025488905, .0497145488949698, .0497145488949698, .02161601352648331, .02161601352648331], [.1610544498487837, .15896884339395434, .15896884339395434, .15276604206585967, .15276604206585967, .1426067021736066, .1426067021736066, .12875396253933621, .12875396253933621, .11156664554733399, .11156664554733399, .09149002162245, .09149002162245, .06904454273764123, .06904454273764123, .0448142267656996, .0448142267656996, .019461788229726478, .019461788229726478], [.15275338713072584, .15275338713072584, .14917298647260374, .14917298647260374, .14209610931838204, .14209610931838204, .13168863844917664, .13168863844917664, .11819453196151841, .11819453196151841, .10193011981724044, .10193011981724044, .08327674157670475, .08327674157670475, .06267204833410907, .06267204833410907, .04060142980038694, .04060142980038694, .017614007139152118, .017614007139152118], [.14608113364969041, .14452440398997005, .14452440398997005, .13988739479107315, .13988739479107315, .13226893863333747, .13226893863333747, .12183141605372853, .12183141605372853, .10879729916714838, .10879729916714838, .09344442345603386, .09344442345603386, .0761001136283793, .0761001136283793, .057134425426857205, .057134425426857205, .036953789770852494, .036953789770852494, .016017228257774335, .016017228257774335], [.13925187285563198, .13925187285563198, .13654149834601517, .13654149834601517, .13117350478706238, .13117350478706238, .12325237681051242, .12325237681051242, .11293229608053922, .11293229608053922, .10041414444288096, .10041414444288096, .08594160621706773, .08594160621706773, .06979646842452049, .06979646842452049, .052293335152683286, .052293335152683286, .03377490158481415, .03377490158481415, .0146279952982722, .0146279952982722], [.13365457218610619, .1324620394046966, .1324620394046966, .12890572218808216, .12890572218808216, .12304908430672953, .12304908430672953, .11499664022241136, .11499664022241136, .10489209146454141, .10489209146454141, .09291576606003515, .09291576606003515, .07928141177671895, .07928141177671895, .06423242140852585, .06423242140852585, .04803767173108467, .04803767173108467, .030988005856979445, .030988005856979445, .013411859487141771, .013411859487141771], [.12793819534675216, .12793819534675216, .1258374563468283, .1258374563468283, .12167047292780339, .12167047292780339, .1155056680537256, .1155056680537256, .10744427011596563, .10744427011596563, .09761865210411388, .09761865210411388, .08619016153195327, .08619016153195327, .0733464814110803, .0733464814110803, .05929858491543678, .05929858491543678, .04427743881741981, .04427743881741981, .028531388628933663, .028531388628933663, .0123412297999872, .0123412297999872]], se = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1]], oe = (t, e, i) => { let r, a, n; r = i / 2, a = 0; for (let i = 0; i < 20; i++)n = r * ae[20][i] + r, a += ne[20][i] * le(t, e, n); return r * a }, he = (t, e, i) => { void 0 === i && (i = 1); const r = t[0] - 2 * t[1] + t[2], a = e[0] - 2 * e[1] + e[2], n = 2 * t[1] - 2 * t[0], s = 2 * e[1] - 2 * e[0], o = 4 * (r * r + a * a), h = 4 * (r * n + a * s), l = n * n + s * s; if (0 === o) return i * Math.sqrt(Math.pow(t[2] - t[0], 2) + Math.pow(e[2] - e[0], 2)); const d = h / (2 * o), c = i + d, g = l / o - d * d, u = c * c + g > 0 ? Math.sqrt(c * c + g) : 0, f = d * d + g > 0 ? Math.sqrt(d * d + g) : 0, p = d + Math.sqrt(d * d + g) !== 0 ? g * Math.log(Math.abs((c + u) / (d + f))) : 0; return Math.sqrt(o) / 2 * (c * u - d * f + p) }; function le(t, e, i) { const r = de(1, i, t), a = de(1, i, e), n = r * r + a * a; return Math.sqrt(n) } const de = (t, e, i) => { const r = i.length - 1; let a, n; if (0 === r) return 0; if (0 === t) { n = 0; for (let t = 0; t <= r; t++)n += se[r][t] * Math.pow(1 - e, r - t) * Math.pow(e, t) * i[t]; return n } a = new Array(r); for (let t = 0; t < r; t++)a[t] = r * (i[t + 1] - i[t]); return de(t - 1, e, a) }, ce = (t, e, i) => { let r = 1, a = t / e, n = (t - i(a)) / e, s = 0; for (; r > .001;) { const o = i(a + n), h = Math.abs(t - o) / e; if (h < r) r = h, a += n; else { const s = i(a - n), o = Math.abs(t - s) / e; o < r ? (r = o, a -= n) : n /= 2 } if (s++, s > 500) break } return a }; class ge extends Bt { constructor(t) { super(t), this.dataArray = [], this.pathLength = 0, this._readDataAttribute(), this.on("dataChange.konva", (function () { this._readDataAttribute() })) } _readDataAttribute() { this.dataArray = ge.parsePathData(this.data()), this.pathLength = ge.getPathLength(this.dataArray) } _sceneFunc(t) { var e = this.dataArray; t.beginPath(); for (var i = !1, r = 0; r < e.length; r++) { var a = e[r].command, n = e[r].points; switch (a) { case "L": t.lineTo(n[0], n[1]); break; case "M": t.moveTo(n[0], n[1]); break; case "C": t.bezierCurveTo(n[0], n[1], n[2], n[3], n[4], n[5]); break; case "Q": t.quadraticCurveTo(n[0], n[1], n[2], n[3]); break; case "A": var s = n[0], o = n[1], h = n[2], l = n[3], d = n[4], c = n[5], g = n[6], u = n[7], f = h > l ? h : l, p = h > l ? 1 : h / l, v = h > l ? l / h : 1; t.translate(s, o), t.rotate(g), t.scale(p, v), t.arc(0, 0, f, d, d + c, 1 - u), t.scale(1 / p, 1 / v), t.rotate(-g), t.translate(-s, -o); break; case "z": i = !0, t.closePath() } } i || this.hasFill() ? t.fillStrokeShape(this) : t.strokeShape(this) } getSelfRect() { var t = []; this.dataArray.forEach((function (e) { if ("A" === e.command) { var i = e.points[4], r = e.points[5], a = e.points[4] + r, n = Math.PI / 180; if (Math.abs(i - a) < n && (n = Math.abs(i - a)), r < 0) for (let r = i - n; r > a; r -= n) { const i = ge.getPointOnEllipticalArc(e.points[0], e.points[1], e.points[2], e.points[3], r, 0); t.push(i.x, i.y) } else for (let r = i + n; r < a; r += n) { const i = ge.getPointOnEllipticalArc(e.points[0], e.points[1], e.points[2], e.points[3], r, 0); t.push(i.x, i.y) } } else if ("C" === e.command) for (let i = 0; i <= 1; i += .01) { const r = ge.getPointOnCubicBezier(i, e.start.x, e.start.y, e.points[0], e.points[1], e.points[2], e.points[3], e.points[4], e.points[5]); t.push(r.x, r.y) } else t = t.concat(e.points) })); for (var e, i, r = t[0], a = t[0], n = t[1], s = t[1], o = 0; o < t.length / 2; o++)e = t[2 * o], i = t[2 * o + 1], isNaN(e) || (r = Math.min(r, e), a = Math.max(a, e)), isNaN(i) || (n = Math.min(n, i), s = Math.max(s, i)); return { x: r, y: n, width: a - r, height: s - n } } getLength() { return this.pathLength } getPointAtLength(t) { return ge.getPointAtLengthOfDataArray(t, this.dataArray) } static getLineLength(t, e, i, r) { return Math.sqrt((i - t) * (i - t) + (r - e) * (r - e)) } static getPathLength(t) { let e = 0; for (var i = 0; i < t.length; ++i)e += t[i].pathLength; return e } static getPointAtLengthOfDataArray(t, e) { var i, r = 0, a = e.length; if (!a) return null; for (; r < a && t > e[r].pathLength;)t -= e[r].pathLength, ++r; if (r === a) return { x: (i = e[r - 1].points.slice(-2))[0], y: i[1] }; if (t < .01) return { x: (i = e[r].points.slice(0, 2))[0], y: i[1] }; var n = e[r], s = n.points; switch (n.command) { case "L": return ge.getPointOnLine(t, n.start.x, n.start.y, s[0], s[1]); case "C": return ge.getPointOnCubicBezier(ce(t, ge.getPathLength(e), (t => oe([n.start.x, s[0], s[2], s[4]], [n.start.y, s[1], s[3], s[5]], t))), n.start.x, n.start.y, s[0], s[1], s[2], s[3], s[4], s[5]); case "Q": return ge.getPointOnQuadraticBezier(ce(t, ge.getPathLength(e), (t => he([n.start.x, s[0], s[2]], [n.start.y, s[1], s[3]], t))), n.start.x, n.start.y, s[0], s[1], s[2], s[3]); case "A": var o = s[0], h = s[1], l = s[2], d = s[3], c = s[4], g = s[5], u = s[6]; return c += g * t / n.pathLength, ge.getPointOnEllipticalArc(o, h, l, d, c, u) }return null } static getPointOnLine(t, e, i, r, a, n, s) { void 0 === n && (n = e), void 0 === s && (s = i); var o = (a - i) / (r - e + 1e-8), h = Math.sqrt(t * t / (1 + o * o)); r < e && (h *= -1); var l, d = o * h; if (r === e) l = { x: n, y: s + d }; else if ((s - i) / (n - e + 1e-8) === o) l = { x: n + h, y: s + d }; else { var c, g, u = this.getLineLength(e, i, r, a), f = (n - e) * (r - e) + (s - i) * (a - i); c = e + (f /= u * u) * (r - e), g = i + f * (a - i); var p = this.getLineLength(n, s, c, g), v = Math.sqrt(t * t - p * p); h = Math.sqrt(v * v / (1 + o * o)), r < e && (h *= -1), l = { x: c + h, y: g + (d = o * h) } } return l } static getPointOnCubicBezier(t, e, i, r, a, n, s, o, h) { function l(t) { return t * t * t } function d(t) { return 3 * t * t * (1 - t) } function c(t) { return 3 * t * (1 - t) * (1 - t) } function g(t) { return (1 - t) * (1 - t) * (1 - t) } return { x: o * l(t) + n * d(t) + r * c(t) + e * g(t), y: h * l(t) + s * d(t) + a * c(t) + i * g(t) } } static getPointOnQuadraticBezier(t, e, i, r, a, n, s) { function o(t) { return t * t } function h(t) { return 2 * t * (1 - t) } function l(t) { return (1 - t) * (1 - t) } return { x: n * o(t) + r * h(t) + e * l(t), y: s * o(t) + a * h(t) + i * l(t) } } static getPointOnEllipticalArc(t, e, i, r, a, n) { var s = Math.cos(n), o = Math.sin(n), h = i * Math.cos(a), l = r * Math.sin(a); return { x: t + (h * s - l * o), y: e + (h * o + l * s) } } static parsePathData(t) { if (!t) return []; var e = t, i = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"]; e = e.replace(new RegExp(" ", "g"), ","); for (var r = 0; r < i.length; r++)e = e.replace(new RegExp(i[r], "g"), "|" + i[r]); var a, n = e.split("|"), s = [], o = [], h = 0, l = 0, d = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/gi; for (r = 1; r < n.length; r++) { var c = n[r], g = c.charAt(0); for (c = c.slice(1), o.length = 0; a = d.exec(c);)o.push(a[0]); for (var u = [], f = 0, p = o.length; f < p; f++)if ("00" !== o[f]) { var v = parseFloat(o[f]); isNaN(v) ? u.push(0) : u.push(v) } else u.push(0, 0); for (; u.length > 0 && !isNaN(u[0]);) { var m, _, y, x, b, S, w, C, P, k, T = null, A = [], M = h, G = l; switch (g) { case "l": h += u.shift(), l += u.shift(), T = "L", A.push(h, l); break; case "L": h = u.shift(), l = u.shift(), A.push(h, l); break; case "m": var R = u.shift(), E = u.shift(); if (h += R, l += E, T = "M", s.length > 2 && "z" === s[s.length - 1].command) for (var D = s.length - 2; D >= 0; D--)if ("M" === s[D].command) { h = s[D].points[0] + R, l = s[D].points[1] + E; break } A.push(h, l), g = "l"; break; case "M": h = u.shift(), l = u.shift(), T = "M", A.push(h, l), g = "L"; break; case "h": h += u.shift(), T = "L", A.push(h, l); break; case "H": h = u.shift(), T = "L", A.push(h, l); break; case "v": l += u.shift(), T = "L", A.push(h, l); break; case "V": l = u.shift(), T = "L", A.push(h, l); break; case "C": A.push(u.shift(), u.shift(), u.shift(), u.shift()), h = u.shift(), l = u.shift(), A.push(h, l); break; case "c": A.push(h + u.shift(), l + u.shift(), h + u.shift(), l + u.shift()), h += u.shift(), l += u.shift(), T = "C", A.push(h, l); break; case "S": _ = h, y = l, "C" === (m = s[s.length - 1]).command && (_ = h + (h - m.points[2]), y = l + (l - m.points[3])), A.push(_, y, u.shift(), u.shift()), h = u.shift(), l = u.shift(), T = "C", A.push(h, l); break; case "s": _ = h, y = l, "C" === (m = s[s.length - 1]).command && (_ = h + (h - m.points[2]), y = l + (l - m.points[3])), A.push(_, y, h + u.shift(), l + u.shift()), h += u.shift(), l += u.shift(), T = "C", A.push(h, l); break; case "Q": A.push(u.shift(), u.shift()), h = u.shift(), l = u.shift(), A.push(h, l); break; case "q": A.push(h + u.shift(), l + u.shift()), h += u.shift(), l += u.shift(), T = "Q", A.push(h, l); break; case "T": _ = h, y = l, "Q" === (m = s[s.length - 1]).command && (_ = h + (h - m.points[0]), y = l + (l - m.points[1])), h = u.shift(), l = u.shift(), T = "Q", A.push(_, y, h, l); break; case "t": _ = h, y = l, "Q" === (m = s[s.length - 1]).command && (_ = h + (h - m.points[0]), y = l + (l - m.points[1])), h += u.shift(), l += u.shift(), T = "Q", A.push(_, y, h, l); break; case "A": x = u.shift(), b = u.shift(), S = u.shift(), w = u.shift(), C = u.shift(), P = h, k = l, h = u.shift(), l = u.shift(), T = "A", A = this.convertEndpointToCenterParameterization(P, k, h, l, w, C, x, b, S); break; case "a": x = u.shift(), b = u.shift(), S = u.shift(), w = u.shift(), C = u.shift(), P = h, k = l, h += u.shift(), l += u.shift(), T = "A", A = this.convertEndpointToCenterParameterization(P, k, h, l, w, C, x, b, S) }s.push({ command: T || g, points: A, start: { x: M, y: G }, pathLength: this.calcLength(M, G, T || g, A) }) } "z" !== g && "Z" !== g || s.push({ command: "z", points: [], start: void 0, pathLength: 0 }) } return s } static calcLength(t, e, i, r) { var a, n, s, o, h = ge; switch (i) { case "L": return h.getLineLength(t, e, r[0], r[1]); case "C": return oe([t, r[0], r[2], r[4]], [e, r[1], r[3], r[5]], 1); case "Q": return he([t, r[0], r[2]], [e, r[1], r[3]], 1); case "A": a = 0; var l = r[4], d = r[5], c = r[4] + d, g = Math.PI / 180; if (Math.abs(l - c) < g && (g = Math.abs(l - c)), n = h.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], l, 0), d < 0) for (o = l - g; o > c; o -= g)s = h.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], o, 0), a += h.getLineLength(n.x, n.y, s.x, s.y), n = s; else for (o = l + g; o < c; o += g)s = h.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], o, 0), a += h.getLineLength(n.x, n.y, s.x, s.y), n = s; return s = h.getPointOnEllipticalArc(r[0], r[1], r[2], r[3], c, 0), a += h.getLineLength(n.x, n.y, s.x, s.y) }return 0 } static convertEndpointToCenterParameterization(t, e, i, r, a, n, s, o, h) { var l = h * (Math.PI / 180), d = Math.cos(l) * (t - i) / 2 + Math.sin(l) * (e - r) / 2, c = -1 * Math.sin(l) * (t - i) / 2 + Math.cos(l) * (e - r) / 2, g = d * d / (s * s) + c * c / (o * o); g > 1 && (s *= Math.sqrt(g), o *= Math.sqrt(g)); var u = Math.sqrt((s * s * (o * o) - s * s * (c * c) - o * o * (d * d)) / (s * s * (c * c) + o * o * (d * d))); a === n && (u *= -1), isNaN(u) && (u = 0); var f = u * s * c / o, p = u * -o * d / s, v = (t + i) / 2 + Math.cos(l) * f - Math.sin(l) * p, m = (e + r) / 2 + Math.sin(l) * f + Math.cos(l) * p, _ = function (t) { return Math.sqrt(t[0] * t[0] + t[1] * t[1]) }, y = function (t, e) { return (t[0] * e[0] + t[1] * e[1]) / (_(t) * _(e)) }, x = function (t, e) { return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(y(t, e)) }, b = x([1, 0], [(d - f) / s, (c - p) / o]), S = [(d - f) / s, (c - p) / o], w = [(-1 * d - f) / s, (-1 * c - p) / o], C = x(S, w); return y(S, w) <= -1 && (C = Math.PI), y(S, w) >= 1 && (C = 0), 0 === n && C > 0 && (C -= 2 * Math.PI), 1 === n && C < 0 && (C += 2 * Math.PI), [v, m, s, o, b, C, l, n] } } ge.prototype.className = "Path", ge.prototype._attrsAffectingSize = ["data"], r(ge), w.addGetterSetter(ge, "data"); class ue extends re { _sceneFunc(t) { super._sceneFunc(t); var e = 2 * Math.PI, i = this.points(), r = i, a = 0 !== this.tension() && i.length > 4; a && (r = this.getTensionPoints()); var n, s, o = this.pointerLength(), h = i.length; if (a) { const t = [r[r.length - 4], r[r.length - 3], r[r.length - 2], r[r.length - 1], i[h - 2], i[h - 1]], e = ge.calcLength(r[r.length - 4], r[r.length - 3], "C", t), a = ge.getPointOnQuadraticBezier(Math.min(1, 1 - o / e), t[0], t[1], t[2], t[3], t[4], t[5]); n = i[h - 2] - a.x, s = i[h - 1] - a.y } else n = i[h - 2] - i[h - 4], s = i[h - 1] - i[h - 3]; var l = (Math.atan2(s, n) + e) % e, d = this.pointerWidth(); this.pointerAtEnding() && (t.save(), t.beginPath(), t.translate(i[h - 2], i[h - 1]), t.rotate(l), t.moveTo(0, 0), t.lineTo(-o, d / 2), t.lineTo(-o, -d / 2), t.closePath(), t.restore(), this.__fillStroke(t)), this.pointerAtBeginning() && (t.save(), t.beginPath(), t.translate(i[0], i[1]), a ? (n = (r[0] + r[2]) / 2 - i[0], s = (r[1] + r[3]) / 2 - i[1]) : (n = i[2] - i[0], s = i[3] - i[1]), t.rotate((Math.atan2(-s, -n) + e) % e), t.moveTo(0, 0), t.lineTo(-o, d / 2), t.lineTo(-o, -d / 2), t.closePath(), t.restore(), this.__fillStroke(t)) } __fillStroke(t) { var e = this.dashEnabled(); e && (this.attrs.dashEnabled = !1, t.setLineDash([])), t.fillStrokeShape(this), e && (this.attrs.dashEnabled = !0) } getSelfRect() { const t = super.getSelfRect(), e = this.pointerWidth() / 2; return { x: t.x - e, y: t.y - e, width: t.width + 2 * e, height: t.height + 2 * e } } } ue.prototype.className = "Arrow", r(ue), w.addGetterSetter(ue, "pointerLength", 10, p()), w.addGetterSetter(ue, "pointerWidth", 10, p()), w.addGetterSetter(ue, "pointerAtBeginning", !1), w.addGetterSetter(ue, "pointerAtEnding", !0); class fe extends Bt { _sceneFunc(t) { t.beginPath(), t.arc(0, 0, this.attrs.radius || 0, 0, 2 * Math.PI, !1), t.closePath(), t.fillStrokeShape(this) } getWidth() { return 2 * this.radius() } getHeight() { return 2 * this.radius() } setWidth(t) { this.radius() !== t / 2 && this.radius(t / 2) } setHeight(t) { this.radius() !== t / 2 && this.radius(t / 2) } } fe.prototype._centroid = !0, fe.prototype.className = "Circle", fe.prototype._attrsAffectingSize = ["radius"], r(fe), w.addGetterSetter(fe, "radius", 0, p()); class pe extends Bt { _sceneFunc(t) { var e = this.radiusX(), i = this.radiusY(); t.beginPath(), t.save(), e !== i && t.scale(1, i / e), t.arc(0, 0, e, 0, 2 * Math.PI, !1), t.restore(), t.closePath(), t.fillStrokeShape(this) } getWidth() { return 2 * this.radiusX() } getHeight() { return 2 * this.radiusY() } setWidth(t) { this.radiusX(t / 2) } setHeight(t) { this.radiusY(t / 2) } } pe.prototype.className = "Ellipse", pe.prototype._centroid = !0, pe.prototype._attrsAffectingSize = ["radiusX", "radiusY"], r(pe), w.addComponentsGetterSetter(pe, "radius", ["x", "y"]), w.addGetterSetter(pe, "radiusX", 0, p()), w.addGetterSetter(pe, "radiusY", 0, p()); class ve extends Bt { constructor(t) { super(t), this.on("imageChange.konva", (() => { this._setImageLoad() })), this._setImageLoad() } _setImageLoad() { const t = this.image(); t && t.complete || t && 4 === t.readyState || t && t.addEventListener && t.addEventListener("load", (() => { this._requestDraw() })) } _useBufferCanvas() { return super._useBufferCanvas(!0) } _sceneFunc(t) { const e = this.getWidth(), i = this.getHeight(), r = this.cornerRadius(), a = this.attrs.image; let n; if (a) { const t = this.attrs.cropWidth, r = this.attrs.cropHeight; n = t && r ? [a, this.cropX(), this.cropY(), t, r, 0, 0, e, i] : [a, 0, 0, e, i] } (this.hasFill() || this.hasStroke() || r) && (t.beginPath(), r ? g.drawRoundedRectPath(t, e, i, r) : t.rect(0, 0, e, i), t.closePath(), t.fillStrokeShape(this)), a && (r && t.clip(), t.drawImage.apply(t, n)) } _hitFunc(t) { var e = this.width(), i = this.height(), r = this.cornerRadius(); t.beginPath(), r ? g.drawRoundedRectPath(t, e, i, r) : t.rect(0, 0, e, i), t.closePath(), t.fillStrokeShape(this) } getWidth() { var t, e; return null !== (t = this.attrs.width) && void 0 !== t ? t : null === (e = this.image()) || void 0 === e ? void 0 : e.width } getHeight() { var t, e; return null !== (t = this.attrs.height) && void 0 !== t ? t : null === (e = this.image()) || void 0 === e ? void 0 : e.height } static fromURL(t, e, i = null) { var r = g.createImageElement(); r.onload = function () { var t = new ve({ image: r }); e(t) }, r.onerror = i, r.crossOrigin = "Anonymous", r.src = t } } ve.prototype.className = "Image", r(ve), w.addGetterSetter(ve, "cornerRadius", 0, v(4)), w.addGetterSetter(ve, "image"), w.addComponentsGetterSetter(ve, "crop", ["x", "y", "width", "height"]), w.addGetterSetter(ve, "cropX", 0, p()), w.addGetterSetter(ve, "cropY", 0, p()), w.addGetterSetter(ve, "cropWidth", 0, p()), w.addGetterSetter(ve, "cropHeight", 0, p()); var me = ["fontFamily", "fontSize", "fontStyle", "padding", "lineHeight", "text", "width", "height", "pointerDirection", "pointerWidth", "pointerHeight"], _e = "up", ye = "right", xe = "down", be = "left", Se = me.length; class we extends Xt { constructor(t) { super(t), this.on("add.konva", (function (t) { this._addListeners(t.child), this._sync() })) } getText() { return this.find("Text")[0] } getTag() { return this.find("Tag")[0] } _addListeners(t) { var e, i = this, r = function () { i._sync() }; for (e = 0; e < Se; e++)t.on(me[e] + "Change.konva", r) } getWidth() { return this.getText().width() } getHeight() { return this.getText().height() } _sync() { var t, e, i, r, a, n, s, o = this.getText(), h = this.getTag(); if (o && h) { switch (t = o.width(), e = o.height(), i = h.pointerDirection(), r = h.pointerWidth(), s = h.pointerHeight(), a = 0, n = 0, i) { case _e: a = t / 2, n = -1 * s; break; case ye: a = t + r, n = e / 2; break; case xe: a = t / 2, n = e + s; break; case be: a = -1 * r, n = e / 2 }h.setAttrs({ x: -1 * a, y: -1 * n, width: t, height: e }), o.setAttrs({ x: -1 * a, y: -1 * n }) } } } we.prototype.className = "Label", r(we); class Ce extends Bt { _sceneFunc(t) { var e = this.width(), i = this.height(), r = this.pointerDirection(), a = this.pointerWidth(), n = this.pointerHeight(), s = this.cornerRadius(); let o = 0, h = 0, l = 0, d = 0; "number" == typeof s ? o = h = l = d = Math.min(s, e / 2, i / 2) : (o = Math.min(s[0] || 0, e / 2, i / 2), h = Math.min(s[1] || 0, e / 2, i / 2), d = Math.min(s[2] || 0, e / 2, i / 2), l = Math.min(s[3] || 0, e / 2, i / 2)), t.beginPath(), t.moveTo(o, 0), r === _e && (t.lineTo((e - a) / 2, 0), t.lineTo(e / 2, -1 * n), t.lineTo((e + a) / 2, 0)), t.lineTo(e - h, 0), t.arc(e - h, h, h, 3 * Math.PI / 2, 0, !1), r === ye && (t.lineTo(e, (i - n) / 2), t.lineTo(e + a, i / 2), t.lineTo(e, (i + n) / 2)), t.lineTo(e, i - d), t.arc(e - d, i - d, d, 0, Math.PI / 2, !1), r === xe && (t.lineTo((e + a) / 2, i), t.lineTo(e / 2, i + n), t.lineTo((e - a) / 2, i)), t.lineTo(l, i), t.arc(l, i - l, l, Math.PI / 2, Math.PI, !1), r === be && (t.lineTo(0, (i + n) / 2), t.lineTo(-1 * a, i / 2), t.lineTo(0, (i - n) / 2)), t.lineTo(0, o), t.arc(o, o, o, Math.PI, 3 * Math.PI / 2, !1), t.closePath(), t.fillStrokeShape(this) } getSelfRect() { var t = 0, e = 0, i = this.pointerWidth(), r = this.pointerHeight(), a = this.pointerDirection(), n = this.width(), s = this.height(); return a === _e ? (e -= r, s += r) : a === xe ? s += r : a === be ? (t -= 1.5 * i, n += i) : a === ye && (n += 1.5 * i), { x: t, y: e, width: n, height: s } } } Ce.prototype.className = "Tag", r(Ce), w.addGetterSetter(Ce, "pointerDirection", "none"), w.addGetterSetter(Ce, "pointerWidth", 0, p()), w.addGetterSetter(Ce, "pointerHeight", 0, p()), w.addGetterSetter(Ce, "cornerRadius", 0, v(4)); class Pe extends Bt { _sceneFunc(t) { var e = this.cornerRadius(), i = this.width(), r = this.height(); t.beginPath(), e ? g.drawRoundedRectPath(t, i, r, e) : t.rect(0, 0, i, r), t.closePath(), t.fillStrokeShape(this) } } Pe.prototype.className = "Rect", r(Pe), w.addGetterSetter(Pe, "cornerRadius", 0, v(4)); class ke extends Bt { _sceneFunc(t) { const e = this._getPoints(); t.beginPath(), t.moveTo(e[0].x, e[0].y); for (var i = 1; i < e.length; i++)t.lineTo(e[i].x, e[i].y); t.closePath(), t.fillStrokeShape(this) } _getPoints() { const t = this.attrs.sides, e = this.attrs.radius || 0, i = []; for (var r = 0; r < t; r++)i.push({ x: e * Math.sin(2 * r * Math.PI / t), y: -1 * e * Math.cos(2 * r * Math.PI / t) }); return i } getSelfRect() { const t = this._getPoints(); var e = t[0].x, i = t[0].y, r = t[0].x, a = t[0].y; return t.forEach((t => { e = Math.min(e, t.x), i = Math.max(i, t.x), r = Math.min(r, t.y), a = Math.max(a, t.y) })), { x: e, y: r, width: i - e, height: a - r } } getWidth() { return 2 * this.radius() } getHeight() { return 2 * this.radius() } setWidth(t) { this.radius(t / 2) } setHeight(t) { this.radius(t / 2) } } ke.prototype.className = "RegularPolygon", ke.prototype._centroid = !0, ke.prototype._attrsAffectingSize = ["radius"], r(ke), w.addGetterSetter(ke, "radius", 0, p()), w.addGetterSetter(ke, "sides", 0, p()); var Te = 2 * Math.PI; class Ae extends Bt { _sceneFunc(t) { t.beginPath(), t.arc(0, 0, this.innerRadius(), 0, Te, !1), t.moveTo(this.outerRadius(), 0), t.arc(0, 0, this.outerRadius(), Te, 0, !0), t.closePath(), t.fillStrokeShape(this) } getWidth() { return 2 * this.outerRadius() } getHeight() { return 2 * this.outerRadius() } setWidth(t) { this.outerRadius(t / 2) } setHeight(t) { this.outerRadius(t / 2) } } Ae.prototype.className = "Ring", Ae.prototype._centroid = !0, Ae.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], r(Ae), w.addGetterSetter(Ae, "innerRadius", 0, p()), w.addGetterSetter(Ae, "outerRadius", 0, p()); class Me extends Bt { constructor(t) { super(t), this._updated = !0, this.anim = new qt((() => { var t = this._updated; return this._updated = !1, t })), this.on("animationChange.konva", (function () { this.frameIndex(0) })), this.on("frameIndexChange.konva", (function () { this._updated = !0 })), this.on("frameRateChange.konva", (function () { this.anim.isRunning() && (clearInterval(this.interval), this._setInterval()) })) } _sceneFunc(t) { var e = this.animation(), i = this.frameIndex(), r = 4 * i, a = this.animations()[e], n = this.frameOffsets(), s = a[r + 0], o = a[r + 1], h = a[r + 2], l = a[r + 3], d = this.image(); if ((this.hasFill() || this.hasStroke()) && (t.beginPath(), t.rect(0, 0, h, l), t.closePath(), t.fillStrokeShape(this)), d) if (n) { var c = n[e], g = 2 * i; t.drawImage(d, s, o, h, l, c[g + 0], c[g + 1], h, l) } else t.drawImage(d, s, o, h, l, 0, 0, h, l) } _hitFunc(t) { var e = this.animation(), i = this.frameIndex(), r = 4 * i, a = this.animations()[e], n = this.frameOffsets(), s = a[r + 2], o = a[r + 3]; if (t.beginPath(), n) { var h = n[e], l = 2 * i; t.rect(h[l + 0], h[l + 1], s, o) } else t.rect(0, 0, s, o); t.closePath(), t.fillShape(this) } _useBufferCanvas() { return super._useBufferCanvas(!0) } _setInterval() { var t = this; this.interval = setInterval((function () { t._updateIndex() }), 1e3 / this.frameRate()) } start() { if (!this.isRunning()) { var t = this.getLayer(); this.anim.setLayers(t), this._setInterval(), this.anim.start() } } stop() { this.anim.stop(), clearInterval(this.interval) } isRunning() { return this.anim.isRunning() } _updateIndex() { var t = this.frameIndex(), e = this.animation(); t < this.animations()[e].length / 4 - 1 ? this.frameIndex(t + 1) : this.frameIndex(0) } } Me.prototype.className = "Sprite", r(Me), w.addGetterSetter(Me, "animation"), w.addGetterSetter(Me, "animations"), w.addGetterSetter(Me, "frameOffsets"), w.addGetterSetter(Me, "image"), w.addGetterSetter(Me, "frameIndex", 0, p()), w.addGetterSetter(Me, "frameRate", 17, p()), w.backCompat(Me, { index: "frameIndex", getIndex: "getFrameIndex", setIndex: "setFrameIndex" }); class Ge extends Bt { _sceneFunc(t) { var e = this.innerRadius(), i = this.outerRadius(), r = this.numPoints(); t.beginPath(), t.moveTo(0, 0 - i); for (var a = 1; a < 2 * r; a++) { var n = a % 2 == 0 ? i : e, s = n * Math.sin(a * Math.PI / r), o = -1 * n * Math.cos(a * Math.PI / r); t.lineTo(s, o) } t.closePath(), t.fillStrokeShape(this) } getWidth() { return 2 * this.outerRadius() } getHeight() { return 2 * this.outerRadius() } setWidth(t) { this.outerRadius(t / 2) } setHeight(t) { this.outerRadius(t / 2) } } function Re(t) { return Array.from(t) } Ge.prototype.className = "Star", Ge.prototype._centroid = !0, Ge.prototype._attrsAffectingSize = ["innerRadius", "outerRadius"], r(Ge), w.addGetterSetter(Ge, "numPoints", 5, p()), w.addGetterSetter(Ge, "innerRadius", 0, p()), w.addGetterSetter(Ge, "outerRadius", 0, p()); var Ee, De = "auto", Le = "justify", Oe = "left", Ie = "middle", Fe = "normal", Ne = " ", Be = "none", He = ["fontFamily", "fontSize", "fontStyle", "fontVariant", "padding", "align", "verticalAlign", "lineHeight", "text", "width", "height", "wrap", "ellipsis", "letterSpacing"], We = He.length; function ze() { return Ee || (Ee = g.createCanvasElement().getContext("2d")) } class Ye extends Bt { constructor(t) { super(function (t) { return (t = t || {}).fillLinearGradientColorStops || t.fillRadialGradientColorStops || t.fillPatternImage || (t.fill = t.fill || "black"), t }(t)), this._partialTextX = 0, this._partialTextY = 0; for (var e = 0; e < We; e++)this.on(He[e] + "Change.konva", this._setTextData); this._setTextData() } _sceneFunc(t) { var e = this.textArr, i = e.length; if (this.text()) { var r, a = this.padding(), n = this.fontSize(), s = this.lineHeight() * n, o = this.verticalAlign(), h = 0, l = this.align(), d = this.getWidth(), c = this.letterSpacing(), g = this.fill(), u = this.textDecoration(), f = -1 !== u.indexOf("underline"), p = -1 !== u.indexOf("line-through"), v = 0, m = (v = s / 2, 0), _ = 0; for (t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", Ie), t.setAttr("textAlign", Oe), o === Ie ? h = (this.getHeight() - i * s - 2 * a) / 2 : "bottom" === o && (h = this.getHeight() - i * s - 2 * a), t.translate(a, h + a), r = 0; r < i; r++) { m = 0, _ = 0; var y, x, b, S = e[r], w = S.text, C = S.width, P = S.lastInParagraph; if (t.save(), "right" === l ? m += d - C - 2 * a : "center" === l && (m += (d - C - 2 * a) / 2), f) { t.save(), t.beginPath(), t.moveTo(m, v + _ + Math.round(n / 2)), x = 0 === (y = w.split(" ").length - 1), b = l !== Le || P ? C : d - 2 * a, t.lineTo(m + Math.round(b), v + _ + Math.round(n / 2)), t.lineWidth = n / 15; const e = this._getLinearGradient(); t.strokeStyle = e || g, t.stroke(), t.restore() } if (p) { t.save(), t.beginPath(), t.moveTo(m, v + _), x = 0 === (y = w.split(" ").length - 1), b = l === Le && P && !x ? d - 2 * a : C, t.lineTo(m + Math.round(b), v + _), t.lineWidth = n / 15; const e = this._getLinearGradient(); t.strokeStyle = e || g, t.stroke(), t.restore() } if (0 !== c || l === Le) { y = w.split(" ").length - 1; for (var k = Re(w), T = 0; T < k.length; T++) { var A = k[T]; " " !== A || P || l !== Le || (m += (d - 2 * a - C) / y), this._partialTextX = m, this._partialTextY = v + _, this._partialText = A, t.fillStrokeShape(this), m += this.measureSize(A).width + c } } else this._partialTextX = m, this._partialTextY = v + _, this._partialText = w, t.fillStrokeShape(this); t.restore(), i > 1 && (v += s) } } } _hitFunc(t) { var e = this.getWidth(), i = this.getHeight(); t.beginPath(), t.rect(0, 0, e, i), t.closePath(), t.fillStrokeShape(this) } setText(t) { var e = g._isString(t) ? t : null == t ? "" : t + ""; return this._setAttr("text", e), this } getWidth() { return this.attrs.width === De || void 0 === this.attrs.width ? this.getTextWidth() + 2 * this.padding() : this.attrs.width } getHeight() { return this.attrs.height === De || void 0 === this.attrs.height ? this.fontSize() * this.textArr.length * this.lineHeight() + 2 * this.padding() : this.attrs.height } getTextWidth() { return this.textWidth } getTextHeight() { return g.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight } measureSize(t) { var e, i = ze(), r = this.fontSize(); return i.save(), i.font = this._getContextFont(), e = i.measureText(t), i.restore(), { width: e.width, height: r } } _getContextFont() { return this.fontStyle() + Ne + this.fontVariant() + Ne + (this.fontSize() + "px ") + this.fontFamily().split(",").map((t => { const e = (t = t.trim()).indexOf(" ") >= 0, i = t.indexOf('"') >= 0 || t.indexOf("'") >= 0; return e && !i && (t = `"${t}"`), t })).join(", ") } _addTextLine(t) { this.align() === Le && (t = t.trim()); var e = this._getTextWidth(t); return this.textArr.push({ text: t, width: e, lastInParagraph: !1 }) } _getTextWidth(t) { var e = this.letterSpacing(), i = t.length; return ze().measureText(t).width + (i ? e * (i - 1) : 0) } _setTextData() { var t = this.text().split("\n"), e = +this.fontSize(), i = 0, r = this.lineHeight() * e, a = this.attrs.width, n = this.attrs.height, s = a !== De && void 0 !== a, o = n !== De && void 0 !== n, h = this.padding(), l = a - 2 * h, d = n - 2 * h, c = 0, g = this.wrap(), u = "char" !== g && g !== Be, f = this.ellipsis(); this.textArr = [], ze().font = this._getContextFont(); for (var p = f ? this._getTextWidth("…") : 0, v = 0, m = t.length; v < m; ++v) { var _ = t[v], y = this._getTextWidth(_); if (s && y > l) for (; _.length > 0;) { for (var x = 0, b = _.length, S = "", w = 0; x < b;) { var C = x + b >>> 1, P = _.slice(0, C + 1), k = this._getTextWidth(P) + p; k <= l ? (x = C + 1, S = P, w = k) : b = C } if (!S) break; if (u) { var T, A = _[S.length]; (T = (A === Ne || "-" === A) && w <= l ? S.length : Math.max(S.lastIndexOf(Ne), S.lastIndexOf("-")) + 1) > 0 && (x = T, S = S.slice(0, x), w = this._getTextWidth(S)) } if (S = S.trimRight(), this._addTextLine(S), i = Math.max(i, w), c += r, this._shouldHandleEllipsis(c)) { this._tryToAddEllipsisToLastLine(); break } if ((_ = (_ = _.slice(x)).trimLeft()).length > 0 && (y = this._getTextWidth(_)) <= l) { this._addTextLine(_), c += r, i = Math.max(i, y); break } } else this._addTextLine(_), c += r, i = Math.max(i, y), this._shouldHandleEllipsis(c) && v < m - 1 && this._tryToAddEllipsisToLastLine(); if (this.textArr[this.textArr.length - 1] && (this.textArr[this.textArr.length - 1].lastInParagraph = !0), o && c + r > d) break } this.textHeight = e, this.textWidth = i } _shouldHandleEllipsis(t) { var e = +this.fontSize(), i = this.lineHeight() * e, r = this.attrs.height, a = r !== De && void 0 !== r, n = r - 2 * this.padding(); return !(this.wrap() !== Be) || a && t + i > n } _tryToAddEllipsisToLastLine() { var t = this.attrs.width, e = t !== De && void 0 !== t, i = t - 2 * this.padding(), r = this.ellipsis(), a = this.textArr[this.textArr.length - 1]; if (a && r) { if (e) this._getTextWidth(a.text + "…") < i || (a.text = a.text.slice(0, a.text.length - 3)); this.textArr.splice(this.textArr.length - 1, 1), this._addTextLine(a.text + "…") } } getStrokeScaleEnabled() { return !0 } } Ye.prototype._fillFunc = function (t) { t.fillText(this._partialText, this._partialTextX, this._partialTextY) }, Ye.prototype._strokeFunc = function (t) { t.setAttr("miterLimit", 2), t.strokeText(this._partialText, this._partialTextX, this._partialTextY) }, Ye.prototype.className = "Text", Ye.prototype._attrsAffectingSize = ["text", "fontSize", "padding", "wrap", "lineHeight", "letterSpacing"], r(Ye), w.overWriteSetter(Ye, "width", m()), w.overWriteSetter(Ye, "height", m()), w.addGetterSetter(Ye, "fontFamily", "Arial"), w.addGetterSetter(Ye, "fontSize", 12, p()), w.addGetterSetter(Ye, "fontStyle", Fe), w.addGetterSetter(Ye, "fontVariant", Fe), w.addGetterSetter(Ye, "padding", 0, p()), w.addGetterSetter(Ye, "align", Oe), w.addGetterSetter(Ye, "verticalAlign", "top"), w.addGetterSetter(Ye, "lineHeight", 1, p()), w.addGetterSetter(Ye, "wrap", "word"), w.addGetterSetter(Ye, "ellipsis", !1, x()), w.addGetterSetter(Ye, "letterSpacing", 0, p()), w.addGetterSetter(Ye, "text", "", _()), w.addGetterSetter(Ye, "textDecoration", ""); var Xe = "normal"; function je(t) { t.fillText(this.partialText, 0, 0) } function qe(t) { t.strokeText(this.partialText, 0, 0) } class Ue extends Bt { constructor(t) { super(t), this.dummyCanvas = g.createCanvasElement(), this.dataArray = [], this._readDataAttribute(), this.on("dataChange.konva", (function () { this._readDataAttribute(), this._setTextData() })), this.on("textChange.konva alignChange.konva letterSpacingChange.konva kerningFuncChange.konva fontSizeChange.konva fontFamilyChange.konva", this._setTextData), this._setTextData() } _getTextPathLength() { return ge.getPathLength(this.dataArray) } _getPointAtLength(t) { if (!this.attrs.data) return null; return t - 1 > this.pathLength ? null : ge.getPointAtLengthOfDataArray(t, this.dataArray) } _readDataAttribute() { this.dataArray = ge.parsePathData(this.attrs.data), this.pathLength = this._getTextPathLength() } _sceneFunc(t) { t.setAttr("font", this._getContextFont()), t.setAttr("textBaseline", this.textBaseline()), t.setAttr("textAlign", "left"), t.save(); var e = this.textDecoration(), i = this.fill(), r = this.fontSize(), a = this.glyphInfo; "underline" === e && t.beginPath(); for (var n = 0; n < a.length; n++) { t.save(); var s = a[n].p0; t.translate(s.x, s.y), t.rotate(a[n].rotation), this.partialText = a[n].text, t.fillStrokeShape(this), "underline" === e && (0 === n && t.moveTo(0, r / 2 + 1), t.lineTo(r, r / 2 + 1)), t.restore() } "underline" === e && (t.strokeStyle = i, t.lineWidth = r / 20, t.stroke()), t.restore() } _hitFunc(t) { t.beginPath(); var e = this.glyphInfo; if (e.length >= 1) { var i = e[0].p0; t.moveTo(i.x, i.y) } for (var r = 0; r < e.length; r++) { var a = e[r].p1; t.lineTo(a.x, a.y) } t.setAttr("lineWidth", this.fontSize()), t.setAttr("strokeStyle", this.colorKey), t.stroke() } getTextWidth() { return this.textWidth } getTextHeight() { return g.warn("text.getTextHeight() method is deprecated. Use text.height() - for full height and text.fontSize() - for one line height."), this.textHeight } setText(t) { return Ye.prototype.setText.call(this, t) } _getContextFont() { return Ye.prototype._getContextFont.call(this) } _getTextSize(t) { var e = this.dummyCanvas.getContext("2d"); e.save(), e.font = this._getContextFont(); var i = e.measureText(t); return e.restore(), { width: i.width, height: parseInt(`${this.fontSize()}`, 10) } } _setTextData() { const { width: t, height: e } = this._getTextSize(this.attrs.text); if (this.textWidth = t, this.textHeight = e, this.glyphInfo = [], !this.attrs.data) return null; const i = this.letterSpacing(), r = this.align(), a = this.kerningFunc(), n = Math.max(this.textWidth + ((this.attrs.text || "").length - 1) * i, 0); let s = 0; "center" === r && (s = Math.max(0, this.pathLength / 2 - n / 2)), "right" === r && (s = Math.max(0, this.pathLength - n)); const o = Re(this.text()); let h = s; for (var l = 0; l < o.length; l++) { const t = this._getPointAtLength(h); if (!t) return; let e = this._getTextSize(o[l]).width + i; if (" " === o[l] && "justify" === r) { const t = this.text().split(" ").length - 1; e += (this.pathLength - n) / t } const s = this._getPointAtLength(h + e); if (!s) return; const d = ge.getLineLength(t.x, t.y, s.x, s.y); let c = 0; if (a) try { c = a(o[l - 1], o[l]) * this.fontSize() } catch (t) { c = 0 } t.x += c, s.x += c, this.textWidth += c; const g = ge.getPointOnLine(c + d / 2, t.x, t.y, s.x, s.y), u = Math.atan2(s.y - t.y, s.x - t.x); this.glyphInfo.push({ transposeX: g.x, transposeY: g.y, text: o[l], rotation: u, p0: t, p1: s }), h += e } } getSelfRect() { if (!this.glyphInfo.length) return { x: 0, y: 0, width: 0, height: 0 }; var t = []; this.glyphInfo.forEach((function (e) { t.push(e.p0.x), t.push(e.p0.y), t.push(e.p1.x), t.push(e.p1.y) })); for (var e, i, r = t[0] || 0, a = t[0] || 0, n = t[1] || 0, s = t[1] || 0, o = 0; o < t.length / 2; o++)e = t[2 * o], i = t[2 * o + 1], r = Math.min(r, e), a = Math.max(a, e), n = Math.min(n, i), s = Math.max(s, i); var h = this.fontSize(); return { x: r - h / 2, y: n - h / 2, width: a - r + h, height: s - n + h } } destroy() { return g.releaseCanvas(this.dummyCanvas), super.destroy() } } Ue.prototype._fillFunc = je, Ue.prototype._strokeFunc = qe, Ue.prototype._fillFuncHit = je, Ue.prototype._strokeFuncHit = qe, Ue.prototype.className = "TextPath", Ue.prototype._attrsAffectingSize = ["text", "fontSize", "data"], r(Ue), w.addGetterSetter(Ue, "data"), w.addGetterSetter(Ue, "fontFamily", "Arial"), w.addGetterSetter(Ue, "fontSize", 12, p()), w.addGetterSetter(Ue, "fontStyle", Xe), w.addGetterSetter(Ue, "align", "left"), w.addGetterSetter(Ue, "letterSpacing", 0, p()), w.addGetterSetter(Ue, "textBaseline", "middle"), w.addGetterSetter(Ue, "fontVariant", Xe), w.addGetterSetter(Ue, "text", ""), w.addGetterSetter(Ue, "textDecoration", null), w.addGetterSetter(Ue, "kerningFunc", null); var Ke = "tr-konva", Ve = ["resizeEnabledChange", "rotateAnchorOffsetChange", "rotateEnabledChange", "enabledAnchorsChange", "anchorSizeChange", "borderEnabledChange", "borderStrokeChange", "borderStrokeWidthChange", "borderDashChange", "anchorStrokeChange", "anchorStrokeWidthChange", "anchorFillChange", "anchorCornerRadiusChange", "ignoreStrokeChange", "anchorStyleFuncChange"].map((t => t + `.${Ke}`)).join(" "), Qe = "nodesRect", Je = ["widthChange", "heightChange", "scaleXChange", "scaleYChange", "skewXChange", "skewYChange", "rotationChange", "offsetXChange", "offsetYChange", "transformsEnabledChange", "strokeWidthChange"], Ze = { "top-left": -45, "top-center": 0, "top-right": 45, "middle-right": -90, "middle-left": 90, "bottom-left": -135, "bottom-center": 180, "bottom-right": 135 }; const $e = "ontouchstart" in i._global; var ti = ["top-left", "top-center", "top-right", "middle-right", "middle-left", "bottom-left", "bottom-center", "bottom-right"]; function ei(t, e, i) { const r = i.x + (t.x - i.x) * Math.cos(e) - (t.y - i.y) * Math.sin(e), a = i.y + (t.x - i.x) * Math.sin(e) + (t.y - i.y) * Math.cos(e); return Object.assign(Object.assign({}, t), { rotation: t.rotation + e, x: r, y: a }) } function ii(t, e) { const i = function (t) { return { x: t.x + t.width / 2 * Math.cos(t.rotation) + t.height / 2 * Math.sin(-t.rotation), y: t.y + t.height / 2 * Math.cos(t.rotation) + t.width / 2 * Math.sin(t.rotation) } }(t); return ei(t, e, i) } class ri extends Xt { constructor(t) { super(t), this._transforming = !1, this._createElements(), this._handleMouseMove = this._handleMouseMove.bind(this), this._handleMouseUp = this._handleMouseUp.bind(this), this.update = this.update.bind(this), this.on(Ve, this.update), this.getNode() && this.update() } attachTo(t) { return this.setNode(t), this } setNode(t) { return g.warn("tr.setNode(shape), tr.node(shape) and tr.attachTo(shape) methods are deprecated. Please use tr.nodes(nodesArray) instead."), this.setNodes([t]) } getNode() { return this._nodes && this._nodes[0] } _getEventNamespace() { return Ke + this._id } setNodes(t = []) { this._nodes && this._nodes.length && this.detach(); const e = t.filter((t => !t.isAncestorOf(this) || (g.error("Konva.Transformer cannot be an a child of the node you are trying to attach"), !1))); return this._nodes = t = e, 1 === t.length && this.useSingleNodeRotation() ? this.rotation(t[0].getAbsoluteRotation()) : this.rotation(0), this._nodes.forEach((t => { const e = () => { 1 === this.nodes().length && this.useSingleNodeRotation() && this.rotation(this.nodes()[0].getAbsoluteRotation()), this._resetTransformCache(), this._transforming || this.isDragging() || this.update() }, i = t._attrsAffectingSize.map((t => t + "Change." + this._getEventNamespace())).join(" "); t.on(i, e), t.on(Je.map((t => t + `.${this._getEventNamespace()}`)).join(" "), e), t.on(`absoluteTransformChange.${this._getEventNamespace()}`, e), this._proxyDrag(t) })), this._resetTransformCache(), !!this.findOne(".top-left") && this.update(), this } _proxyDrag(t) { let e; t.on(`dragstart.${this._getEventNamespace()}`, (i => { e = t.getAbsolutePosition(), this.isDragging() || t === this.findOne(".back") || this.startDrag(i, !1) })), t.on(`dragmove.${this._getEventNamespace()}`, (i => { if (!e) return; const r = t.getAbsolutePosition(), a = r.x - e.x, n = r.y - e.y; this.nodes().forEach((e => { if (e === t) return; if (e.isDragging()) return; const r = e.getAbsolutePosition(); e.setAbsolutePosition({ x: r.x + a, y: r.y + n }), e.startDrag(i) })), e = null })) } getNodes() { return this._nodes || [] } getActiveAnchor() { return this._movingAnchorName } detach() { this._nodes && this._nodes.forEach((t => { t.off("." + this._getEventNamespace()) })), this._nodes = [], this._resetTransformCache() } _resetTransformCache() { this._clearCache(Qe), this._clearCache("transform"), this._clearSelfAndDescendantCache("absoluteTransform") } _getNodeRect() { return this._getCache(Qe, this.__getNodeRect) } __getNodeShape(t, e = this.rotation(), r) { var a = t.getClientRect({ skipTransform: !0, skipShadow: !0, skipStroke: this.ignoreStroke() }), n = t.getAbsoluteScale(r), s = t.getAbsolutePosition(r), o = a.x * n.x - t.offsetX() * n.x, h = a.y * n.y - t.offsetY() * n.y; const l = (i.getAngle(t.getAbsoluteRotation()) + 2 * Math.PI) % (2 * Math.PI); return ei({ x: s.x + o * Math.cos(l) + h * Math.sin(-l), y: s.y + h * Math.cos(l) + o * Math.sin(l), width: a.width * n.x, height: a.height * n.y, rotation: l }, -i.getAngle(e), { x: 0, y: 0 }) } __getNodeRect() { if (!this.getNode()) return { x: -1e8, y: -1e8, width: 0, height: 0, rotation: 0 }; const t = []; this.nodes().map((e => { const i = e.getClientRect({ skipTransform: !0, skipShadow: !0, skipStroke: this.ignoreStroke() }); var r = [{ x: i.x, y: i.y }, { x: i.x + i.width, y: i.y }, { x: i.x + i.width, y: i.y + i.height }, { x: i.x, y: i.y + i.height }], a = e.getAbsoluteTransform(); r.forEach((function (e) { var i = a.point(e); t.push(i) })) })); const e = new a; var r, n, s, o; e.rotate(-i.getAngle(this.rotation())), t.forEach((function (t) { var i = e.point(t); void 0 === r && (r = s = i.x, n = o = i.y), r = Math.min(r, i.x), n = Math.min(n, i.y), s = Math.max(s, i.x), o = Math.max(o, i.y) })), e.invert(); const h = e.point({ x: r, y: n }); return { x: h.x, y: h.y, width: s - r, height: o - n, rotation: i.getAngle(this.rotation()) } } getX() { return this._getNodeRect().x } getY() { return this._getNodeRect().y } getWidth() { return this._getNodeRect().width } getHeight() { return this._getNodeRect().height } _createElements() { this._createBack(), ti.forEach(function (t) { this._createAnchor(t) }.bind(this)), this._createAnchor("rotater") } _createAnchor(t) { var e = new Pe({ stroke: "rgb(0, 161, 255)", fill: "white", strokeWidth: 1, name: t + " _anchor", dragDistance: 0, draggable: !0, hitStrokeWidth: $e ? 10 : "auto" }), r = this; e.on("mousedown touchstart", (function (t) { r._handleMouseDown(t) })), e.on("dragstart", (t => { e.stopDrag(), t.cancelBubble = !0 })), e.on("dragend", (t => { t.cancelBubble = !0 })), e.on("mouseenter", (() => { var r = i.getAngle(this.rotation()), a = function (t, e) { if ("rotater" === t) return "crosshair"; e += g.degToRad(Ze[t] || 0); var i = (g.radToDeg(e) % 360 + 360) % 360; return g._inRange(i, 337.5, 360) || g._inRange(i, 0, 22.5) ? "ns-resize" : g._inRange(i, 22.5, 67.5) ? "nesw-resize" : g._inRange(i, 67.5, 112.5) ? "ew-resize" : g._inRange(i, 112.5, 157.5) ? "nwse-resize" : g._inRange(i, 157.5, 202.5) ? "ns-resize" : g._inRange(i, 202.5, 247.5) ? "nesw-resize" : g._inRange(i, 247.5, 292.5) ? "ew-resize" : g._inRange(i, 292.5, 337.5) ? "nwse-resize" : (g.error("Transformer has unknown angle for cursor detection: " + i), "pointer") }(t, r); e.getStage().content && (e.getStage().content.style.cursor = a), this._cursorChange = !0 })), e.on("mouseout", (() => { e.getStage().content && (e.getStage().content.style.cursor = ""), this._cursorChange = !1 })), this.add(e) } _createBack() { var t = new Bt({ name: "back", width: 0, height: 0, draggable: !0, sceneFunc(t) { var e = this.getParent(), i = e.padding(); t.beginPath(), t.rect(-i, -i, this.width() + 2 * i, this.height() + 2 * i), t.moveTo(this.width() / 2, -i), e.rotateEnabled() && t.lineTo(this.width() / 2, -e.rotateAnchorOffset() * g._sign(this.height()) - i), t.fillStrokeShape(this) }, hitFunc: (t, e) => { if (this.shouldOverdrawWholeArea()) { var i = this.padding(); t.beginPath(), t.rect(-i, -i, e.width() + 2 * i, e.height() + 2 * i), t.fillStrokeShape(e) } } }); this.add(t), this._proxyDrag(t), t.on("dragstart", (t => { t.cancelBubble = !0 })), t.on("dragmove", (t => { t.cancelBubble = !0 })), t.on("dragend", (t => { t.cancelBubble = !0 })), this.on("dragmove", (t => { this.update() })) } _handleMouseDown(t) { this._movingAnchorName = t.target.name().split(" ")[0]; var e = this._getNodeRect(), i = e.width, r = e.height, a = Math.sqrt(Math.pow(i, 2) + Math.pow(r, 2)); this.sin = Math.abs(r / a), this.cos = Math.abs(i / a), "undefined" != typeof window && (window.addEventListener("mousemove", this._handleMouseMove), window.addEventListener("touchmove", this._handleMouseMove), window.addEventListener("mouseup", this._handleMouseUp, !0), window.addEventListener("touchend", this._handleMouseUp, !0)), this._transforming = !0; var n = t.target.getAbsolutePosition(), s = t.target.getStage().getPointerPosition(); this._anchorDragOffset = { x: s.x - n.x, y: s.y - n.y }, this._fire("transformstart", { evt: t.evt, target: this.getNode() }), this._nodes.forEach((e => { e._fire("transformstart", { evt: t.evt, target: e }) })) } _handleMouseMove(t) { var e, r, a, n = this.findOne("." + this._movingAnchorName), s = n.getStage(); s.setPointersPositions(t); const o = s.getPointerPosition(); let h = { x: o.x - this._anchorDragOffset.x, y: o.y - this._anchorDragOffset.y }; const l = n.getAbsolutePosition(); this.anchorDragBoundFunc() && (h = this.anchorDragBoundFunc()(l, h, t)), n.setAbsolutePosition(h); const d = n.getAbsolutePosition(); if (l.x !== d.x || l.y !== d.y) if ("rotater" !== this._movingAnchorName) { var c, g = this.shiftBehavior(); c = "inverted" === g ? this.keepRatio() && !t.shiftKey : "none" === g ? this.keepRatio() : this.keepRatio() || t.shiftKey; var u = this.centeredScaling() || t.altKey; if ("top-left" === this._movingAnchorName) { if (c) { var f = u ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".bottom-right").x(), y: this.findOne(".bottom-right").y() }; a = Math.sqrt(Math.pow(f.x - n.x(), 2) + Math.pow(f.y - n.y(), 2)); var p = this.findOne(".top-left").x() > f.x ? -1 : 1, v = this.findOne(".top-left").y() > f.y ? -1 : 1; e = a * this.cos * p, r = a * this.sin * v, this.findOne(".top-left").x(f.x - e), this.findOne(".top-left").y(f.y - r) } } else if ("top-center" === this._movingAnchorName) this.findOne(".top-left").y(n.y()); else if ("top-right" === this._movingAnchorName) { if (c) { f = u ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".bottom-left").x(), y: this.findOne(".bottom-left").y() }; a = Math.sqrt(Math.pow(n.x() - f.x, 2) + Math.pow(f.y - n.y(), 2)); p = this.findOne(".top-right").x() < f.x ? -1 : 1, v = this.findOne(".top-right").y() > f.y ? -1 : 1; e = a * this.cos * p, r = a * this.sin * v, this.findOne(".top-right").x(f.x + e), this.findOne(".top-right").y(f.y - r) } var m = n.position(); this.findOne(".top-left").y(m.y), this.findOne(".bottom-right").x(m.x) } else if ("middle-left" === this._movingAnchorName) this.findOne(".top-left").x(n.x()); else if ("middle-right" === this._movingAnchorName) this.findOne(".bottom-right").x(n.x()); else if ("bottom-left" === this._movingAnchorName) { if (c) { f = u ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".top-right").x(), y: this.findOne(".top-right").y() }; a = Math.sqrt(Math.pow(f.x - n.x(), 2) + Math.pow(n.y() - f.y, 2)); p = f.x < n.x() ? -1 : 1, v = n.y() < f.y ? -1 : 1; e = a * this.cos * p, r = a * this.sin * v, n.x(f.x - e), n.y(f.y + r) } m = n.position(), this.findOne(".top-left").x(m.x), this.findOne(".bottom-right").y(m.y) } else if ("bottom-center" === this._movingAnchorName) this.findOne(".bottom-right").y(n.y()); else if ("bottom-right" === this._movingAnchorName) { if (c) { f = u ? { x: this.width() / 2, y: this.height() / 2 } : { x: this.findOne(".top-left").x(), y: this.findOne(".top-left").y() }; a = Math.sqrt(Math.pow(n.x() - f.x, 2) + Math.pow(n.y() - f.y, 2)); p = this.findOne(".bottom-right").x() < f.x ? -1 : 1, v = this.findOne(".bottom-right").y() < f.y ? -1 : 1; e = a * this.cos * p, r = a * this.sin * v, this.findOne(".bottom-right").x(f.x + e), this.findOne(".bottom-right").y(f.y + r) } } else console.error(new Error("Wrong position argument of selection resizer: " + this._movingAnchorName)); if (u = this.centeredScaling() || t.altKey) { var _ = this.findOne(".top-left"), y = this.findOne(".bottom-right"), x = _.x(), b = _.y(), S = this.getWidth() - y.x(), w = this.getHeight() - y.y(); y.move({ x: -x, y: -b }), _.move({ x: S, y: w }) } var C = this.findOne(".top-left").getAbsolutePosition(); e = C.x, r = C.y; var P = this.findOne(".bottom-right").x() - this.findOne(".top-left").x(), k = this.findOne(".bottom-right").y() - this.findOne(".top-left").y(); this._fitNodesInto({ x: e, y: r, width: P, height: k, rotation: i.getAngle(this.rotation()) }, t) } else { var T = this._getNodeRect(); e = n.x() - T.width / 2, r = -n.y() + T.height / 2; let a = Math.atan2(-r, e) + Math.PI / 2; T.height < 0 && (a -= Math.PI); const s = i.getAngle(this.rotation()) + a, o = i.getAngle(this.rotationSnapTolerance()), h = ii(T, function (t, e, r) { let a = e; for (let n = 0; n < t.length; n++) { const s = i.getAngle(t[n]), o = Math.abs(s - e) % (2 * Math.PI); Math.min(o, 2 * Math.PI - o) < r && (a = s) } return a }(this.rotationSnaps(), s, o) - T.rotation); this._fitNodesInto(h, t) } } _handleMouseUp(t) { this._removeEvents(t) } getAbsoluteTransform() { return this.getTransform() } _removeEvents(t) { if (this._transforming) { this._transforming = !1, "undefined" != typeof window && (window.removeEventListener("mousemove", this._handleMouseMove), window.removeEventListener("touchmove", this._handleMouseMove), window.removeEventListener("mouseup", this._handleMouseUp, !0), window.removeEventListener("touchend", this._handleMouseUp, !0)); var e = this.getNode(); this._fire("transformend", { evt: t, target: e }), e && this._nodes.forEach((e => { e._fire("transformend", { evt: t, target: e }) })), this._movingAnchorName = null } } _fitNodesInto(t, e) { var r = this._getNodeRect(); if (g._inRange(t.width, 2 * -this.padding() - 1, 1)) return void this.update(); if (g._inRange(t.height, 2 * -this.padding() - 1, 1)) return void this.update(); const n = this.flipEnabled(); var s = new a; if (s.rotate(i.getAngle(this.rotation())), this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("left") >= 0) { const e = s.point({ x: 2 * -this.padding(), y: 0 }); if (t.x += e.x, t.y += e.y, t.width += 2 * this.padding(), this._movingAnchorName = this._movingAnchorName.replace("left", "right"), this._anchorDragOffset.x -= e.x, this._anchorDragOffset.y -= e.y, !n) return void this.update() } else if (this._movingAnchorName && t.width < 0 && this._movingAnchorName.indexOf("right") >= 0) { const e = s.point({ x: 2 * this.padding(), y: 0 }); if (this._movingAnchorName = this._movingAnchorName.replace("right", "left"), this._anchorDragOffset.x -= e.x, this._anchorDragOffset.y -= e.y, t.width += 2 * this.padding(), !n) return void this.update() } if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("top") >= 0) { const e = s.point({ x: 0, y: 2 * -this.padding() }); if (t.x += e.x, t.y += e.y, this._movingAnchorName = this._movingAnchorName.replace("top", "bottom"), this._anchorDragOffset.x -= e.x, this._anchorDragOffset.y -= e.y, t.height += 2 * this.padding(), !n) return void this.update() } else if (this._movingAnchorName && t.height < 0 && this._movingAnchorName.indexOf("bottom") >= 0) { const e = s.point({ x: 0, y: 2 * this.padding() }); if (this._movingAnchorName = this._movingAnchorName.replace("bottom", "top"), this._anchorDragOffset.x -= e.x, this._anchorDragOffset.y -= e.y, t.height += 2 * this.padding(), !n) return void this.update() } if (this.boundBoxFunc()) { const e = this.boundBoxFunc()(r, t); e ? t = e : g.warn("boundBoxFunc returned falsy. You should return new bound rect from it!") } const o = 1e7, h = new a; h.translate(r.x, r.y), h.rotate(r.rotation), h.scale(r.width / o, r.height / o); const l = new a; l.translate(t.x, t.y), l.rotate(t.rotation), l.scale(t.width / o, t.height / o); const d = l.multiply(h.invert()); this._nodes.forEach((t => { var i; const r = t.getParent().getAbsoluteTransform(), n = t.getTransform().copy(); n.translate(t.offsetX(), t.offsetY()); const s = new a; s.multiply(r.copy().invert()).multiply(d).multiply(r).multiply(n); const o = s.decompose(); t.setAttrs(o), this._fire("transform", { evt: e, target: t }), t._fire("transform", { evt: e, target: t }), null === (i = t.getLayer()) || void 0 === i || i.batchDraw() })), this.rotation(g._getRotation(t.rotation)), this._resetTransformCache(), this.update(), this.getLayer().batchDraw() } forceUpdate() { this._resetTransformCache(), this.update() } _batchChangeChild(t, e) { this.findOne(t).setAttrs(e) } update() { var t, e = this._getNodeRect(); this.rotation(g._getRotation(e.rotation)); var i = e.width, r = e.height, a = this.enabledAnchors(), n = this.resizeEnabled(), s = this.padding(), o = this.anchorSize(); const h = this.find("._anchor"); h.forEach((t => { t.setAttrs({ width: o, height: o, offsetX: o / 2, offsetY: o / 2, stroke: this.anchorStroke(), strokeWidth: this.anchorStrokeWidth(), fill: this.anchorFill(), cornerRadius: this.anchorCornerRadius() }) })), this._batchChangeChild(".top-left", { x: 0, y: 0, offsetX: o / 2 + s, offsetY: o / 2 + s, visible: n && a.indexOf("top-left") >= 0 }), this._batchChangeChild(".top-center", { x: i / 2, y: 0, offsetY: o / 2 + s, visible: n && a.indexOf("top-center") >= 0 }), this._batchChangeChild(".top-right", { x: i, y: 0, offsetX: o / 2 - s, offsetY: o / 2 + s, visible: n && a.indexOf("top-right") >= 0 }), this._batchChangeChild(".middle-left", { x: 0, y: r / 2, offsetX: o / 2 + s, visible: n && a.indexOf("middle-left") >= 0 }), this._batchChangeChild(".middle-right", { x: i, y: r / 2, offsetX: o / 2 - s, visible: n && a.indexOf("middle-right") >= 0 }), this._batchChangeChild(".bottom-left", { x: 0, y: r, offsetX: o / 2 + s, offsetY: o / 2 - s, visible: n && a.indexOf("bottom-left") >= 0 }), this._batchChangeChild(".bottom-center", { x: i / 2, y: r, offsetY: o / 2 - s, visible: n && a.indexOf("bottom-center") >= 0 }), this._batchChangeChild(".bottom-right", { x: i, y: r, offsetX: o / 2 - s, offsetY: o / 2 - s, visible: n && a.indexOf("bottom-right") >= 0 }), this._batchChangeChild(".rotater", { x: i / 2, y: -this.rotateAnchorOffset() * g._sign(r) - s, visible: this.rotateEnabled() }), this._batchChangeChild(".back", { width: i, height: r, visible: this.borderEnabled(), stroke: this.borderStroke(), strokeWidth: this.borderStrokeWidth(), dash: this.borderDash(), x: 0, y: 0 }); const l = this.anchorStyleFunc(); l && h.forEach((t => { l(t) })), null === (t = this.getLayer()) || void 0 === t || t.batchDraw() } isTransforming() { return this._transforming } stopTransform() { if (this._transforming) { this._removeEvents(); var t = this.findOne("." + this._movingAnchorName); t && t.stopDrag() } } destroy() { return this.getStage() && this._cursorChange && this.getStage().content && (this.getStage().content.style.cursor = ""), Xt.prototype.destroy.call(this), this.detach(), this._removeEvents(), this } toObject() { return K.prototype.toObject.call(this) } clone(t) { return K.prototype.clone.call(this, t) } getClientRect() { return this.nodes().length > 0 ? super.getClientRect() : { x: 0, y: 0, width: 0, height: 0 } } } ri.prototype.className = "Transformer", r(ri), w.addGetterSetter(ri, "enabledAnchors", ti, (function (t) { return t instanceof Array || g.warn("enabledAnchors value should be an array"), t instanceof Array && t.forEach((function (t) { -1 === ti.indexOf(t) && g.warn("Unknown anchor name: " + t + ". Available names are: " + ti.join(", ")) })), t || [] })), w.addGetterSetter(ri, "flipEnabled", !0, x()), w.addGetterSetter(ri, "resizeEnabled", !0), w.addGetterSetter(ri, "anchorSize", 10, p()), w.addGetterSetter(ri, "rotateEnabled", !0), w.addGetterSetter(ri, "rotationSnaps", []), w.addGetterSetter(ri, "rotateAnchorOffset", 50, p()), w.addGetterSetter(ri, "rotationSnapTolerance", 5, p()), w.addGetterSetter(ri, "borderEnabled", !0), w.addGetterSetter(ri, "anchorStroke", "rgb(0, 161, 255)"), w.addGetterSetter(ri, "anchorStrokeWidth", 1, p()), w.addGetterSetter(ri, "anchorFill", "white"), w.addGetterSetter(ri, "anchorCornerRadius", 0, p()), w.addGetterSetter(ri, "borderStroke", "rgb(0, 161, 255)"), w.addGetterSetter(ri, "borderStrokeWidth", 1, p()), w.addGetterSetter(ri, "borderDash"), w.addGetterSetter(ri, "keepRatio", !0), w.addGetterSetter(ri, "shiftBehavior", "default"), w.addGetterSetter(ri, "centeredScaling", !1), w.addGetterSetter(ri, "ignoreStroke", !1), w.addGetterSetter(ri, "padding", 0, p()), w.addGetterSetter(ri, "node"), w.addGetterSetter(ri, "nodes"), w.addGetterSetter(ri, "boundBoxFunc"), w.addGetterSetter(ri, "anchorDragBoundFunc"), w.addGetterSetter(ri, "anchorStyleFunc"), w.addGetterSetter(ri, "shouldOverdrawWholeArea", !1), w.addGetterSetter(ri, "useSingleNodeRotation", !0), w.backCompat(ri, { lineEnabled: "borderEnabled", rotateHandlerOffset: "rotateAnchorOffset", enabledHandlers: "enabledAnchors" }); class ai extends Bt { _sceneFunc(t) { t.beginPath(), t.arc(0, 0, this.radius(), 0, i.getAngle(this.angle()), this.clockwise()), t.lineTo(0, 0), t.closePath(), t.fillStrokeShape(this) } getWidth() { return 2 * this.radius() } getHeight() { return 2 * this.radius() } setWidth(t) { this.radius(t / 2) } setHeight(t) { this.radius(t / 2) } } function ni() { this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null } ai.prototype.className = "Wedge", ai.prototype._centroid = !0, ai.prototype._attrsAffectingSize = ["radius"], r(ai), w.addGetterSetter(ai, "radius", 0, p()), w.addGetterSetter(ai, "angle", 0, p()), w.addGetterSetter(ai, "clockwise", !1), w.backCompat(ai, { angleDeg: "angle", getAngleDeg: "getAngle", setAngleDeg: "setAngle" }); var si = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], oi = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24]; w.addGetterSetter(K, "blurRadius", 0, p(), w.afterSetFilter); w.addGetterSetter(K, "brightness", 0, p(), w.afterSetFilter); w.addGetterSetter(K, "contrast", 0, p(), w.afterSetFilter); function hi(t, e, i, r, a) { var n = i - e, s = a - r; return 0 === n ? r + s / 2 : 0 === s ? r : s * ((t - e) / n) + r } w.addGetterSetter(K, "embossStrength", .5, p(), w.afterSetFilter), w.addGetterSetter(K, "embossWhiteLevel", .5, p(), w.afterSetFilter), w.addGetterSetter(K, "embossDirection", "top-left", null, w.afterSetFilter), w.addGetterSetter(K, "embossBlend", !1, null, w.afterSetFilter); w.addGetterSetter(K, "enhance", 0, p(), w.afterSetFilter); w.addGetterSetter(K, "hue", 0, p(), w.afterSetFilter), w.addGetterSetter(K, "saturation", 0, p(), w.afterSetFilter), w.addGetterSetter(K, "luminance", 0, p(), w.afterSetFilter); w.addGetterSetter(K, "hue", 0, p(), w.afterSetFilter), w.addGetterSetter(K, "saturation", 0, p(), w.afterSetFilter), w.addGetterSetter(K, "value", 0, p(), w.afterSetFilter); function li(t, e, i) { var r = 4 * (i * t.width + e), a = []; return a.push(t.data[r++], t.data[r++], t.data[r++], t.data[r++]), a } function di(t, e) { return Math.sqrt(Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2) + Math.pow(t[2] - e[2], 2)) } w.addGetterSetter(K, "kaleidoscopePower", 2, p(), w.afterSetFilter), w.addGetterSetter(K, "kaleidoscopeAngle", 0, p(), w.afterSetFilter); w.addGetterSetter(K, "threshold", 0, p(), w.afterSetFilter); w.addGetterSetter(K, "noise", .2, p(), w.afterSetFilter); w.addGetterSetter(K, "pixelSize", 8, p(), w.afterSetFilter); w.addGetterSetter(K, "levels", .5, p(), w.afterSetFilter); w.addGetterSetter(K, "red", 0, (function (t) { return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t) })), w.addGetterSetter(K, "green", 0, (function (t) { return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t) })), w.addGetterSetter(K, "blue", 0, f, w.afterSetFilter); w.addGetterSetter(K, "red", 0, (function (t) { return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t) })), w.addGetterSetter(K, "green", 0, (function (t) { return this._filterUpToDate = !1, t > 255 ? 255 : t < 0 ? 0 : Math.round(t) })), w.addGetterSetter(K, "blue", 0, f, w.afterSetFilter), w.addGetterSetter(K, "alpha", 1, (function (t) { return this._filterUpToDate = !1, t > 1 ? 1 : t < 0 ? 0 : t })); w.addGetterSetter(K, "threshold", .5, p(), w.afterSetFilter); return $t.Util._assign($t, { Arc: te, Arrow: ue, Circle: fe, Ellipse: pe, Image: ve, Label: we, Tag: Ce, Line: re, Path: ge, Rect: Pe, RegularPolygon: ke, Ring: Ae, Sprite: Me, Star: Ge, Text: Ye, TextPath: Ue, Transformer: ri, Wedge: ai, Filters: { Blur: function (t) { var e = Math.round(this.blurRadius()); e > 0 && function (t, e) { var i, r, a, n, s, o, h, l, d, c, g, u, f, p, v, m, _, y, x, b, S, w, C, P, k = t.data, T = t.width, A = t.height, M = e + e + 1, G = T - 1, R = A - 1, E = e + 1, D = E * (E + 1) / 2, L = new ni, O = null, I = L, F = null, N = null, B = si[e], H = oi[e]; for (a = 1; a < M; a++)I = I.next = new ni, a === E && (O = I); for (I.next = L, h = o = 0, r = 0; r < A; r++) { for (m = _ = y = x = l = d = c = g = 0, u = E * (b = k[o]), f = E * (S = k[o + 1]), p = E * (w = k[o + 2]), v = E * (C = k[o + 3]), l += D * b, d += D * S, c += D * w, g += D * C, I = L, a = 0; a < E; a++)I.r = b, I.g = S, I.b = w, I.a = C, I = I.next; for (a = 1; a < E; a++)n = o + ((G < a ? G : a) << 2), l += (I.r = b = k[n]) * (P = E - a), d += (I.g = S = k[n + 1]) * P, c += (I.b = w = k[n + 2]) * P, g += (I.a = C = k[n + 3]) * P, m += b, _ += S, y += w, x += C, I = I.next; for (F = L, N = O, i = 0; i < T; i++)k[o + 3] = C = g * B >> H, 0 !== C ? (C = 255 / C, k[o] = (l * B >> H) * C, k[o + 1] = (d * B >> H) * C, k[o + 2] = (c * B >> H) * C) : k[o] = k[o + 1] = k[o + 2] = 0, l -= u, d -= f, c -= p, g -= v, u -= F.r, f -= F.g, p -= F.b, v -= F.a, n = h + ((n = i + e + 1) < G ? n : G) << 2, l += m += F.r = k[n], d += _ += F.g = k[n + 1], c += y += F.b = k[n + 2], g += x += F.a = k[n + 3], F = F.next, u += b = N.r, f += S = N.g, p += w = N.b, v += C = N.a, m -= b, _ -= S, y -= w, x -= C, N = N.next, o += 4; h += T } for (i = 0; i < T; i++) { for (_ = y = x = m = d = c = g = l = 0, u = E * (b = k[o = i << 2]), f = E * (S = k[o + 1]), p = E * (w = k[o + 2]), v = E * (C = k[o + 3]), l += D * b, d += D * S, c += D * w, g += D * C, I = L, a = 0; a < E; a++)I.r = b, I.g = S, I.b = w, I.a = C, I = I.next; for (s = T, a = 1; a <= e; a++)o = s + i << 2, l += (I.r = b = k[o]) * (P = E - a), d += (I.g = S = k[o + 1]) * P, c += (I.b = w = k[o + 2]) * P, g += (I.a = C = k[o + 3]) * P, m += b, _ += S, y += w, x += C, I = I.next, a < R && (s += T); for (o = i, F = L, N = O, r = 0; r < A; r++)k[3 + (n = o << 2)] = C = g * B >> H, C > 0 ? (C = 255 / C, k[n] = (l * B >> H) * C, k[n + 1] = (d * B >> H) * C, k[n + 2] = (c * B >> H) * C) : k[n] = k[n + 1] = k[n + 2] = 0, l -= u, d -= f, c -= p, g -= v, u -= F.r, f -= F.g, p -= F.b, v -= F.a, n = i + ((n = r + E) < R ? n : R) * T << 2, l += m += F.r = k[n], d += _ += F.g = k[n + 1], c += y += F.b = k[n + 2], g += x += F.a = k[n + 3], F = F.next, u += b = N.r, f += S = N.g, p += w = N.b, v += C = N.a, m -= b, _ -= S, y -= w, x -= C, N = N.next, o += T } }(t, e) }, Brighten: function (t) { var e, i = 255 * this.brightness(), r = t.data, a = r.length; for (e = 0; e < a; e += 4)r[e] += i, r[e + 1] += i, r[e + 2] += i }, Contrast: function (t) { var e, i = Math.pow((this.contrast() + 100) / 100, 2), r = t.data, a = r.length, n = 150, s = 150, o = 150; for (e = 0; e < a; e += 4)n = r[e], s = r[e + 1], o = r[e + 2], n /= 255, n -= .5, n *= i, n += .5, s /= 255, s -= .5, s *= i, s += .5, o /= 255, o -= .5, o *= i, o += .5, n = (n *= 255) < 0 ? 0 : n > 255 ? 255 : n, s = (s *= 255) < 0 ? 0 : s > 255 ? 255 : s, o = (o *= 255) < 0 ? 0 : o > 255 ? 255 : o, r[e] = n, r[e + 1] = s, r[e + 2] = o }, Emboss: function (t) { var e = 10 * this.embossStrength(), i = 255 * this.embossWhiteLevel(), r = this.embossDirection(), a = this.embossBlend(), n = 0, s = 0, o = t.data, h = t.width, l = t.height, d = 4 * h, c = l; switch (r) { case "top-left": n = -1, s = -1; break; case "top": n = -1, s = 0; break; case "top-right": n = -1, s = 1; break; case "right": n = 0, s = 1; break; case "bottom-right": n = 1, s = 1; break; case "bottom": n = 1, s = 0; break; case "bottom-left": n = 1, s = -1; break; case "left": n = 0, s = -1; break; default: g.error("Unknown emboss direction: " + r) }do { var u = (c - 1) * d, f = n; c + f < 1 && (f = 0), c + f > l && (f = 0); var p = (c - 1 + f) * h * 4, v = h; do { var m = u + 4 * (v - 1), _ = s; v + _ < 1 && (_ = 0), v + _ > h && (_ = 0); var y = p + 4 * (v - 1 + _), x = o[m] - o[y], b = o[m + 1] - o[y + 1], S = o[m + 2] - o[y + 2], w = x, C = w > 0 ? w : -w; if ((b > 0 ? b : -b) > C && (w = b), (S > 0 ? S : -S) > C && (w = S), w *= e, a) { var P = o[m] + w, k = o[m + 1] + w, T = o[m + 2] + w; o[m] = P > 255 ? 255 : P < 0 ? 0 : P, o[m + 1] = k > 255 ? 255 : k < 0 ? 0 : k, o[m + 2] = T > 255 ? 255 : T < 0 ? 0 : T } else { var A = i - w; A < 0 ? A = 0 : A > 255 && (A = 255), o[m] = o[m + 1] = o[m + 2] = A } } while (--v) } while (--c) }, Enhance: function (t) { var e, i, r, a, n = t.data, s = n.length, o = n[0], h = o, l = n[1], d = l, c = n[2], g = c, u = this.enhance(); if (0 !== u) { for (a = 0; a < s; a += 4)(e = n[a + 0]) < o ? o = e : e > h && (h = e), (i = n[a + 1]) < l ? l = i : i > d && (d = i), (r = n[a + 2]) < c ? c = r : r > g && (g = r); var f, p, v, m, _, y, x, b, S; for (h === o && (h = 255, o = 0), d === l && (d = 255, l = 0), g === c && (g = 255, c = 0), u > 0 ? (p = h + u * (255 - h), v = o - u * (o - 0), _ = d + u * (255 - d), y = l - u * (l - 0), b = g + u * (255 - g), S = c - u * (c - 0)) : (p = h + u * (h - (f = .5 * (h + o))), v = o + u * (o - f), _ = d + u * (d - (m = .5 * (d + l))), y = l + u * (l - m), b = g + u * (g - (x = .5 * (g + c))), S = c + u * (c - x)), a = 0; a < s; a += 4)n[a + 0] = hi(n[a + 0], o, h, v, p), n[a + 1] = hi(n[a + 1], l, d, y, _), n[a + 2] = hi(n[a + 2], c, g, S, b) } }, Grayscale: function (t) { var e, i, r = t.data, a = r.length; for (e = 0; e < a; e += 4)i = .34 * r[e] + .5 * r[e + 1] + .16 * r[e + 2], r[e] = i, r[e + 1] = i, r[e + 2] = i }, HSL: function (t) { var e, i, r, a, n, s = t.data, o = s.length, h = Math.pow(2, this.saturation()), l = Math.abs(this.hue() + 360) % 360, d = 127 * this.luminance(), c = 1 * h * Math.cos(l * Math.PI / 180), g = 1 * h * Math.sin(l * Math.PI / 180), u = .299 + .701 * c + .167 * g, f = .587 - .587 * c + .33 * g, p = .114 - .114 * c - .497 * g, v = .299 - .299 * c - .328 * g, m = .587 + .413 * c + .035 * g, _ = .114 - .114 * c + .293 * g, y = .299 - .3 * c + 1.25 * g, x = .587 - .586 * c - 1.05 * g, b = .114 + .886 * c - .2 * g; for (e = 0; e < o; e += 4)i = s[e + 0], r = s[e + 1], a = s[e + 2], n = s[e + 3], s[e + 0] = u * i + f * r + p * a + d, s[e + 1] = v * i + m * r + _ * a + d, s[e + 2] = y * i + x * r + b * a + d, s[e + 3] = n }, HSV: function (t) { var e, i, r, a, n, s = t.data, o = s.length, h = Math.pow(2, this.value()), l = Math.pow(2, this.saturation()), d = Math.abs(this.hue() + 360) % 360, c = h * l * Math.cos(d * Math.PI / 180), g = h * l * Math.sin(d * Math.PI / 180), u = .299 * h + .701 * c + .167 * g, f = .587 * h - .587 * c + .33 * g, p = .114 * h - .114 * c - .497 * g, v = .299 * h - .299 * c - .328 * g, m = .587 * h + .413 * c + .035 * g, _ = .114 * h - .114 * c + .293 * g, y = .299 * h - .3 * c + 1.25 * g, x = .587 * h - .586 * c - 1.05 * g, b = .114 * h + .886 * c - .2 * g; for (e = 0; e < o; e += 4)i = s[e + 0], r = s[e + 1], a = s[e + 2], n = s[e + 3], s[e + 0] = u * i + f * r + p * a, s[e + 1] = v * i + m * r + _ * a, s[e + 2] = y * i + x * r + b * a, s[e + 3] = n }, Invert: function (t) { var e, i = t.data, r = i.length; for (e = 0; e < r; e += 4)i[e] = 255 - i[e], i[e + 1] = 255 - i[e + 1], i[e + 2] = 255 - i[e + 2] }, Kaleidoscope: function (t) { var e, i, r, a, n, s, o, h, l, d = t.width, c = t.height, u = Math.round(this.kaleidoscopePower()), f = Math.round(this.kaleidoscopeAngle()), p = Math.floor(d * (f % 360) / 360); if (!(u < 1)) { var v = g.createCanvasElement(); v.width = d, v.height = c; var m = v.getContext("2d").getImageData(0, 0, d, c); g.releaseCanvas(v), function (t, e, i) { var r, a, n, s, o = t.data, h = e.data, l = t.width, d = t.height, c = i.polarCenterX || l / 2, g = i.polarCenterY || d / 2, u = 0, f = 0, p = 0, v = 0, m = Math.sqrt(c * c + g * g); a = l - c, n = d - g, m = (s = Math.sqrt(a * a + n * n)) > m ? s : m; var _, y, x, b, S = d, w = l, C = 360 / w * Math.PI / 180; for (y = 0; y < w; y += 1)for (x = Math.sin(y * C), b = Math.cos(y * C), _ = 0; _ < S; _ += 1)a = Math.floor(c + m * _ / S * b), u = o[0 + (r = 4 * ((n = Math.floor(g + m * _ / S * x)) * l + a))], f = o[r + 1], p = o[r + 2], v = o[r + 3], h[0 + (r = 4 * (y + _ * l))] = u, h[r + 1] = f, h[r + 2] = p, h[r + 3] = v }(t, m, { polarCenterX: d / 2, polarCenterY: c / 2 }); for (var _ = d / Math.pow(2, u); _ <= 8;)_ *= 2, u -= 1; var y = _ = Math.ceil(_), x = 0, b = y, S = 1; for (p + _ > d && (x = y, b = 0, S = -1), i = 0; i < c; i += 1)for (e = x; e !== b; e += S)h = 4 * (d * i + Math.round(e + p) % d), a = m.data[h + 0], n = m.data[h + 1], s = m.data[h + 2], o = m.data[h + 3], l = 4 * (d * i + e), m.data[l + 0] = a, m.data[l + 1] = n, m.data[l + 2] = s, m.data[l + 3] = o; for (i = 0; i < c; i += 1)for (y = Math.floor(_), r = 0; r < u; r += 1) { for (e = 0; e < y + 1; e += 1)h = 4 * (d * i + e), a = m.data[h + 0], n = m.data[h + 1], s = m.data[h + 2], o = m.data[h + 3], l = 4 * (d * i + 2 * y - e - 1), m.data[l + 0] = a, m.data[l + 1] = n, m.data[l + 2] = s, m.data[l + 3] = o; y *= 2 } !function (t, e, i) { var r, a, n, s, o, h, l = t.data, d = e.data, c = t.width, g = t.height, u = i.polarCenterX || c / 2, f = i.polarCenterY || g / 2, p = 0, v = 0, m = 0, _ = 0, y = Math.sqrt(u * u + f * f); a = c - u, n = g - f, y = (h = Math.sqrt(a * a + n * n)) > y ? h : y; var x, b, S, w = g, C = c, P = i.polarRotation || 0; for (a = 0; a < c; a += 1)for (n = 0; n < g; n += 1)s = a - u, o = n - f, x = Math.sqrt(s * s + o * o) * w / y, b = (b = (180 * Math.atan2(o, s) / Math.PI + 360 + P) % 360) * C / 360, S = Math.floor(b), p = l[0 + (r = 4 * (Math.floor(x) * c + S))], v = l[r + 1], m = l[r + 2], _ = l[r + 3], d[0 + (r = 4 * (n * c + a))] = p, d[r + 1] = v, d[r + 2] = m, d[r + 3] = _ }(m, t, { polarRotation: 0 }) } }, Mask: function (t) { var e = function (t, e) { var i = li(t, 0, 0), r = li(t, t.width - 1, 0), a = li(t, 0, t.height - 1), n = li(t, t.width - 1, t.height - 1), s = e || 10; if (di(i, r) < s && di(r, n) < s && di(n, a) < s && di(a, i) < s) { for (var o = function (t) { for (var e = [0, 0, 0], i = 0; i < t.length; i++)e[0] += t[i][0], e[1] += t[i][1], e[2] += t[i][2]; return e[0] /= t.length, e[1] /= t.length, e[2] /= t.length, e }([r, i, n, a]), h = [], l = 0; l < t.width * t.height; l++) { var d = di(o, [t.data[4 * l], t.data[4 * l + 1], t.data[4 * l + 2]]); h[l] = d < s ? 0 : 255 } return h } }(t, this.threshold()); return e && function (t, e) { for (var i = 0; i < t.width * t.height; i++)t.data[4 * i + 3] = e[i] }(t, e = function (t, e, i) { for (var r = [1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9, 1 / 9], a = Math.round(Math.sqrt(r.length)), n = Math.floor(a / 2), s = [], o = 0; o < i; o++)for (var h = 0; h < e; h++) { for (var l = o * e + h, d = 0, c = 0; c < a; c++)for (var g = 0; g < a; g++) { var u = o + c - n, f = h + g - n; if (u >= 0 && u < i && f >= 0 && f < e) { var p = r[c * a + g]; d += t[u * e + f] * p } } s[l] = d } return s }(e = function (t, e, i) { for (var r = [1, 1, 1, 1, 1, 1, 1, 1, 1], a = Math.round(Math.sqrt(r.length)), n = Math.floor(a / 2), s = [], o = 0; o < i; o++)for (var h = 0; h < e; h++) { for (var l = o * e + h, d = 0, c = 0; c < a; c++)for (var g = 0; g < a; g++) { var u = o + c - n, f = h + g - n; if (u >= 0 && u < i && f >= 0 && f < e) { var p = r[c * a + g]; d += t[u * e + f] * p } } s[l] = d >= 1020 ? 255 : 0 } return s }(e = function (t, e, i) { for (var r = [1, 1, 1, 1, 0, 1, 1, 1, 1], a = Math.round(Math.sqrt(r.length)), n = Math.floor(a / 2), s = [], o = 0; o < i; o++)for (var h = 0; h < e; h++) { for (var l = o * e + h, d = 0, c = 0; c < a; c++)for (var g = 0; g < a; g++) { var u = o + c - n, f = h + g - n; if (u >= 0 && u < i && f >= 0 && f < e) { var p = r[c * a + g]; d += t[u * e + f] * p } } s[l] = 2040 === d ? 255 : 0 } return s }(e, t.width, t.height), t.width, t.height), t.width, t.height)), t }, Noise: function (t) { var e, i = 255 * this.noise(), r = t.data, a = r.length, n = i / 2; for (e = 0; e < a; e += 4)r[e + 0] += n - 2 * n * Math.random(), r[e + 1] += n - 2 * n * Math.random(), r[e + 2] += n - 2 * n * Math.random() }, Pixelate: function (t) { var e, i, r, a, n, s, o, h, l, d, c, u, f, p, v = Math.ceil(this.pixelSize()), m = t.width, _ = t.height, y = Math.ceil(m / v), x = Math.ceil(_ / v), b = t.data; if (v <= 0) g.error("pixelSize value can not be <= 0"); else for (u = 0; u < y; u += 1)for (f = 0; f < x; f += 1) { for (a = 0, n = 0, s = 0, o = 0, l = (h = u * v) + v, c = (d = f * v) + v, p = 0, e = h; e < l; e += 1)if (!(e >= m)) for (i = d; i < c; i += 1)i >= _ || (a += b[(r = 4 * (m * i + e)) + 0], n += b[r + 1], s += b[r + 2], o += b[r + 3], p += 1); for (a /= p, n /= p, s /= p, o /= p, e = h; e < l; e += 1)if (!(e >= m)) for (i = d; i < c; i += 1)i >= _ || (b[(r = 4 * (m * i + e)) + 0] = a, b[r + 1] = n, b[r + 2] = s, b[r + 3] = o) } }, Posterize: function (t) { var e, i = Math.round(254 * this.levels()) + 1, r = t.data, a = r.length, n = 255 / i; for (e = 0; e < a; e += 1)r[e] = Math.floor(r[e] / n) * n }, RGB: function (t) { var e, i, r = t.data, a = r.length, n = this.red(), s = this.green(), o = this.blue(); for (e = 0; e < a; e += 4)i = (.34 * r[e] + .5 * r[e + 1] + .16 * r[e + 2]) / 255, r[e] = i * n, r[e + 1] = i * s, r[e + 2] = i * o, r[e + 3] = r[e + 3] }, RGBA: function (t) { var e, i, r = t.data, a = r.length, n = this.red(), s = this.green(), o = this.blue(), h = this.alpha(); for (e = 0; e < a; e += 4)i = 1 - h, r[e] = n * h + r[e] * i, r[e + 1] = s * h + r[e + 1] * i, r[e + 2] = o * h + r[e + 2] * i }, Sepia: function (t) { var e, i, r, a, n = t.data, s = n.length; for (e = 0; e < s; e += 4)i = n[e + 0], r = n[e + 1], a = n[e + 2], n[e + 0] = Math.min(255, .393 * i + .769 * r + .189 * a), n[e + 1] = Math.min(255, .349 * i + .686 * r + .168 * a), n[e + 2] = Math.min(255, .272 * i + .534 * r + .131 * a) }, Solarize: function (t) { var e = t.data, i = t.width, r = 4 * i, a = t.height; do { var n = (a - 1) * r, s = i; do { var o = n + 4 * (s - 1), h = e[o], l = e[o + 1], d = e[o + 2]; h > 127 && (h = 255 - h), l > 127 && (l = 255 - l), d > 127 && (d = 255 - d), e[o] = h, e[o + 1] = l, e[o + 2] = d } while (--s) } while (--a) }, Threshold: function (t) { var e, i = 255 * this.threshold(), r = t.data, a = r.length; for (e = 0; e < a; e += 1)r[e] = r[e] < i ? 0 : 255 } } })
}));

var fabric = fabric || { version: "5.2.1" }; if ("undefined" != typeof exports ? exports.fabric = fabric : "function" == typeof define && define.amd && define([], function () { return fabric }), "undefined" != typeof document && "undefined" != typeof window) fabric.document = document instanceof ("undefined" != typeof HTMLDocument ? HTMLDocument : Document) ? document : document.implementation.createHTMLDocument(""), fabric.window = window; else { var jsdom = require("jsdom"), virtualWindow = new jsdom.JSDOM(decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"), { features: { FetchExternalResources: ["img"] }, resources: "usable" }).window; fabric.document = virtualWindow.document, fabric.jsdomImplForWrapper = require("jsdom/lib/jsdom/living/generated/utils").implForWrapper, fabric.nodeCanvas = require("jsdom/lib/jsdom/utils").Canvas, fabric.window = virtualWindow, DOMParser = fabric.window.DOMParser } fabric.isTouchSupported = "ontouchstart" in fabric.window || "ontouchstart" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0, fabric.isLikelyNode = "undefined" != typeof Buffer && "undefined" == typeof window, fabric.SHARED_ATTRIBUTES = ["display", "transform", "fill", "fill-opacity", "fill-rule", "opacity", "stroke", "stroke-dasharray", "stroke-linecap", "stroke-dashoffset", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "id", "paint-order", "vector-effect", "instantiated_by_use", "clip-path"], fabric.DPI = 96, fabric.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)", fabric.commaWsp = "(?:\\s+,?\\s*|,\\s*)", fabric.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi, fabric.reNonWord = /[ \n\.,;!\?\-]/, fabric.fontPaths = {}, fabric.iMatrix = [1, 0, 0, 1, 0, 0], fabric.svgNS = "http://www.w3.org/2000/svg", fabric.perfLimitSizeTotal = 2097152, fabric.maxCacheSideLimit = 4096, fabric.minCacheSideLimit = 256, fabric.charWidthsCache = {}, fabric.textureSize = 2048, fabric.disableStyleCopyPaste = !1, fabric.enableGLFiltering = !0, fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1, fabric.browserShadowBlurConstant = 1, fabric.arcToSegmentsCache = {}, fabric.boundsOfCurveCache = {}, fabric.cachesBoundsOfCurve = !0, fabric.forceGLPutImageData = !1, fabric.initFilterBackend = function () { return fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize) ? (console.log("max texture size: " + fabric.maxTextureSize), new fabric.WebglFilterBackend({ tileSize: fabric.textureSize })) : fabric.Canvas2dFilterBackend ? new fabric.Canvas2dFilterBackend : void 0 }; "undefined" != typeof document && "undefined" != typeof window && (window.fabric = fabric); !function () { function e(e, t) { if (this.__eventListeners[e]) { var r = this.__eventListeners[e]; t ? r[r.indexOf(t)] = !1 : fabric.util.array.fill(r, !1) } } function t(e, t) { if (this.__eventListeners || (this.__eventListeners = {}), 1 === arguments.length) for (var r in e) this.on(r, e[r]); else this.__eventListeners[e] || (this.__eventListeners[e] = []), this.__eventListeners[e].push(t); return this } function r(e, t) { var r = function () { t.apply(this, arguments), this.off(e, r) }.bind(this); this.on(e, r) } function a(e, t) { if (1 === arguments.length) for (var a in e) r.call(this, a, e[a]); else r.call(this, e, t); return this } function i(t, r) { if (!this.__eventListeners) return this; if (0 === arguments.length) for (t in this.__eventListeners) e.call(this, t); else if (1 === arguments.length && "object" == typeof arguments[0]) for (var a in t) e.call(this, a, t[a]); else e.call(this, t, r); return this } function n(e, t) { if (!this.__eventListeners) return this; var r = this.__eventListeners[e]; if (!r) return this; for (var a = 0, i = r.length; i > a; a++)r[a] && r[a].call(this, t || {}); return this.__eventListeners[e] = r.filter(function (e) { return e !== !1 }), this } fabric.Observable = { fire: n, on: t, once: a, off: i } }(); fabric.Collection = { _objects: [], add: function () { if (this._objects.push.apply(this._objects, arguments), this._onObjectAdded) for (var t = 0, e = arguments.length; e > t; t++)this._onObjectAdded(arguments[t]); return this.renderOnAddRemove && this.requestRenderAll(), this }, insertAt: function (t, e, i) { var r = this._objects; return i ? r[e] = t : r.splice(e, 0, t), this._onObjectAdded && this._onObjectAdded(t), this.renderOnAddRemove && this.requestRenderAll(), this }, remove: function () { for (var t, e = this._objects, i = !1, r = 0, n = arguments.length; n > r; r++)t = e.indexOf(arguments[r]), -1 !== t && (i = !0, e.splice(t, 1), this._onObjectRemoved && this._onObjectRemoved(arguments[r])); return this.renderOnAddRemove && i && this.requestRenderAll(), this }, forEachObject: function (t, e) { for (var i = this.getObjects(), r = 0, n = i.length; n > r; r++)t.call(e, i[r], r, i); return this }, getObjects: function (t) { return "undefined" == typeof t ? this._objects.concat() : this._objects.filter(function (e) { return e.type === t }) }, item: function (t) { return this._objects[t] }, isEmpty: function () { return 0 === this._objects.length }, size: function () { return this._objects.length }, contains: function (t, e) { return this._objects.indexOf(t) > -1 ? !0 : e ? this._objects.some(function (e) { return "function" == typeof e.contains && e.contains(t, !0) }) : !1 }, complexity: function () { return this._objects.reduce(function (t, e) { return t += e.complexity ? e.complexity() : 0 }, 0) } }; fabric.CommonMethods = { _setOptions: function (t) { for (var e in t) this.set(e, t[e]) }, _initGradient: function (t, e) { !t || !t.colorStops || t instanceof fabric.Gradient || this.set(e, new fabric.Gradient(t)) }, _initPattern: function (t, e, i) { !t || !t.source || t instanceof fabric.Pattern ? i && i() : this.set(e, new fabric.Pattern(t, i)) }, _setObject: function (t) { for (var e in t) this._set(e, t[e]) }, set: function (t, e) { return "object" == typeof t ? this._setObject(t) : this._set(t, e), this }, _set: function (t, e) { this[t] = e }, toggle: function (t) { var e = this.get(t); return "boolean" == typeof e && this.set(t, !e), this }, get: function (t) { return this[t] } }; !function (t) { var e = Math.sqrt, i = Math.atan2, r = Math.pow, n = Math.PI / 180, a = Math.PI / 2; fabric.util = { cos: function (t) { if (0 === t) return 1; 0 > t && (t = -t); var e = t / a; switch (e) { case 1: case 3: return 0; case 2: return -1 }return Math.cos(t) }, sin: function (t) { if (0 === t) return 0; var e = t / a, i = 1; switch (0 > t && (i = -1), e) { case 1: return i; case 2: return 0; case 3: return -i }return Math.sin(t) }, removeFromArray: function (t, e) { var i = t.indexOf(e); return -1 !== i && t.splice(i, 1), t }, getRandomInt: function (t, e) { return Math.floor(Math.random() * (e - t + 1)) + t }, degreesToRadians: function (t) { return t * n }, radiansToDegrees: function (t) { return t / n }, rotatePoint: function (t, e, i) { var r = new fabric.Point(t.x - e.x, t.y - e.y), n = fabric.util.rotateVector(r, i); return new fabric.Point(n.x, n.y).addEquals(e) }, rotateVector: function (t, e) { var i = fabric.util.sin(e), r = fabric.util.cos(e), n = t.x * r - t.y * i, a = t.x * i + t.y * r; return { x: n, y: a } }, createVector: function (t, e) { return new fabric.Point(e.x - t.x, e.y - t.y) }, calcAngleBetweenVectors: function (t, e) { return Math.acos((t.x * e.x + t.y * e.y) / (Math.hypot(t.x, t.y) * Math.hypot(e.x, e.y))) }, getHatVector: function (t) { return new fabric.Point(t.x, t.y).multiply(1 / Math.hypot(t.x, t.y)) }, getBisector: function (t, e, i) { var r = fabric.util.createVector(t, e), n = fabric.util.createVector(t, i), a = fabric.util.calcAngleBetweenVectors(r, n), s = fabric.util.calcAngleBetweenVectors(fabric.util.rotateVector(r, a), n), o = a * (0 === s ? 1 : -1) / 2; return { vector: fabric.util.getHatVector(fabric.util.rotateVector(r, o)), angle: a } }, projectStrokeOnPoints: function (t, e, i) { var r = [], n = e.strokeWidth / 2, a = e.strokeUniform ? new fabric.Point(1 / e.scaleX, 1 / e.scaleY) : new fabric.Point(1, 1), s = function (t) { var e = n / Math.hypot(t.x, t.y); return new fabric.Point(t.x * e * a.x, t.y * e * a.y) }; return t.length <= 1 ? r : (t.forEach(function (o, c) { var h, l, f = new fabric.Point(o.x, o.y); 0 === c ? (l = t[c + 1], h = i ? s(fabric.util.createVector(l, f)).addEquals(f) : t[t.length - 1]) : c === t.length - 1 ? (h = t[c - 1], l = i ? s(fabric.util.createVector(h, f)).addEquals(f) : t[0]) : (h = t[c - 1], l = t[c + 1]); var u, d, p = fabric.util.getBisector(f, h, l), b = p.vector, v = p.angle; return "miter" === e.strokeLineJoin && (u = -n / Math.sin(v / 2), d = new fabric.Point(b.x * u * a.x, b.y * u * a.y), Math.hypot(d.x, d.y) / n <= e.strokeMiterLimit) ? (r.push(f.add(d)), void r.push(f.subtract(d))) : (u = -n * Math.SQRT2, d = new fabric.Point(b.x * u * a.x, b.y * u * a.y), r.push(f.add(d)), void r.push(f.subtract(d))) }), r) }, transformPoint: function (t, e, i) { return i ? new fabric.Point(e[0] * t.x + e[2] * t.y, e[1] * t.x + e[3] * t.y) : new fabric.Point(e[0] * t.x + e[2] * t.y + e[4], e[1] * t.x + e[3] * t.y + e[5]) }, makeBoundingBoxFromPoints: function (t, e) { if (e) for (var i = 0; i < t.length; i++)t[i] = fabric.util.transformPoint(t[i], e); var r = [t[0].x, t[1].x, t[2].x, t[3].x], n = fabric.util.array.min(r), a = fabric.util.array.max(r), s = a - n, o = [t[0].y, t[1].y, t[2].y, t[3].y], c = fabric.util.array.min(o), h = fabric.util.array.max(o), l = h - c; return { left: n, top: c, width: s, height: l } }, invertTransform: function (t) { var e = 1 / (t[0] * t[3] - t[1] * t[2]), i = [e * t[3], -e * t[1], -e * t[2], e * t[0]], r = fabric.util.transformPoint({ x: t[4], y: t[5] }, i, !0); return i[4] = -r.x, i[5] = -r.y, i }, toFixed: function (t, e) { return parseFloat(Number(t).toFixed(e)) }, parseUnit: function (t, e) { var i = /\D{0,2}$/.exec(t), r = parseFloat(t); switch (e || (e = fabric.Text.DEFAULT_SVG_FONT_SIZE), i[0]) { case "mm": return r * fabric.DPI / 25.4; case "cm": return r * fabric.DPI / 2.54; case "in": return r * fabric.DPI; case "pt": return r * fabric.DPI / 72; case "pc": return r * fabric.DPI / 72 * 12; case "em": return r * e; default: return r } }, falseFunction: function () { return !1 }, getKlass: function (t, e) { return t = fabric.util.string.camelize(t.charAt(0).toUpperCase() + t.slice(1)), fabric.util.resolveNamespace(e)[t] }, getSvgAttributes: function (t) { var e = ["instantiated_by_use", "style", "id", "class"]; switch (t) { case "linearGradient": e = e.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]); break; case "radialGradient": e = e.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]); break; case "stop": e = e.concat(["offset", "stop-color", "stop-opacity"]) }return e }, resolveNamespace: function (e) { if (!e) return fabric; var i, r = e.split("."), n = r.length, a = t || fabric.window; for (i = 0; n > i; ++i)a = a[r[i]]; return a }, loadImage: function (t, e, i, r) { if (!t) return void (e && e.call(i, t)); var n = fabric.util.createImage(), a = function () { e && e.call(i, n, !1), n = n.onload = n.onerror = null }; n.onload = a, n.onerror = function () { fabric.log("Error loading " + n.src), e && e.call(i, null, !0), n = n.onload = n.onerror = null }, 0 !== t.indexOf("data") && void 0 !== r && null !== r && (n.crossOrigin = r), "data:image/svg" === t.substring(0, 14) && (n.onload = null, fabric.util.loadImageInDom(n, a)), n.src = t }, loadImageInDom: function (t, e) { var i = fabric.document.createElement("div"); i.style.width = i.style.height = "1px", i.style.left = i.style.top = "-100%", i.style.position = "absolute", i.appendChild(t), fabric.document.querySelector("body").appendChild(i), t.onload = function () { e(), i.parentNode.removeChild(i), i = null } }, enlivenObjects: function (t, e, i, r) { function n() { ++s === o && e && e(a.filter(function (t) { return t })) } t = t || []; var a = [], s = 0, o = t.length; return o ? void t.forEach(function (t, e) { if (!t || !t.type) return void n(); var s = fabric.util.getKlass(t.type, i); s.fromObject(t, function (i, s) { s || (a[e] = i), r && r(t, i, s), n() }) }) : void (e && e(a)) }, enlivenObjectEnlivables: function (t, e, i) { var r = fabric.Object.ENLIVEN_PROPS.filter(function (e) { return !!t[e] }); fabric.util.enlivenObjects(r.map(function (e) { return t[e] }), function (t) { var n = {}; r.forEach(function (i, r) { n[i] = t[r], e && (e[i] = t[r]) }), i && i(n) }) }, enlivenPatterns: function (t, e) { function i() { ++n === a && e && e(r) } t = t || []; var r = [], n = 0, a = t.length; return a ? void t.forEach(function (t, e) { t && t.source ? new fabric.Pattern(t, function (t) { r[e] = t, i() }) : (r[e] = t, i()) }) : void (e && e(r)) }, groupSVGElements: function (t, e, i) { var r; return t && 1 === t.length ? t[0] : (e && (e.width && e.height ? e.centerPoint = { x: e.width / 2, y: e.height / 2 } : (delete e.width, delete e.height)), r = new fabric.Group(t, e), "undefined" != typeof i && (r.sourcePath = i), r) }, populateWithProperties: function (t, e, i) { if (i && Array.isArray(i)) for (var r = 0, n = i.length; n > r; r++)i[r] in t && (e[i[r]] = t[i[r]]) }, createCanvasElement: function () { return fabric.document.createElement("canvas") }, copyCanvasElement: function (t) { var e = fabric.util.createCanvasElement(); return e.width = t.width, e.height = t.height, e.getContext("2d").drawImage(t, 0, 0), e }, toDataURL: function (t, e, i) { return t.toDataURL("image/" + e, i) }, createImage: function () { return fabric.document.createElement("img") }, multiplyTransformMatrices: function (t, e, i) { return [t[0] * e[0] + t[2] * e[1], t[1] * e[0] + t[3] * e[1], t[0] * e[2] + t[2] * e[3], t[1] * e[2] + t[3] * e[3], i ? 0 : t[0] * e[4] + t[2] * e[5] + t[4], i ? 0 : t[1] * e[4] + t[3] * e[5] + t[5]] }, qrDecompose: function (t) { var a = i(t[1], t[0]), s = r(t[0], 2) + r(t[1], 2), o = e(s), c = (t[0] * t[3] - t[2] * t[1]) / o, h = i(t[0] * t[2] + t[1] * t[3], s); return { angle: a / n, scaleX: o, scaleY: c, skewX: h / n, skewY: 0, translateX: t[4], translateY: t[5] } }, calcRotateMatrix: function (t) { if (!t.angle) return fabric.iMatrix.concat(); var e = fabric.util.degreesToRadians(t.angle), i = fabric.util.cos(e), r = fabric.util.sin(e); return [i, r, -r, i, 0, 0] }, calcDimensionsMatrix: function (t) { var e = "undefined" == typeof t.scaleX ? 1 : t.scaleX, i = "undefined" == typeof t.scaleY ? 1 : t.scaleY, r = [t.flipX ? -e : e, 0, 0, t.flipY ? -i : i, 0, 0], n = fabric.util.multiplyTransformMatrices, a = fabric.util.degreesToRadians; return t.skewX && (r = n(r, [1, 0, Math.tan(a(t.skewX)), 1], !0)), t.skewY && (r = n(r, [1, Math.tan(a(t.skewY)), 0, 1], !0)), r }, composeMatrix: function (t) { var e = [1, 0, 0, 1, t.translateX || 0, t.translateY || 0], i = fabric.util.multiplyTransformMatrices; return t.angle && (e = i(e, fabric.util.calcRotateMatrix(t))), (1 !== t.scaleX || 1 !== t.scaleY || t.skewX || t.skewY || t.flipX || t.flipY) && (e = i(e, fabric.util.calcDimensionsMatrix(t))), e }, resetObjectTransform: function (t) { t.scaleX = 1, t.scaleY = 1, t.skewX = 0, t.skewY = 0, t.flipX = !1, t.flipY = !1, t.rotate(0) }, saveObjectTransform: function (t) { return { scaleX: t.scaleX, scaleY: t.scaleY, skewX: t.skewX, skewY: t.skewY, angle: t.angle, left: t.left, flipX: t.flipX, flipY: t.flipY, top: t.top } }, isTransparent: function (t, e, i, r) { r > 0 && (e > r ? e -= r : e = 0, i > r ? i -= r : i = 0); var n, a, s = !0, o = t.getImageData(e, i, 2 * r || 1, 2 * r || 1), c = o.data.length; for (n = 3; c > n && (a = o.data[n], s = 0 >= a, s !== !1); n += 4); return o = null, s }, parsePreserveAspectRatioAttribute: function (t) { var e, i = "meet", r = "Mid", n = "Mid", a = t.split(" "); return a && a.length && (i = a.pop(), "meet" !== i && "slice" !== i ? (e = i, i = "meet") : a.length && (e = a.pop())), r = "none" !== e ? e.slice(1, 4) : "none", n = "none" !== e ? e.slice(5, 8) : "none", { meetOrSlice: i, alignX: r, alignY: n } }, clearFabricFontCache: function (t) { t = (t || "").toLowerCase(), t ? fabric.charWidthsCache[t] && delete fabric.charWidthsCache[t] : fabric.charWidthsCache = {} }, limitDimsByArea: function (t, e) { var i = Math.sqrt(e * t), r = Math.floor(e / i); return { x: Math.floor(i), y: r } }, capValue: function (t, e, i) { return Math.max(t, Math.min(e, i)) }, findScaleToFit: function (t, e) { return Math.min(e.width / t.width, e.height / t.height) }, findScaleToCover: function (t, e) { return Math.max(e.width / t.width, e.height / t.height) }, matrixToSVG: function (t) { return "matrix(" + t.map(function (t) { return fabric.util.toFixed(t, fabric.Object.NUM_FRACTION_DIGITS) }).join(" ") + ")" }, removeTransformFromObject: function (t, e) { var i = fabric.util.invertTransform(e), r = fabric.util.multiplyTransformMatrices(i, t.calcOwnMatrix()); fabric.util.applyTransformToObject(t, r) }, addTransformToObject: function (t, e) { fabric.util.applyTransformToObject(t, fabric.util.multiplyTransformMatrices(e, t.calcOwnMatrix())) }, applyTransformToObject: function (t, e) { var i = fabric.util.qrDecompose(e), r = new fabric.Point(i.translateX, i.translateY); t.flipX = !1, t.flipY = !1, t.set("scaleX", i.scaleX), t.set("scaleY", i.scaleY), t.skewX = i.skewX, t.skewY = i.skewY, t.angle = i.angle, t.setPositionByOrigin(r, "center", "center") }, sizeAfterTransform: function (t, e, i) { var r = t / 2, n = e / 2, a = [{ x: -r, y: -n }, { x: r, y: -n }, { x: -r, y: n }, { x: r, y: n }], s = fabric.util.calcDimensionsMatrix(i), o = fabric.util.makeBoundingBoxFromPoints(a, s); return { x: o.width, y: o.height } }, mergeClipPaths: function (t, e) { var i = t, r = e; i.inverted && !r.inverted && (i = e, r = t), fabric.util.applyTransformToObject(r, fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(i.calcTransformMatrix()), r.calcTransformMatrix())); var n = i.inverted && r.inverted; return n && (i.inverted = r.inverted = !1), new fabric.Group([i], { clipPath: r, inverted: n }) }, hasStyleChanged: function (t, e, i) { return i = i || !1, t.fill !== e.fill || t.stroke !== e.stroke || t.strokeWidth !== e.strokeWidth || t.fontSize !== e.fontSize || t.fontFamily !== e.fontFamily || t.fontWeight !== e.fontWeight || t.fontStyle !== e.fontStyle || t.deltaY !== e.deltaY || i && (t.overline !== e.overline || t.underline !== e.underline || t.linethrough !== e.linethrough) }, stylesToArray: function (t, e) { for (var t = fabric.util.object.clone(t, !0), i = e.split("\n"), r = -1, n = {}, a = [], s = 0; s < i.length; s++)if (t[s]) for (var o = 0; o < i[s].length; o++) { r++; var c = t[s][o]; if (c) { var h = fabric.util.hasStyleChanged(n, c, !0); h ? a.push({ start: r, end: r + 1, style: c }) : a[a.length - 1].end++ } n = c || {} } else r += i[s].length; return a }, stylesFromArray: function (t, e) { if (!Array.isArray(t)) return t; for (var i = e.split("\n"), r = -1, n = 0, a = {}, s = 0; s < i.length; s++)for (var o = 0; o < i[s].length; o++)r++, t[n] && t[n].start <= r && r < t[n].end && (a[s] = a[s] || {}, a[s][o] = Object.assign({}, t[n].style), r === t[n].end - 1 && n++); return a } } }("undefined" != typeof exports ? exports : this); !function () { function t(t, e, i, r, n, s, a, o, c, h, l) { var u = fabric.util.cos(t), f = fabric.util.sin(t), d = fabric.util.cos(e), p = fabric.util.sin(e), v = i * n * d - r * s * p + a, g = r * n * d + i * s * p + o, b = h + c * (-i * n * f - r * s * u), m = l + c * (-r * n * f + i * s * u), y = v + c * (i * n * p + r * s * d), _ = g + c * (r * n * p - i * s * d); return ["C", b, m, y, _, v, g] } function e(e, r, n, s, a, o, c) { var h = Math.PI, l = c * h / 180, u = fabric.util.sin(l), f = fabric.util.cos(l), d = 0, p = 0; n = Math.abs(n), s = Math.abs(s); var v = -f * e * .5 - u * r * .5, g = -f * r * .5 + u * e * .5, b = n * n, m = s * s, y = g * g, _ = v * v, x = b * m - b * y - m * _, S = 0; if (0 > x) { var C = Math.sqrt(1 - x / (b * m)); n *= C, s *= C } else S = (a === o ? -1 : 1) * Math.sqrt(x / (b * y + m * _)); var T = S * n * g / s, w = -S * s * v / n, E = f * T - u * w + .5 * e, M = u * T + f * w + .5 * r, O = i(1, 0, (v - T) / n, (g - w) / s), k = i((v - T) / n, (g - w) / s, (-v - T) / n, (-g - w) / s); 0 === o && k > 0 ? k -= 2 * h : 1 === o && 0 > k && (k += 2 * h); for (var P = Math.ceil(Math.abs(k / h * 2)), L = [], D = k / P, j = 8 / 3 * Math.sin(D / 4) * Math.sin(D / 4) / Math.sin(D / 2), I = O + D, A = 0; P > A; A++)L[A] = t(O, I, f, u, n, s, E, M, j, d, p), d = L[A][5], p = L[A][6], O = I, I += D; return L } function i(t, e, i, r) { var n = Math.atan2(e, t), s = Math.atan2(r, i); return s >= n ? s - n : 2 * Math.PI - (n - s) } function r(t, e, i, r, n, s, a, o) { var c; if (fabric.cachesBoundsOfCurve && (c = w.call(arguments), fabric.boundsOfCurveCache[c])) return fabric.boundsOfCurveCache[c]; var h, l, u, f, d, p, v, g, b = Math.sqrt, m = Math.min, y = Math.max, _ = Math.abs, x = [], S = [[], []]; l = 6 * t - 12 * i + 6 * n, h = -3 * t + 9 * i - 9 * n + 3 * a, u = 3 * i - 3 * t; for (var C = 0; 2 > C; ++C)if (C > 0 && (l = 6 * e - 12 * r + 6 * s, h = -3 * e + 9 * r - 9 * s + 3 * o, u = 3 * r - 3 * e), _(h) < 1e-12) { if (_(l) < 1e-12) continue; f = -u / l, f > 0 && 1 > f && x.push(f) } else v = l * l - 4 * u * h, 0 > v || (g = b(v), d = (-l + g) / (2 * h), d > 0 && 1 > d && x.push(d), p = (-l - g) / (2 * h), p > 0 && 1 > p && x.push(p)); for (var T, E, M, O = x.length, k = O; O--;)f = x[O], M = 1 - f, T = M * M * M * t + 3 * M * M * f * i + 3 * M * f * f * n + f * f * f * a, S[0][O] = T, E = M * M * M * e + 3 * M * M * f * r + 3 * M * f * f * s + f * f * f * o, S[1][O] = E; S[0][k] = t, S[1][k] = e, S[0][k + 1] = a, S[1][k + 1] = o; var P = [{ x: m.apply(null, S[0]), y: m.apply(null, S[1]) }, { x: y.apply(null, S[0]), y: y.apply(null, S[1]) }]; return fabric.cachesBoundsOfCurve && (fabric.boundsOfCurveCache[c] = P), P } function n(t, i, r) { for (var n = r[1], s = r[2], a = r[3], o = r[4], c = r[5], h = r[6], l = r[7], u = e(h - t, l - i, n, s, o, c, a), f = 0, d = u.length; d > f; f++)u[f][1] += t, u[f][2] += i, u[f][3] += t, u[f][4] += i, u[f][5] += t, u[f][6] += i; return u } function s(t) { var e, i, r, s, a, o, c = 0, h = 0, l = t.length, u = 0, f = 0, d = []; for (i = 0; l > i; ++i) { switch (r = !1, e = t[i].slice(0), e[0]) { case "l": e[0] = "L", e[1] += c, e[2] += h; case "L": c = e[1], h = e[2]; break; case "h": e[1] += c; case "H": e[0] = "L", e[2] = h, c = e[1]; break; case "v": e[1] += h; case "V": e[0] = "L", h = e[1], e[1] = c, e[2] = h; break; case "m": e[0] = "M", e[1] += c, e[2] += h; case "M": c = e[1], h = e[2], u = e[1], f = e[2]; break; case "c": e[0] = "C", e[1] += c, e[2] += h, e[3] += c, e[4] += h, e[5] += c, e[6] += h; case "C": a = e[3], o = e[4], c = e[5], h = e[6]; break; case "s": e[0] = "S", e[1] += c, e[2] += h, e[3] += c, e[4] += h; case "S": "C" === s ? (a = 2 * c - a, o = 2 * h - o) : (a = c, o = h), c = e[3], h = e[4], e[0] = "C", e[5] = e[3], e[6] = e[4], e[3] = e[1], e[4] = e[2], e[1] = a, e[2] = o, a = e[3], o = e[4]; break; case "q": e[0] = "Q", e[1] += c, e[2] += h, e[3] += c, e[4] += h; case "Q": a = e[1], o = e[2], c = e[3], h = e[4]; break; case "t": e[0] = "T", e[1] += c, e[2] += h; case "T": "Q" === s ? (a = 2 * c - a, o = 2 * h - o) : (a = c, o = h), e[0] = "Q", c = e[1], h = e[2], e[1] = a, e[2] = o, e[3] = c, e[4] = h; break; case "a": e[0] = "A", e[6] += c, e[7] += h; case "A": r = !0, d = d.concat(n(c, h, e)), c = e[6], h = e[7]; break; case "z": case "Z": c = u, h = f }r || d.push(e), s = e[0] } return d } function a(t, e, i, r) { return Math.sqrt((i - t) * (i - t) + (r - e) * (r - e)) } function o(t) { return t * t * t } function c(t) { return 3 * t * t * (1 - t) } function h(t) { return 3 * t * (1 - t) * (1 - t) } function l(t) { return (1 - t) * (1 - t) * (1 - t) } function u(t, e, i, r, n, s, a, u) { return function (f) { var d = o(f), p = c(f), v = h(f), g = l(f); return { x: a * d + n * p + i * v + t * g, y: u * d + s * p + r * v + e * g } } } function f(t, e, i, r, n, s, a, o) { return function (c) { var h = 1 - c, l = 3 * h * h * (i - t) + 6 * h * c * (n - i) + 3 * c * c * (a - n), u = 3 * h * h * (r - e) + 6 * h * c * (s - r) + 3 * c * c * (o - s); return Math.atan2(u, l) } } function d(t) { return t * t } function p(t) { return 2 * t * (1 - t) } function v(t) { return (1 - t) * (1 - t) } function g(t, e, i, r, n, s) { return function (a) { var o = d(a), c = p(a), h = v(a); return { x: n * o + i * c + t * h, y: s * o + r * c + e * h } } } function b(t, e, i, r, n, s) { return function (a) { var o = 1 - a, c = 2 * o * (i - t) + 2 * a * (n - i), h = 2 * o * (r - e) + 2 * a * (s - r); return Math.atan2(h, c) } } function m(t, e, i) { var r, n, s = { x: e, y: i }, o = 0; for (n = 1; 100 >= n; n += 1)r = t(n / 100), o += a(s.x, s.y, r.x, r.y), s = r; return o } function y(t, e) { for (var i, r, n, s = 0, o = 0, c = t.iterator, h = { x: t.x, y: t.y }, l = .01, u = t.angleFinder; e > o && l > 1e-4;)i = c(s), n = s, r = a(h.x, h.y, i.x, i.y), r + o > e ? (s -= l, l /= 2) : (h = i, s += l, o += r); return i.angle = u(n), i } function _(t) { for (var e, i, r, n, s = 0, o = t.length, c = 0, h = 0, l = 0, d = 0, p = [], v = 0; o > v; v++) { switch (e = t[v], r = { x: c, y: h, command: e[0] }, e[0]) { case "M": r.length = 0, l = c = e[1], d = h = e[2]; break; case "L": r.length = a(c, h, e[1], e[2]), c = e[1], h = e[2]; break; case "C": i = u(c, h, e[1], e[2], e[3], e[4], e[5], e[6]), n = f(c, h, e[1], e[2], e[3], e[4], e[5], e[6]), r.iterator = i, r.angleFinder = n, r.length = m(i, c, h), c = e[5], h = e[6]; break; case "Q": i = g(c, h, e[1], e[2], e[3], e[4]), n = b(c, h, e[1], e[2], e[3], e[4]), r.iterator = i, r.angleFinder = n, r.length = m(i, c, h), c = e[3], h = e[4]; break; case "Z": case "z": r.destX = l, r.destY = d, r.length = a(c, h, l, d), c = l, h = d }s += r.length, p.push(r) } return p.push({ length: s, x: c, y: h }), p } function x(t, e, i) { i || (i = _(t)); for (var r = 0; e - i[r].length > 0 && r < i.length - 2;)e -= i[r].length, r++; var n, s = i[r], a = e / s.length, o = s.command, c = t[r]; switch (o) { case "M": return { x: s.x, y: s.y, angle: 0 }; case "Z": case "z": return n = new fabric.Point(s.x, s.y).lerp(new fabric.Point(s.destX, s.destY), a), n.angle = Math.atan2(s.destY - s.y, s.destX - s.x), n; case "L": return n = new fabric.Point(s.x, s.y).lerp(new fabric.Point(c[1], c[2]), a), n.angle = Math.atan2(c[2] - s.y, c[1] - s.x), n; case "C": return y(s, e); case "Q": return y(s, e) } } function S(t) { var e, i, r, n, s, a = [], o = [], c = fabric.rePathCommand, h = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", l = "(" + h + ")" + fabric.commaWsp, u = "([01])" + fabric.commaWsp + "?", f = l + "?" + l + "?" + l + u + u + l + "?(" + h + ")", d = new RegExp(f, "g"); if (!t || !t.match) return a; s = t.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi); for (var p, v = 0, g = s.length; g > v; v++) { e = s[v], n = e.slice(1).trim(), o.length = 0; var b = e.charAt(0); if (p = [b], "a" === b.toLowerCase()) for (var m; m = d.exec(n);)for (var y = 1; y < m.length; y++)o.push(m[y]); else for (; r = c.exec(n);)o.push(r[0]); for (var y = 0, _ = o.length; _ > y; y++)i = parseFloat(o[y]), isNaN(i) || p.push(i); var x = E[b.toLowerCase()], S = M[b] || b; if (p.length - 1 > x) for (var C = 1, T = p.length; T > C; C += x)a.push([b].concat(p.slice(C, C + x))), b = S; else a.push(p) } return a } function C(t, e) { var i, r = [], n = new fabric.Point(t[0].x, t[0].y), s = new fabric.Point(t[1].x, t[1].y), a = t.length, o = 1, c = 0, h = a > 2; for (e = e || 0, h && (o = t[2].x < s.x ? -1 : t[2].x === s.x ? 0 : 1, c = t[2].y < s.y ? -1 : t[2].y === s.y ? 0 : 1), r.push(["M", n.x - o * e, n.y - c * e]), i = 1; a > i; i++) { if (!n.eq(s)) { var l = n.midPointFrom(s); r.push(["Q", n.x, n.y, l.x, l.y]) } n = t[i], i + 1 < t.length && (s = t[i + 1]) } return h && (o = n.x > t[i - 2].x ? 1 : n.x === t[i - 2].x ? 0 : -1, c = n.y > t[i - 2].y ? 1 : n.y === t[i - 2].y ? 0 : -1), r.push(["L", n.x + o * e, n.y + c * e]), r } function T(t, e, i) { return i && (e = fabric.util.multiplyTransformMatrices(e, [1, 0, 0, 1, -i.x, -i.y])), t.map(function (t) { for (var i = t.slice(0), r = {}, n = 1; n < t.length - 1; n += 2)r.x = t[n], r.y = t[n + 1], r = fabric.util.transformPoint(r, e), i[n] = r.x, i[n + 1] = r.y; return i }) } var w = Array.prototype.join, E = { m: 2, l: 2, h: 1, v: 1, c: 6, s: 4, q: 4, t: 2, a: 7 }, M = { m: "l", M: "L" }; fabric.util.joinPath = function (t) { return t.map(function (t) { return t.join(" ") }).join(" ") }, fabric.util.parsePath = S, fabric.util.makePathSimpler = s, fabric.util.getSmoothPathFromPoints = C, fabric.util.getPathSegmentsInfo = _, fabric.util.getBoundsOfCurve = r, fabric.util.getPointOnPath = x, fabric.util.transformPath = T }(); !function () { function t(t, e) { for (var i = s.call(arguments, 2), r = [], n = 0, a = t.length; a > n; n++)r[n] = i.length ? t[n][e].apply(t[n], i) : t[n][e].call(t[n]); return r } function e(t, e) { return n(t, e, function (t, e) { return t >= e }) } function i(t, e) { return n(t, e, function (t, e) { return e > t }) } function r(t, e) { for (var i = t.length; i--;)t[i] = e; return t } function n(t, e, i) { if (t && 0 !== t.length) { var r = t.length - 1, n = e ? t[r][e] : t[r]; if (e) for (; r--;)i(t[r][e], n) && (n = t[r][e]); else for (; r--;)i(t[r], n) && (n = t[r]); return n } } var s = Array.prototype.slice; fabric.util.array = { fill: r, invoke: t, min: i, max: e } }(); !function () { function t(e, i, r) { if (r) if (!fabric.isLikelyNode && i instanceof Element) e = i; else if (i instanceof Array) { e = []; for (var n = 0, a = i.length; a > n; n++)e[n] = t({}, i[n], r) } else if (i && "object" == typeof i) for (var s in i) "canvas" === s || "group" === s ? e[s] = null : i.hasOwnProperty(s) && (e[s] = t({}, i[s], r)); else e = i; else for (var s in i) e[s] = i[s]; return e } function e(e, i) { return t({}, e, i) } fabric.util.object = { extend: t, clone: e }, fabric.util.object.extend(fabric.util, fabric.Observable) }(); !function () { function t(t) { return t.replace(/-+(.)?/g, function (t, e) { return e ? e.toUpperCase() : "" }) } function e(t, e) { return t.charAt(0).toUpperCase() + (e ? t.slice(1) : t.slice(1).toLowerCase()) } function i(t) { return t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;") } function r(t) { var e, i = 0, r = []; for (i = 0, e; i < t.length; i++)(e = n(t, i)) !== !1 && r.push(e); return r } function n(t, e) { var i = t.charCodeAt(e); if (isNaN(i)) return ""; if (55296 > i || i > 57343) return t.charAt(e); if (i >= 55296 && 56319 >= i) { if (t.length <= e + 1) throw "High surrogate without following low surrogate"; var r = t.charCodeAt(e + 1); if (56320 > r || r > 57343) throw "High surrogate without following low surrogate"; return t.charAt(e) + t.charAt(e + 1) } if (0 === e) throw "Low surrogate without preceding high surrogate"; var n = t.charCodeAt(e - 1); if (55296 > n || n > 56319) throw "Low surrogate without preceding high surrogate"; return !1 } fabric.util.string = { camelize: t, capitalize: e, escapeXml: i, graphemeSplit: r } }(); !function () { function t() { } function e(t) { for (var e = null, i = this; i.constructor.superclass;) { var n = i.constructor.superclass.prototype[t]; if (i[t] !== n) { e = n; break } i = i.constructor.superclass.prototype } return e ? arguments.length > 1 ? e.apply(this, r.call(arguments, 1)) : e.call(this) : console.log("tried to callSuper " + t + ", method not found in prototype chain", this) } function i() { function i() { this.initialize.apply(this, arguments) } var s = null, o = r.call(arguments, 0); "function" == typeof o[0] && (s = o.shift()), i.superclass = s, i.subclasses = [], s && (t.prototype = s.prototype, i.prototype = new t, s.subclasses.push(i)); for (var c = 0, h = o.length; h > c; c++)a(i, o[c], s); return i.prototype.initialize || (i.prototype.initialize = n), i.prototype.constructor = i, i.prototype.callSuper = e, i } var r = Array.prototype.slice, n = function () { }, s = function () { for (var t in { toString: 1 }) if ("toString" === t) return !1; return !0 }(), a = function (t, e, i) { for (var r in e) t.prototype[r] = r in t.prototype && "function" == typeof t.prototype[r] && (e[r] + "").indexOf("callSuper") > -1 ? function (t) { return function () { var r = this.constructor.superclass; this.constructor.superclass = i; var n = e[t].apply(this, arguments); return this.constructor.superclass = r, "initialize" !== t ? n : void 0 } }(r) : e[r], s && (e.toString !== Object.prototype.toString && (t.prototype.toString = e.toString), e.valueOf !== Object.prototype.valueOf && (t.prototype.valueOf = e.valueOf)) }; fabric.util.createClass = i }(); !function () { function t(t) { var e = t.changedTouches; return e && e[0] ? e[0] : t } var e = !!fabric.document.createElement("div").attachEvent, i = ["touchstart", "touchmove", "touchend"]; fabric.util.addListener = function (t, i, r, n) { t && t.addEventListener(i, r, e ? !1 : n) }, fabric.util.removeListener = function (t, i, r, n) { t && t.removeEventListener(i, r, e ? !1 : n) }, fabric.util.getPointer = function (e) { var i = e.target, r = fabric.util.getScrollLeftTop(i), n = t(e); return { x: n.clientX + r.left, y: n.clientY + r.top } }, fabric.util.isTouchEvent = function (t) { return i.indexOf(t.type) > -1 || "touch" === t.pointerType } }(); !function () { function t(t, e) { var i = t.style; if (!i) return t; if ("string" == typeof e) return t.style.cssText += ";" + e, e.indexOf("opacity") > -1 ? s(t, e.match(/opacity:\s*(\d?\.?\d*)/)[1]) : t; for (var r in e) if ("opacity" === r) s(t, e[r]); else { var n = "float" === r || "cssFloat" === r ? "undefined" == typeof i.styleFloat ? "cssFloat" : "styleFloat" : r; i.setProperty(n, e[r]) } return t } var e = fabric.document.createElement("div"), i = "string" == typeof e.style.opacity, r = "string" == typeof e.style.filter, n = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, s = function (t) { return t }; i ? s = function (t, e) { return t.style.opacity = e, t } : r && (s = function (t, e) { var i = t.style; return t.currentStyle && !t.currentStyle.hasLayout && (i.zoom = 1), n.test(i.filter) ? (e = e >= .9999 ? "" : "alpha(opacity=" + 100 * e + ")", i.filter = i.filter.replace(n, e)) : i.filter += " alpha(opacity=" + 100 * e + ")", t }), fabric.util.setStyle = t }(); !function () { function t(t) { return "string" == typeof t ? fabric.document.getElementById(t) : t } function e(t, e) { var i = fabric.document.createElement(t); for (var n in e) "class" === n ? i.className = e[n] : "for" === n ? i.htmlFor = e[n] : i.setAttribute(n, e[n]); return i } function i(t, e) { t && -1 === (" " + t.className + " ").indexOf(" " + e + " ") && (t.className += (t.className ? " " : "") + e) } function n(t, i, n) { return "string" == typeof i && (i = e(i, n)), t.parentNode && t.parentNode.replaceChild(i, t), i.appendChild(t), i } function r(t) { for (var e = 0, i = 0, n = fabric.document.documentElement, r = fabric.document.body || { scrollLeft: 0, scrollTop: 0 }; t && (t.parentNode || t.host) && (t = t.parentNode || t.host, t === fabric.document ? (e = r.scrollLeft || n.scrollLeft || 0, i = r.scrollTop || n.scrollTop || 0) : (e += t.scrollLeft || 0, i += t.scrollTop || 0), 1 !== t.nodeType || "fixed" !== t.style.position);); return { left: e, top: i } } function s(t) { var e, i, n = t && t.ownerDocument, s = { left: 0, top: 0 }, a = { left: 0, top: 0 }, o = { borderLeftWidth: "left", borderTopWidth: "top", paddingLeft: "left", paddingTop: "top" }; if (!n) return a; for (var h in o) a[o[h]] += parseInt(d(t, h), 10) || 0; return e = n.documentElement, "undefined" != typeof t.getBoundingClientRect && (s = t.getBoundingClientRect()), i = r(t), { left: s.left + i.left - (e.clientLeft || 0) + a.left, top: s.top + i.top - (e.clientTop || 0) + a.top } } function a(t) { var e = fabric.jsdomImplForWrapper(t); return e._canvas || e._image } function o(t) { if (fabric.isLikelyNode) { var e = fabric.jsdomImplForWrapper(t); e && (e._image = null, e._canvas = null, e._currentSrc = null, e._attributes = null, e._classList = null) } } function h(t, e) { t.imageSmoothingEnabled = t.imageSmoothingEnabled || t.webkitImageSmoothingEnabled || t.mozImageSmoothingEnabled || t.msImageSmoothingEnabled || t.oImageSmoothingEnabled, t.imageSmoothingEnabled = e } var c, l = Array.prototype.slice, f = function (t) { return l.call(t, 0) }; try { c = f(fabric.document.childNodes) instanceof Array } catch (u) { } c || (f = function (t) { for (var e = new Array(t.length), i = t.length; i--;)e[i] = t[i]; return e }); var d; d = fabric.document.defaultView && fabric.document.defaultView.getComputedStyle ? function (t, e) { var i = fabric.document.defaultView.getComputedStyle(t, null); return i ? i[e] : void 0 } : function (t, e) { var i = t.style[e]; return !i && t.currentStyle && (i = t.currentStyle[e]), i }, function () { function t(t) { return "undefined" != typeof t.onselectstart && (t.onselectstart = fabric.util.falseFunction), n ? t.style[n] = "none" : "string" == typeof t.unselectable && (t.unselectable = "on"), t } function e(t) { return "undefined" != typeof t.onselectstart && (t.onselectstart = null), n ? t.style[n] = "" : "string" == typeof t.unselectable && (t.unselectable = ""), t } var i = fabric.document.documentElement.style, n = "userSelect" in i ? "userSelect" : "MozUserSelect" in i ? "MozUserSelect" : "WebkitUserSelect" in i ? "WebkitUserSelect" : "KhtmlUserSelect" in i ? "KhtmlUserSelect" : ""; fabric.util.makeElementUnselectable = t, fabric.util.makeElementSelectable = e }(), fabric.util.setImageSmoothing = h, fabric.util.getById = t, fabric.util.toArray = f, fabric.util.addClass = i, fabric.util.makeElement = e, fabric.util.wrapElement = n, fabric.util.getScrollLeftTop = r, fabric.util.getElementOffset = s, fabric.util.getNodeCanvas = a, fabric.util.cleanUpJsdomNode = o }(); !function () { function t(t, e) { return t + (/\?/.test(t) ? "&" : "?") + e } function e() { } function i(i, n) { n || (n = {}); var r = n.method ? n.method.toUpperCase() : "GET", s = n.onComplete || function () { }, a = new fabric.window.XMLHttpRequest, o = n.body || n.parameters; return a.onreadystatechange = function () { 4 === a.readyState && (s(a), a.onreadystatechange = e) }, "GET" === r && (o = null, "string" == typeof n.parameters && (i = t(i, n.parameters))), a.open(r, i, !0), ("POST" === r || "PUT" === r) && a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), a.send(o), a } fabric.util.request = i }(); fabric.log = console.log, fabric.warn = console.warn; !function () { function t() { return !1 } function e(t, e, i, n) { return -i * Math.cos(t / n * (Math.PI / 2)) + i + e } function i(i) { i || (i = {}); var r, o = !1, c = function () { var t = fabric.runningAnimations.indexOf(r); return t > -1 && fabric.runningAnimations.splice(t, 1)[0] }; return r = s(a(i), { cancel: function () { return o = !0, c() }, currentValue: "startValue" in i ? i.startValue : 0, completionRate: 0, durationRate: 0 }), fabric.runningAnimations.push(r), n(function (s) { var a, h = s || +new Date, l = i.duration || 500, f = h + l, u = i.onChange || t, d = i.abort || t, p = i.onComplete || t, g = i.easing || e, m = "startValue" in i ? i.startValue.length > 0 : !1, v = "startValue" in i ? i.startValue : 0, y = "endValue" in i ? i.endValue : 100, b = i.byValue || (m ? v.map(function (t, e) { return y[e] - v[e] }) : y - v); i.onStart && i.onStart(), function _(t) { a = t || +new Date; var e = a > f ? l : a - h, i = e / l, s = m ? v.map(function (t, i) { return g(e, v[i], b[i], l) }) : g(e, v, b, l), x = Math.abs(m ? (s[0] - v[0]) / b[0] : (s - v) / b); return r.currentValue = m ? s.slice() : s, r.completionRate = x, r.durationRate = i, o ? void 0 : d(s, x, i) ? void c() : a > f ? (r.currentValue = m ? y.slice() : y, r.completionRate = 1, r.durationRate = 1, u(m ? y.slice() : y, 1, 1), p(y, 1, 1), void c()) : (u(s, x, i), void n(_)) }(h) }), r.cancel } function n() { return c.apply(fabric.window, arguments) } function r() { return h.apply(fabric.window, arguments) } var s = fabric.util.object.extend, a = fabric.util.object.clone, o = []; fabric.util.object.extend(o, { cancelAll: function () { var t = this.splice(0); return t.forEach(function (t) { t.cancel() }), t }, cancelByCanvas: function (t) { if (!t) return []; var e = this.filter(function (e) { return "object" == typeof e.target && e.target.canvas === t }); return e.forEach(function (t) { t.cancel() }), e }, cancelByTarget: function (t) { var e = this.findAnimationsByTarget(t); return e.forEach(function (t) { t.cancel() }), e }, findAnimationIndex: function (t) { return this.indexOf(this.findAnimation(t)) }, findAnimation: function (t) { return this.find(function (e) { return e.cancel === t }) }, findAnimationsByTarget: function (t) { return t ? this.filter(function (e) { return e.target === t }) : [] } }); var c = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function (t) { return fabric.window.setTimeout(t, 1e3 / 60) }, h = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout; fabric.util.animate = i, fabric.util.requestAnimFrame = n, fabric.util.cancelAnimFrame = r, fabric.runningAnimations = o }(); !function () { function t(t, e, i) { var n = "rgba(" + parseInt(t[0] + i * (e[0] - t[0]), 10) + "," + parseInt(t[1] + i * (e[1] - t[1]), 10) + "," + parseInt(t[2] + i * (e[2] - t[2]), 10); return n += "," + (t && e ? parseFloat(t[3] + i * (e[3] - t[3])) : 1), n += ")" } function e(e, i, n, r) { var s = new fabric.Color(e).getSource(), a = new fabric.Color(i).getSource(), o = r.onComplete, c = r.onChange; return r = r || {}, fabric.util.animate(fabric.util.object.extend(r, { duration: n || 500, startValue: s, endValue: a, byValue: a, easing: function (e, i, n, s) { var a = r.colorEasing ? r.colorEasing(e, s) : 1 - Math.cos(e / s * (Math.PI / 2)); return t(i, n, a) }, onComplete: function (e, i, n) { return o ? o(t(a, a, 0), i, n) : void 0 }, onChange: function (e, i, n) { if (c) { if (Array.isArray(e)) return c(t(e, e, 0), i, n); c(e, i, n) } } })) } fabric.util.animateColor = e }(); !function () { function t(t, e, i, n) { return t < Math.abs(e) ? (t = e, n = i / 4) : n = 0 === e && 0 === t ? i / (2 * Math.PI) * Math.asin(1) : i / (2 * Math.PI) * Math.asin(e / t), { a: t, c: e, p: i, s: n } } function e(t, e, i) { return t.a * Math.pow(2, 10 * (e -= 1)) * Math.sin(2 * (e * i - t.s) * Math.PI / t.p) } function i(t, e, i, n) { return i * ((t = t / n - 1) * t * t + 1) + e } function n(t, e, i, n) { return t /= n / 2, 1 > t ? i / 2 * t * t * t + e : i / 2 * ((t -= 2) * t * t + 2) + e } function r(t, e, i, n) { return i * (t /= n) * t * t * t + e } function s(t, e, i, n) { return -i * ((t = t / n - 1) * t * t * t - 1) + e } function a(t, e, i, n) { return t /= n / 2, 1 > t ? i / 2 * t * t * t * t + e : -i / 2 * ((t -= 2) * t * t * t - 2) + e } function o(t, e, i, n) { return i * (t /= n) * t * t * t * t + e } function c(t, e, i, n) { return i * ((t = t / n - 1) * t * t * t * t + 1) + e } function h(t, e, i, n) { return t /= n / 2, 1 > t ? i / 2 * t * t * t * t * t + e : i / 2 * ((t -= 2) * t * t * t * t + 2) + e } function l(t, e, i, n) { return -i * Math.cos(t / n * (Math.PI / 2)) + i + e } function f(t, e, i, n) { return i * Math.sin(t / n * (Math.PI / 2)) + e } function u(t, e, i, n) { return -i / 2 * (Math.cos(Math.PI * t / n) - 1) + e } function d(t, e, i, n) { return 0 === t ? e : i * Math.pow(2, 10 * (t / n - 1)) + e } function p(t, e, i, n) { return t === n ? e + i : i * (-Math.pow(2, -10 * t / n) + 1) + e } function g(t, e, i, n) { return 0 === t ? e : t === n ? e + i : (t /= n / 2, 1 > t ? i / 2 * Math.pow(2, 10 * (t - 1)) + e : i / 2 * (-Math.pow(2, -10 * --t) + 2) + e) } function m(t, e, i, n) { return -i * (Math.sqrt(1 - (t /= n) * t) - 1) + e } function v(t, e, i, n) { return i * Math.sqrt(1 - (t = t / n - 1) * t) + e } function y(t, e, i, n) { return t /= n / 2, 1 > t ? -i / 2 * (Math.sqrt(1 - t * t) - 1) + e : i / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + e } function b(i, n, r, s) { var a = 1.70158, o = 0, c = r; if (0 === i) return n; if (i /= s, 1 === i) return n + r; o || (o = .3 * s); var h = t(c, r, o, a); return -e(h, i, s) + n } function _(e, i, n, r) { var s = 1.70158, a = 0, o = n; if (0 === e) return i; if (e /= r, 1 === e) return i + n; a || (a = .3 * r); var c = t(o, n, a, s); return c.a * Math.pow(2, -10 * e) * Math.sin(2 * (e * r - c.s) * Math.PI / c.p) + c.c + i } function x(i, n, r, s) { var a = 1.70158, o = 0, c = r; if (0 === i) return n; if (i /= s / 2, 2 === i) return n + r; o || (o = .3 * s * 1.5); var h = t(c, r, o, a); return 1 > i ? -.5 * e(h, i, s) + n : h.a * Math.pow(2, -10 * (i -= 1)) * Math.sin(2 * (i * s - h.s) * Math.PI / h.p) * .5 + h.c + n } function S(t, e, i, n, r) { return void 0 === r && (r = 1.70158), i * (t /= n) * t * ((r + 1) * t - r) + e } function C(t, e, i, n, r) { return void 0 === r && (r = 1.70158), i * ((t = t / n - 1) * t * ((r + 1) * t + r) + 1) + e } function T(t, e, i, n, r) { return void 0 === r && (r = 1.70158), t /= n / 2, 1 > t ? i / 2 * t * t * (((r *= 1.525) + 1) * t - r) + e : i / 2 * ((t -= 2) * t * (((r *= 1.525) + 1) * t + r) + 2) + e } function w(t, e, i, n) { return i - O(n - t, 0, i, n) + e } function O(t, e, i, n) { return (t /= n) < 1 / 2.75 ? 7.5625 * i * t * t + e : 2 / 2.75 > t ? i * (7.5625 * (t -= 1.5 / 2.75) * t + .75) + e : 2.5 / 2.75 > t ? i * (7.5625 * (t -= 2.25 / 2.75) * t + .9375) + e : i * (7.5625 * (t -= 2.625 / 2.75) * t + .984375) + e } function E(t, e, i, n) { return n / 2 > t ? .5 * w(2 * t, 0, i, n) + e : .5 * O(2 * t - n, 0, i, n) + .5 * i + e } fabric.util.ease = { easeInQuad: function (t, e, i, n) { return i * (t /= n) * t + e }, easeOutQuad: function (t, e, i, n) { return -i * (t /= n) * (t - 2) + e }, easeInOutQuad: function (t, e, i, n) { return t /= n / 2, 1 > t ? i / 2 * t * t + e : -i / 2 * (--t * (t - 2) - 1) + e }, easeInCubic: function (t, e, i, n) { return i * (t /= n) * t * t + e }, easeOutCubic: i, easeInOutCubic: n, easeInQuart: r, easeOutQuart: s, easeInOutQuart: a, easeInQuint: o, easeOutQuint: c, easeInOutQuint: h, easeInSine: l, easeOutSine: f, easeInOutSine: u, easeInExpo: d, easeOutExpo: p, easeInOutExpo: g, easeInCirc: m, easeOutCirc: v, easeInOutCirc: y, easeInElastic: b, easeOutElastic: _, easeInOutElastic: x, easeInBack: S, easeOutBack: C, easeInOutBack: T, easeInBounce: w, easeOutBounce: O, easeInOutBounce: E } }(); !function (t) { "use strict"; function e(t) { return t in E ? E[t] : t } function i(t, e, i, r) { var n, s = Array.isArray(e); if ("fill" !== t && "stroke" !== t || "none" !== e) { if ("strokeUniform" === t) return "non-scaling-stroke" === e; if ("strokeDashArray" === t) e = "none" === e ? null : e.replace(/,/g, " ").split(/\s+/).map(parseFloat); else if ("transformMatrix" === t) e = i && i.transformMatrix ? S(i.transformMatrix, v.parseTransformAttribute(e)) : v.parseTransformAttribute(e); else if ("visible" === t) e = "none" !== e && "hidden" !== e, i && i.visible === !1 && (e = !1); else if ("opacity" === t) e = parseFloat(e), i && "undefined" != typeof i.opacity && (e *= i.opacity); else if ("textAnchor" === t) e = "start" === e ? "left" : "end" === e ? "right" : "center"; else if ("charSpacing" === t) n = _(e, r) / r * 1e3; else if ("paintFirst" === t) { var a = e.indexOf("fill"), o = e.indexOf("stroke"), e = "fill"; a > -1 && o > -1 && a > o ? e = "stroke" : -1 === a && o > -1 && (e = "stroke") } else { if ("href" === t || "xlink:href" === t || "font" === t) return e; if ("imageSmoothing" === t) return "optimizeQuality" === e; n = s ? e.map(_) : _(e, r) } } else e = ""; return !s && isNaN(n) ? e : n } function r(t) { return new RegExp("^(" + t.join("|") + ")\\b", "i") } function n(t) { for (var e in k) if ("undefined" != typeof t[k[e]] && "" !== t[e]) { if ("undefined" == typeof t[e]) { if (!v.Object.prototype[e]) continue; t[e] = v.Object.prototype[e] } if (0 !== t[e].indexOf("url(")) { var i = new v.Color(t[e]); t[e] = i.setAlpha(x(i.getAlpha() * t[k[e]], 2)).toRgba() } } return t } function s(t, e) { var i, r, n, s, a = []; for (n = 0, s = e.length; s > n; n++)i = e[n], r = t.getElementsByTagName(i), a = a.concat(Array.prototype.slice.call(r)); return a } function a(t, e) { var i, r; t.replace(/;\s*$/, "").split(";").forEach(function (t) { var n = t.split(":"); i = n[0].trim().toLowerCase(), r = n[1].trim(), e[i] = r }) } function o(t, e) { var i, r; for (var n in t) "undefined" != typeof t[n] && (i = n.toLowerCase(), r = t[n], e[i] = r) } function c(t, e) { var i = {}; for (var r in v.cssRules[e]) if (l(t, r.split(" "))) for (var n in v.cssRules[e][r]) i[n] = v.cssRules[e][r][n]; return i } function l(t, e) { var i, r = !0; return i = f(t, e.pop()), i && e.length && (r = h(t, e)), i && r && 0 === e.length } function h(t, e) { for (var i, r = !0; t.parentNode && 1 === t.parentNode.nodeType && e.length;)r && (i = e.pop()), t = t.parentNode, r = f(t, i); return 0 === e.length } function f(t, e) { var i, r, n = t.nodeName, s = t.getAttribute("class"), a = t.getAttribute("id"); if (i = new RegExp("^" + n, "i"), e = e.replace(i, ""), a && e.length && (i = new RegExp("#" + a + "(?![a-zA-Z\\-]+)", "i"), e = e.replace(i, "")), s && e.length) for (s = s.split(" "), r = s.length; r--;)i = new RegExp("\\." + s[r] + "(?![a-zA-Z\\-]+)", "i"), e = e.replace(i, ""); return 0 === e.length } function u(t, e) { var i; if (t.getElementById && (i = t.getElementById(e)), i) return i; var r, n, s, a = t.getElementsByTagName("*"); for (n = 0, s = a.length; s > n; n++)if (r = a[n], e === r.getAttribute("id")) return r } function d(t) { for (var e = s(t, ["use", "svg:use"]), i = 0; e.length && i < e.length;) { var r = e[i], n = r.getAttribute("xlink:href") || r.getAttribute("href"); if (null === n) return; var a, o, c, l, h, f = n.slice(1), d = r.getAttribute("x") || 0, g = r.getAttribute("y") || 0, m = u(t, f).cloneNode(!0), y = (m.getAttribute("transform") || "") + " translate(" + d + ", " + g + ")", b = e.length, x = v.svgNS; if (p(m), /^svg$/i.test(m.nodeName)) { var _ = m.ownerDocument.createElementNS(x, "g"); for (c = 0, l = m.attributes, h = l.length; h > c; c++)o = l.item(c), _.setAttributeNS(x, o.nodeName, o.nodeValue); for (; m.firstChild;)_.appendChild(m.firstChild); m = _ } for (c = 0, l = r.attributes, h = l.length; h > c; c++)o = l.item(c), "x" !== o.nodeName && "y" !== o.nodeName && "xlink:href" !== o.nodeName && "href" !== o.nodeName && ("transform" === o.nodeName ? y = o.nodeValue + " " + y : m.setAttribute(o.nodeName, o.nodeValue)); m.setAttribute("transform", y), m.setAttribute("instantiated_by_use", "1"), m.removeAttribute("id"), a = r.parentNode, a.replaceChild(m, r), e.length === b && i++ } } function p(t) { if (!v.svgViewBoxElementsRegEx.test(t.nodeName)) return {}; var e, i, r, n, s = t.getAttribute("viewBox"), a = 1, o = 1, c = 0, l = 0, h = t.getAttribute("width"), f = t.getAttribute("height"), u = t.getAttribute("x") || 0, d = t.getAttribute("y") || 0, p = t.getAttribute("preserveAspectRatio") || "", g = !s || !(s = s.match(M)), m = !h || !f || "100%" === h || "100%" === f, y = g && m, b = {}, x = "", S = 0, C = 0; if (b.width = 0, b.height = 0, b.toBeParsed = y, g && (u || d) && t.parentNode && "#document" !== t.parentNode.nodeName && (x = " translate(" + _(u) + " " + _(d) + ") ", r = (t.getAttribute("transform") || "") + x, t.setAttribute("transform", r), t.removeAttribute("x"), t.removeAttribute("y")), y) return b; if (g) return b.width = _(h), b.height = _(f), b; if (c = -parseFloat(s[1]), l = -parseFloat(s[2]), e = parseFloat(s[3]), i = parseFloat(s[4]), b.minX = c, b.minY = l, b.viewBoxWidth = e, b.viewBoxHeight = i, m ? (b.width = e, b.height = i) : (b.width = _(h), b.height = _(f), a = b.width / e, o = b.height / i), p = v.util.parsePreserveAspectRatioAttribute(p), "none" !== p.alignX && ("meet" === p.meetOrSlice && (o = a = a > o ? o : a), "slice" === p.meetOrSlice && (o = a = a > o ? a : o), S = b.width - e * a, C = b.height - i * a, "Mid" === p.alignX && (S /= 2), "Mid" === p.alignY && (C /= 2), "Min" === p.alignX && (S = 0), "Min" === p.alignY && (C = 0)), 1 === a && 1 === o && 0 === c && 0 === l && 0 === u && 0 === d) return b; if ((u || d) && "#document" !== t.parentNode.nodeName && (x = " translate(" + _(u) + " " + _(d) + ") "), r = x + " matrix(" + a + " 0 0 " + o + " " + (c * a + S) + " " + (l * o + C) + ") ", "svg" === t.nodeName) { for (n = t.ownerDocument.createElementNS(v.svgNS, "g"); t.firstChild;)n.appendChild(t.firstChild); t.appendChild(n) } else n = t, n.removeAttribute("x"), n.removeAttribute("y"), r = n.getAttribute("transform") + r; return n.setAttribute("transform", r), b } function g(t, e) { for (; t && (t = t.parentNode);)if (t.nodeName && e.test(t.nodeName.replace("svg:", "")) && !t.getAttribute("instantiated_by_use")) return !0; return !1 } function m(t, e) { var i = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], r = "xlink:href", n = e.getAttribute(r).slice(1), s = u(t, n); if (s && s.getAttribute(r) && m(t, s), i.forEach(function (t) { s && !e.hasAttribute(t) && s.hasAttribute(t) && e.setAttribute(t, s.getAttribute(t)) }), !e.children.length) for (var a = s.cloneNode(!0); a.firstChild;)e.appendChild(a.firstChild); e.removeAttribute(r) } var v = t.fabric || (t.fabric = {}), y = v.util.object.extend, b = v.util.object.clone, x = v.util.toFixed, _ = v.util.parseUnit, S = v.util.multiplyTransformMatrices, C = ["path", "circle", "polygon", "polyline", "ellipse", "rect", "line", "image", "text"], T = ["symbol", "image", "marker", "pattern", "view", "svg"], w = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], O = ["symbol", "g", "a", "svg", "clipPath", "defs"], E = { cx: "left", x: "left", r: "radius", cy: "top", y: "top", display: "visible", visibility: "visible", transform: "transformMatrix", "fill-opacity": "fillOpacity", "fill-rule": "fillRule", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "letter-spacing": "charSpacing", "paint-order": "paintFirst", "stroke-dasharray": "strokeDashArray", "stroke-dashoffset": "strokeDashOffset", "stroke-linecap": "strokeLineCap", "stroke-linejoin": "strokeLineJoin", "stroke-miterlimit": "strokeMiterLimit", "stroke-opacity": "strokeOpacity", "stroke-width": "strokeWidth", "text-decoration": "textDecoration", "text-anchor": "textAnchor", opacity: "opacity", "clip-path": "clipPath", "clip-rule": "clipRule", "vector-effect": "strokeUniform", "image-rendering": "imageSmoothing" }, k = { stroke: "strokeOpacity", fill: "fillOpacity" }, L = "font-size", A = "clip-path"; v.svgValidTagNamesRegEx = r(C), v.svgViewBoxElementsRegEx = r(T), v.svgInvalidAncestorsRegEx = r(w), v.svgValidParentsRegEx = r(O), v.cssRules = {}, v.gradientDefs = {}, v.clipPaths = {}, v.parseTransformAttribute = function () { function t(t, e) { var i = v.util.cos(e[0]), r = v.util.sin(e[0]), n = 0, s = 0; 3 === e.length && (n = e[1], s = e[2]), t[0] = i, t[1] = r, t[2] = -r, t[3] = i, t[4] = n - (i * n - r * s), t[5] = s - (r * n + i * s) } function e(t, e) { var i = e[0], r = 2 === e.length ? e[1] : e[0]; t[0] = i, t[3] = r } function i(t, e, i) { t[i] = Math.tan(v.util.degreesToRadians(e[0])) } function r(t, e) { t[4] = e[0], 2 === e.length && (t[5] = e[1]) } var n = v.iMatrix, s = v.reNum, a = v.commaWsp, o = "(?:(skewX)\\s*\\(\\s*(" + s + ")\\s*\\))", c = "(?:(skewY)\\s*\\(\\s*(" + s + ")\\s*\\))", l = "(?:(rotate)\\s*\\(\\s*(" + s + ")(?:" + a + "(" + s + ")" + a + "(" + s + "))?\\s*\\))", h = "(?:(scale)\\s*\\(\\s*(" + s + ")(?:" + a + "(" + s + "))?\\s*\\))", f = "(?:(translate)\\s*\\(\\s*(" + s + ")(?:" + a + "(" + s + "))?\\s*\\))", u = "(?:(matrix)\\s*\\(\\s*(" + s + ")" + a + "(" + s + ")" + a + "(" + s + ")" + a + "(" + s + ")" + a + "(" + s + ")" + a + "(" + s + ")\\s*\\))", d = "(?:" + u + "|" + f + "|" + h + "|" + l + "|" + o + "|" + c + ")", p = "(?:" + d + "(?:" + a + "*" + d + ")*)", g = "^\\s*(?:" + p + "?)\\s*$", m = new RegExp(g), y = new RegExp(d, "g"); return function (s) { var a = n.concat(), o = []; if (!s || s && !m.test(s)) return a; s.replace(y, function (s) { var c = new RegExp(d).exec(s).filter(function (t) { return !!t }), l = c[1], h = c.slice(2).map(parseFloat); switch (l) { case "translate": r(a, h); break; case "rotate": h[0] = v.util.degreesToRadians(h[0]), t(a, h); break; case "scale": e(a, h); break; case "skewX": i(a, h, 2); break; case "skewY": i(a, h, 1); break; case "matrix": a = h }o.push(a.concat()), a = n.concat() }); for (var c = o[0]; o.length > 1;)o.shift(), c = v.util.multiplyTransformMatrices(c, o[0]); return c } }(); var M = new RegExp("^\\s*(" + v.reNum + "+)\\s*,?\\s*(" + v.reNum + "+)\\s*,?\\s*(" + v.reNum + "+)\\s*,?\\s*(" + v.reNum + "+)\\s*$"); v.parseSVGDocument = function (t, e, i, r) { if (t) { d(t); var n, s, a = v.Object.__uid++, o = p(t), c = v.util.toArray(t.getElementsByTagName("*")); if (o.crossOrigin = r && r.crossOrigin, o.svgUid = a, 0 === c.length && v.isLikelyNode) { c = t.selectNodes('//*[name(.)!="svg"]'); var l = []; for (n = 0, s = c.length; s > n; n++)l[n] = c[n]; c = l } var h = c.filter(function (t) { return p(t), v.svgValidTagNamesRegEx.test(t.nodeName.replace("svg:", "")) && !g(t, v.svgInvalidAncestorsRegEx) }); if (!h || h && !h.length) return void (e && e([], {})); var f = {}; c.filter(function (t) { return "clipPath" === t.nodeName.replace("svg:", "") }).forEach(function (t) { var e = t.getAttribute("id"); f[e] = v.util.toArray(t.getElementsByTagName("*")).filter(function (t) { return v.svgValidTagNamesRegEx.test(t.nodeName.replace("svg:", "")) }) }), v.gradientDefs[a] = v.getGradientDefs(t), v.cssRules[a] = v.getCSSRules(t), v.clipPaths[a] = f, v.parseElements(h, function (t, i) { e && (e(t, o, i, c), delete v.gradientDefs[a], delete v.cssRules[a], delete v.clipPaths[a]) }, b(o), i, r) } }; var P = new RegExp("(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + v.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + v.reNum + "))?\\s+(.*)"); y(v, { parseFontDeclaration: function (t, e) { var i = t.match(P); if (i) { var r = i[1], n = i[3], s = i[4], a = i[5], o = i[6]; r && (e.fontStyle = r), n && (e.fontWeight = isNaN(parseFloat(n)) ? n : parseFloat(n)), s && (e.fontSize = _(s)), o && (e.fontFamily = o), a && (e.lineHeight = "normal" === a ? 1 : a) } }, getGradientDefs: function (t) { var e, i = ["linearGradient", "radialGradient", "svg:linearGradient", "svg:radialGradient"], r = s(t, i), n = 0, a = {}; for (n = r.length; n--;)e = r[n], e.getAttribute("xlink:href") && m(t, e), a[e.getAttribute("id")] = e; return a }, parseAttributes: function (t, r, s) { if (t) { var a, o, l, h = {}; "undefined" == typeof s && (s = t.getAttribute("svgUid")), t.parentNode && v.svgValidParentsRegEx.test(t.parentNode.nodeName) && (h = v.parseAttributes(t.parentNode, r, s)); var f = r.reduce(function (e, i) { return a = t.getAttribute(i), a && (e[i] = a), e }, {}), u = y(c(t, s), v.parseStyleAttribute(t)); f = y(f, u), u[A] && t.setAttribute(A, u[A]), o = l = h.fontSize || v.Text.DEFAULT_SVG_FONT_SIZE, f[L] && (f[L] = o = _(f[L], l)); var d, p, g = {}; for (var m in f) d = e(m), p = i(d, f[m], h, o), g[d] = p; g && g.font && v.parseFontDeclaration(g.font, g); var b = y(h, g); return v.svgValidParentsRegEx.test(t.nodeName) ? b : n(b) } }, parseElements: function (t, e, i, r, n) { new v.ElementsParser(t, e, i, r, n).parse() }, parseStyleAttribute: function (t) { var e = {}, i = t.getAttribute("style"); return i ? ("string" == typeof i ? a(i, e) : o(i, e), e) : e }, parsePointsAttribute: function (t) { if (!t) return null; t = t.replace(/,/g, " ").trim(), t = t.split(/\s+/); var e, i, r = []; for (e = 0, i = t.length; i > e; e += 2)r.push({ x: parseFloat(t[e]), y: parseFloat(t[e + 1]) }); return r }, getCSSRules: function (t) { var e, i, r, n = t.getElementsByTagName("style"), s = {}; for (e = 0, i = n.length; i > e; e++) { var a = n[e].textContent; a = a.replace(/\/\*[\s\S]*?\*\//g, ""), "" !== a.trim() && (r = a.split("}"), r = r.filter(function (t) { return t.trim() }), r.forEach(function (t) { var r = t.split("{"), n = {}, a = r[1].trim(), o = a.split(";").filter(function (t) { return t.trim() }); for (e = 0, i = o.length; i > e; e++) { var c = o[e].split(":"), l = c[0].trim(), h = c[1].trim(); n[l] = h } t = r[0].trim(), t.split(",").forEach(function (t) { t = t.replace(/^svg/i, "").trim(), "" !== t && (s[t] ? v.util.object.extend(s[t], n) : s[t] = v.util.object.clone(n)) }) })) } return s }, loadSVGFromURL: function (t, e, i, r) { function n(t) { var n = t.responseXML; return n && n.documentElement ? void v.parseSVGDocument(n.documentElement, function (t, i, r, n) { e && e(t, i, r, n) }, i, r) : (e && e(null), !1) } t = t.replace(/^\n\s*/, "").trim(), new v.util.request(t, { method: "get", onComplete: n }) }, loadSVGFromString: function (t, e, i, r) { var n = new v.window.DOMParser, s = n.parseFromString(t.trim(), "text/xml"); v.parseSVGDocument(s.documentElement, function (t, i, r, n) { e(t, i, r, n) }, i, r) } }) }("undefined" != typeof exports ? exports : this); fabric.ElementsParser = function (t, e, i, r, n, s) { this.elements = t, this.callback = e, this.options = i, this.reviver = r, this.svgUid = i && i.svgUid || 0, this.parsingOptions = n, this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g, this.doc = s }, function (t) { t.parse = function () { this.instances = new Array(this.elements.length), this.numElements = this.elements.length, this.createObjects() }, t.createObjects = function () { var t = this; this.elements.forEach(function (e, i) { e.setAttribute("svgUid", t.svgUid), t.createObject(e, i) }) }, t.findTag = function (t) { return fabric[fabric.util.string.capitalize(t.tagName.replace("svg:", ""))] }, t.createObject = function (t, e) { var i = this.findTag(t); if (i && i.fromElement) try { i.fromElement(t, this.createCallback(e, t), this.options) } catch (r) { fabric.log(r) } else this.checkIfDone() }, t.createCallback = function (t, e) { var i = this; return function (r) { var n; i.resolveGradient(r, e, "fill"), i.resolveGradient(r, e, "stroke"), r instanceof fabric.Image && r._originalElement && (n = r.parsePreserveAspectRatioAttribute(e)), r._removeTransformMatrix(n), i.resolveClipPath(r, e), i.reviver && i.reviver(e, r), i.instances[t] = r, i.checkIfDone() } }, t.extractPropertyDefinition = function (t, e, i) { var r = t[e], n = this.regexUrl; if (n.test(r)) { n.lastIndex = 0; var s = n.exec(r)[1]; return n.lastIndex = 0, fabric[i][this.svgUid][s] } }, t.resolveGradient = function (t, e, i) { var r = this.extractPropertyDefinition(t, i, "gradientDefs"); if (r) { var n = e.getAttribute(i + "-opacity"), s = fabric.Gradient.fromElement(r, t, n, this.options); t.set(i, s) } }, t.createClipPathCallback = function (t, e) { return function (t) { t._removeTransformMatrix(), t.fillRule = t.clipRule, e.push(t) } }, t.resolveClipPath = function (t, e) { var i, r, n, s, a, o, c = this.extractPropertyDefinition(t, "clipPath", "clipPaths"); if (c) { s = [], n = fabric.util.invertTransform(t.calcTransformMatrix()); for (var l = c[0].parentNode, h = e; h.parentNode && h.getAttribute("clip-path") !== t.clipPath;)h = h.parentNode; h.parentNode.appendChild(l); for (var f = 0; f < c.length; f++)i = c[f], r = this.findTag(i), r.fromElement(i, this.createClipPathCallback(t, s), this.options); c = 1 === s.length ? s[0] : new fabric.Group(s), a = fabric.util.multiplyTransformMatrices(n, c.calcTransformMatrix()), c.clipPath && this.resolveClipPath(c, h); var o = fabric.util.qrDecompose(a); c.flipX = !1, c.flipY = !1, c.set("scaleX", o.scaleX), c.set("scaleY", o.scaleY), c.angle = o.angle, c.skewX = o.skewX, c.skewY = 0, c.setPositionByOrigin({ x: o.translateX, y: o.translateY }, "center", "center"), t.clipPath = c } else delete t.clipPath }, t.checkIfDone = function () { 0 === --this.numElements && (this.instances = this.instances.filter(function (t) { return null != t }), this.callback(this.instances, this.elements)) } }(fabric.ElementsParser.prototype); !function (t) { "use strict"; function e(t, e) { this.x = t, this.y = e } var i = t.fabric || (t.fabric = {}); return i.Point ? void i.warn("fabric.Point is already defined") : (i.Point = e, void (e.prototype = { type: "point", constructor: e, add: function (t) { return new e(this.x + t.x, this.y + t.y) }, addEquals: function (t) { return this.x += t.x, this.y += t.y, this }, scalarAdd: function (t) { return new e(this.x + t, this.y + t) }, scalarAddEquals: function (t) { return this.x += t, this.y += t, this }, subtract: function (t) { return new e(this.x - t.x, this.y - t.y) }, subtractEquals: function (t) { return this.x -= t.x, this.y -= t.y, this }, scalarSubtract: function (t) { return new e(this.x - t, this.y - t) }, scalarSubtractEquals: function (t) { return this.x -= t, this.y -= t, this }, multiply: function (t) { return new e(this.x * t, this.y * t) }, multiplyEquals: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return new e(this.x / t, this.y / t) }, divideEquals: function (t) { return this.x /= t, this.y /= t, this }, eq: function (t) { return this.x === t.x && this.y === t.y }, lt: function (t) { return this.x < t.x && this.y < t.y }, lte: function (t) { return this.x <= t.x && this.y <= t.y }, gt: function (t) { return this.x > t.x && this.y > t.y }, gte: function (t) { return this.x >= t.x && this.y >= t.y }, lerp: function (t, i) { return "undefined" == typeof i && (i = .5), i = Math.max(Math.min(1, i), 0), new e(this.x + (t.x - this.x) * i, this.y + (t.y - this.y) * i) }, distanceFrom: function (t) { var e = this.x - t.x, i = this.y - t.y; return Math.sqrt(e * e + i * i) }, midPointFrom: function (t) { return this.lerp(t) }, min: function (t) { return new e(Math.min(this.x, t.x), Math.min(this.y, t.y)) }, max: function (t) { return new e(Math.max(this.x, t.x), Math.max(this.y, t.y)) }, toString: function () { return this.x + "," + this.y }, setXY: function (t, e) { return this.x = t, this.y = e, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setFromPoint: function (t) { return this.x = t.x, this.y = t.y, this }, swap: function (t) { var e = this.x, i = this.y; this.x = t.x, this.y = t.y, t.x = e, t.y = i }, clone: function () { return new e(this.x, this.y) } })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t) { this.status = t, this.points = [] } var i = t.fabric || (t.fabric = {}); return i.Intersection ? void i.warn("fabric.Intersection is already defined") : (i.Intersection = e, i.Intersection.prototype = { constructor: e, appendPoint: function (t) { return this.points.push(t), this }, appendPoints: function (t) { return this.points = this.points.concat(t), this } }, i.Intersection.intersectLineLine = function (t, r, n, s) { var a, o = (s.x - n.x) * (t.y - n.y) - (s.y - n.y) * (t.x - n.x), c = (r.x - t.x) * (t.y - n.y) - (r.y - t.y) * (t.x - n.x), l = (s.y - n.y) * (r.x - t.x) - (s.x - n.x) * (r.y - t.y); if (0 !== l) { var h = o / l, u = c / l; h >= 0 && 1 >= h && u >= 0 && 1 >= u ? (a = new e("Intersection"), a.appendPoint(new i.Point(t.x + h * (r.x - t.x), t.y + h * (r.y - t.y)))) : a = new e } else a = new e(0 === o || 0 === c ? "Coincident" : "Parallel"); return a }, i.Intersection.intersectLinePolygon = function (t, i, r) { var n, s, a, o, c = new e, l = r.length; for (o = 0; l > o; o++)n = r[o], s = r[(o + 1) % l], a = e.intersectLineLine(t, i, n, s), c.appendPoints(a.points); return c.points.length > 0 && (c.status = "Intersection"), c }, i.Intersection.intersectPolygonPolygon = function (t, i) { var r, n = new e, s = t.length; for (r = 0; s > r; r++) { var a = t[r], o = t[(r + 1) % s], c = e.intersectLinePolygon(a, o, i); n.appendPoints(c.points) } return n.points.length > 0 && (n.status = "Intersection"), n }, void (i.Intersection.intersectPolygonRectangle = function (t, r, n) { var s = r.min(n), a = r.max(n), o = new i.Point(a.x, s.y), c = new i.Point(s.x, a.y), l = e.intersectLinePolygon(s, o, t), h = e.intersectLinePolygon(o, a, t), u = e.intersectLinePolygon(a, c, t), f = e.intersectLinePolygon(c, s, t), d = new e; return d.appendPoints(l.points), d.appendPoints(h.points), d.appendPoints(u.points), d.appendPoints(f.points), d.points.length > 0 && (d.status = "Intersection"), d })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t) { t ? this._tryParsingColor(t) : this.setSource([0, 0, 0, 1]) } function i(t, e, i) { return 0 > i && (i += 1), i > 1 && (i -= 1), 1 / 6 > i ? t + 6 * (e - t) * i : .5 > i ? e : 2 / 3 > i ? t + (e - t) * (2 / 3 - i) * 6 : t } var r = t.fabric || (t.fabric = {}); return r.Color ? void r.warn("fabric.Color is already defined.") : (r.Color = e, r.Color.prototype = { _tryParsingColor: function (t) { var i; t in e.colorNameMap && (t = e.colorNameMap[t]), "transparent" === t && (i = [255, 255, 255, 0]), i || (i = e.sourceFromHex(t)), i || (i = e.sourceFromRgb(t)), i || (i = e.sourceFromHsl(t)), i || (i = [0, 0, 0, 1]), i && this.setSource(i) }, _rgbToHsl: function (t, e, i) { t /= 255, e /= 255, i /= 255; var n, s, a, o = r.util.array.max([t, e, i]), c = r.util.array.min([t, e, i]); if (a = (o + c) / 2, o === c) n = s = 0; else { var l = o - c; switch (s = a > .5 ? l / (2 - o - c) : l / (o + c), o) { case t: n = (e - i) / l + (i > e ? 6 : 0); break; case e: n = (i - t) / l + 2; break; case i: n = (t - e) / l + 4 }n /= 6 } return [Math.round(360 * n), Math.round(100 * s), Math.round(100 * a)] }, getSource: function () { return this._source }, setSource: function (t) { this._source = t }, toRgb: function () { var t = this.getSource(); return "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")" }, toRgba: function () { var t = this.getSource(); return "rgba(" + t[0] + "," + t[1] + "," + t[2] + "," + t[3] + ")" }, toHsl: function () { var t = this.getSource(), e = this._rgbToHsl(t[0], t[1], t[2]); return "hsl(" + e[0] + "," + e[1] + "%," + e[2] + "%)" }, toHsla: function () { var t = this.getSource(), e = this._rgbToHsl(t[0], t[1], t[2]); return "hsla(" + e[0] + "," + e[1] + "%," + e[2] + "%," + t[3] + ")" }, toHex: function () { var t, e, i, r = this.getSource(); return t = r[0].toString(16), t = 1 === t.length ? "0" + t : t, e = r[1].toString(16), e = 1 === e.length ? "0" + e : e, i = r[2].toString(16), i = 1 === i.length ? "0" + i : i, t.toUpperCase() + e.toUpperCase() + i.toUpperCase() }, toHexa: function () { var t, e = this.getSource(); return t = Math.round(255 * e[3]), t = t.toString(16), t = 1 === t.length ? "0" + t : t, this.toHex() + t.toUpperCase() }, getAlpha: function () { return this.getSource()[3] }, setAlpha: function (t) { var e = this.getSource(); return e[3] = t, this.setSource(e), this }, toGrayscale: function () { var t = this.getSource(), e = parseInt((.3 * t[0] + .59 * t[1] + .11 * t[2]).toFixed(0), 10), i = t[3]; return this.setSource([e, e, e, i]), this }, toBlackWhite: function (t) { var e = this.getSource(), i = (.3 * e[0] + .59 * e[1] + .11 * e[2]).toFixed(0), r = e[3]; return t = t || 127, i = Number(i) < Number(t) ? 0 : 255, this.setSource([i, i, i, r]), this }, overlayWith: function (t) { t instanceof e || (t = new e(t)); var i, r = [], n = this.getAlpha(), s = .5, a = this.getSource(), o = t.getSource(); for (i = 0; 3 > i; i++)r.push(Math.round(a[i] * (1 - s) + o[i] * s)); return r[3] = n, this.setSource(r), this } }, r.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i, r.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i, r.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i, r.Color.colorNameMap = { aliceblue: "#F0F8FF", antiquewhite: "#FAEBD7", aqua: "#00FFFF", aquamarine: "#7FFFD4", azure: "#F0FFFF", beige: "#F5F5DC", bisque: "#FFE4C4", black: "#000000", blanchedalmond: "#FFEBCD", blue: "#0000FF", blueviolet: "#8A2BE2", brown: "#A52A2A", burlywood: "#DEB887", cadetblue: "#5F9EA0", chartreuse: "#7FFF00", chocolate: "#D2691E", coral: "#FF7F50", cornflowerblue: "#6495ED", cornsilk: "#FFF8DC", crimson: "#DC143C", cyan: "#00FFFF", darkblue: "#00008B", darkcyan: "#008B8B", darkgoldenrod: "#B8860B", darkgray: "#A9A9A9", darkgrey: "#A9A9A9", darkgreen: "#006400", darkkhaki: "#BDB76B", darkmagenta: "#8B008B", darkolivegreen: "#556B2F", darkorange: "#FF8C00", darkorchid: "#9932CC", darkred: "#8B0000", darksalmon: "#E9967A", darkseagreen: "#8FBC8F", darkslateblue: "#483D8B", darkslategray: "#2F4F4F", darkslategrey: "#2F4F4F", darkturquoise: "#00CED1", darkviolet: "#9400D3", deeppink: "#FF1493", deepskyblue: "#00BFFF", dimgray: "#696969", dimgrey: "#696969", dodgerblue: "#1E90FF", firebrick: "#B22222", floralwhite: "#FFFAF0", forestgreen: "#228B22", fuchsia: "#FF00FF", gainsboro: "#DCDCDC", ghostwhite: "#F8F8FF", gold: "#FFD700", goldenrod: "#DAA520", gray: "#808080", grey: "#808080", green: "#008000", greenyellow: "#ADFF2F", honeydew: "#F0FFF0", hotpink: "#FF69B4", indianred: "#CD5C5C", indigo: "#4B0082", ivory: "#FFFFF0", khaki: "#F0E68C", lavender: "#E6E6FA", lavenderblush: "#FFF0F5", lawngreen: "#7CFC00", lemonchiffon: "#FFFACD", lightblue: "#ADD8E6", lightcoral: "#F08080", lightcyan: "#E0FFFF", lightgoldenrodyellow: "#FAFAD2", lightgray: "#D3D3D3", lightgrey: "#D3D3D3", lightgreen: "#90EE90", lightpink: "#FFB6C1", lightsalmon: "#FFA07A", lightseagreen: "#20B2AA", lightskyblue: "#87CEFA", lightslategray: "#778899", lightslategrey: "#778899", lightsteelblue: "#B0C4DE", lightyellow: "#FFFFE0", lime: "#00FF00", limegreen: "#32CD32", linen: "#FAF0E6", magenta: "#FF00FF", maroon: "#800000", mediumaquamarine: "#66CDAA", mediumblue: "#0000CD", mediumorchid: "#BA55D3", mediumpurple: "#9370DB", mediumseagreen: "#3CB371", mediumslateblue: "#7B68EE", mediumspringgreen: "#00FA9A", mediumturquoise: "#48D1CC", mediumvioletred: "#C71585", midnightblue: "#191970", mintcream: "#F5FFFA", mistyrose: "#FFE4E1", moccasin: "#FFE4B5", navajowhite: "#FFDEAD", navy: "#000080", oldlace: "#FDF5E6", olive: "#808000", olivedrab: "#6B8E23", orange: "#FFA500", orangered: "#FF4500", orchid: "#DA70D6", palegoldenrod: "#EEE8AA", palegreen: "#98FB98", paleturquoise: "#AFEEEE", palevioletred: "#DB7093", papayawhip: "#FFEFD5", peachpuff: "#FFDAB9", peru: "#CD853F", pink: "#FFC0CB", plum: "#DDA0DD", powderblue: "#B0E0E6", purple: "#800080", rebeccapurple: "#663399", red: "#FF0000", rosybrown: "#BC8F8F", royalblue: "#4169E1", saddlebrown: "#8B4513", salmon: "#FA8072", sandybrown: "#F4A460", seagreen: "#2E8B57", seashell: "#FFF5EE", sienna: "#A0522D", silver: "#C0C0C0", skyblue: "#87CEEB", slateblue: "#6A5ACD", slategray: "#708090", slategrey: "#708090", snow: "#FFFAFA", springgreen: "#00FF7F", steelblue: "#4682B4", tan: "#D2B48C", teal: "#008080", thistle: "#D8BFD8", tomato: "#FF6347", turquoise: "#40E0D0", violet: "#EE82EE", wheat: "#F5DEB3", white: "#FFFFFF", whitesmoke: "#F5F5F5", yellow: "#FFFF00", yellowgreen: "#9ACD32" }, r.Color.fromRgb = function (t) { return e.fromSource(e.sourceFromRgb(t)) }, r.Color.sourceFromRgb = function (t) { var i = t.match(e.reRGBa); if (i) { var r = parseInt(i[1], 10) / (/%$/.test(i[1]) ? 100 : 1) * (/%$/.test(i[1]) ? 255 : 1), n = parseInt(i[2], 10) / (/%$/.test(i[2]) ? 100 : 1) * (/%$/.test(i[2]) ? 255 : 1), s = parseInt(i[3], 10) / (/%$/.test(i[3]) ? 100 : 1) * (/%$/.test(i[3]) ? 255 : 1); return [parseInt(r, 10), parseInt(n, 10), parseInt(s, 10), i[4] ? parseFloat(i[4]) : 1] } }, r.Color.fromRgba = e.fromRgb, r.Color.fromHsl = function (t) { return e.fromSource(e.sourceFromHsl(t)) }, r.Color.sourceFromHsl = function (t) { var r = t.match(e.reHSLa); if (r) { var n, s, a, o = (parseFloat(r[1]) % 360 + 360) % 360 / 360, c = parseFloat(r[2]) / (/%$/.test(r[2]) ? 100 : 1), l = parseFloat(r[3]) / (/%$/.test(r[3]) ? 100 : 1); if (0 === c) n = s = a = l; else { var h = .5 >= l ? l * (c + 1) : l + c - l * c, u = 2 * l - h; n = i(u, h, o + 1 / 3), s = i(u, h, o), a = i(u, h, o - 1 / 3) } return [Math.round(255 * n), Math.round(255 * s), Math.round(255 * a), r[4] ? parseFloat(r[4]) : 1] } }, r.Color.fromHsla = e.fromHsl, r.Color.fromHex = function (t) { return e.fromSource(e.sourceFromHex(t)) }, r.Color.sourceFromHex = function (t) { if (t.match(e.reHex)) { var i = t.slice(t.indexOf("#") + 1), r = 3 === i.length || 4 === i.length, n = 8 === i.length || 4 === i.length, s = r ? i.charAt(0) + i.charAt(0) : i.substring(0, 2), a = r ? i.charAt(1) + i.charAt(1) : i.substring(2, 4), o = r ? i.charAt(2) + i.charAt(2) : i.substring(4, 6), c = n ? r ? i.charAt(3) + i.charAt(3) : i.substring(6, 8) : "FF"; return [parseInt(s, 16), parseInt(a, 16), parseInt(o, 16), parseFloat((parseInt(c, 16) / 255).toFixed(2))] } }, void (r.Color.fromSource = function (t) { var i = new e; return i.setSource(t), i })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t, e) { var i = t.angle + R(Math.atan2(e.y, e.x)) + 360; return Math.round(i % 360 / 45) } function i(t, e) { var i = e.transform.target, r = i.canvas, n = A.util.object.clone(e); n.target = i, r && r.fire("object:" + t, n), i.fire(t, e) } function r(t, e) { var i = e.canvas, r = i.uniScaleKey, n = t[r]; return i.uniformScaling && !n || !i.uniformScaling && n } function n(t) { return t.originX === H && t.originY === H } function a(t, e, i) { var r = t.lockScalingX, n = t.lockScalingY; return r && n ? !0 : !e && (r || n) && i ? !0 : r && "x" === e ? !0 : n && "y" === e ? !0 : !1 } function s(t, i, n) { var s = "not-allowed", o = r(t, n), c = ""; if (0 !== i.x && 0 === i.y ? c = "x" : 0 === i.x && 0 !== i.y && (c = "y"), a(n, c, o)) return s; var l = e(n, i); return D[l] + "-resize" } function o(t, i, r) { var n = "not-allowed"; if (0 !== i.x && r.lockSkewingY) return n; if (0 !== i.y && r.lockSkewingX) return n; var a = e(r, i) % 4; return M[a] + "-resize" } function c(t, e, i) { return t[i.canvas.altActionKey] ? P.skewCursorStyleHandler(t, e, i) : P.scaleCursorStyleHandler(t, e, i) } function l(t, e, i) { var r = t[i.canvas.altActionKey]; return 0 === e.x ? r ? "skewX" : "scaleY" : 0 === e.y ? r ? "skewY" : "scaleX" : void 0 } function h(t, e, i) { return i.lockRotation ? "not-allowed" : e.cursorStyle } function u(t, e, i, r) { return { e: t, transform: e, pointer: { x: i, y: r } } } function f(t) { return function (e, i, r, n) { var a = i.target, s = a.getCenterPoint(), o = a.translateToOriginPoint(s, i.originX, i.originY), c = t(e, i, r, n); return a.setPositionByOrigin(o, i.originX, i.originY), c } } function d(t, e) { return function (r, n, a, s) { var o = e(r, n, a, s); return o && i(t, u(r, n, a, s)), o } } function g(t, e, i, r, n) { var a = t.target, s = a.controls[t.corner], o = a.canvas.getZoom(), c = a.padding / o, l = a.toLocalPoint(new A.Point(r, n), e, i); return l.x >= c && (l.x -= c), l.x <= -c && (l.x += c), l.y >= c && (l.y -= c), l.y <= c && (l.y += c), l.x -= s.offsetX, l.y -= s.offsetY, l } function p(t) { return t.flipX !== t.flipY } function m(t, e, i, r, n) { if (0 !== t[e]) { var a = t._getTransformedDimensions()[r], s = n / a * t[i]; t.set(i, s) } } function v(t, e, i, r) { var n, a = e.target, s = a._getTransformedDimensions(0, a.skewY), o = g(e, e.originX, e.originY, i, r), c = Math.abs(2 * o.x) - s.x, l = a.skewX; 2 > c ? n = 0 : (n = R(Math.atan2(c / a.scaleX, s.y / a.scaleY)), e.originX === L && e.originY === j && (n = -n), e.originX === B && e.originY === I && (n = -n), p(a) && (n = -n)); var h = l !== n; if (h) { var u = a._getTransformedDimensions().y; a.set("skewX", n), m(a, "skewY", "scaleY", "y", u) } return h } function y(t, e, i, r) { var n, a = e.target, s = a._getTransformedDimensions(a.skewX, 0), o = g(e, e.originX, e.originY, i, r), c = Math.abs(2 * o.y) - s.y, l = a.skewY; 2 > c ? n = 0 : (n = R(Math.atan2(c / a.scaleY, s.x / a.scaleX)), e.originX === L && e.originY === j && (n = -n), e.originX === B && e.originY === I && (n = -n), p(a) && (n = -n)); var h = l !== n; if (h) { var u = a._getTransformedDimensions().x; a.set("skewY", n), m(a, "skewX", "scaleX", "x", u) } return h } function b(t, e, i, r) { var n, a = e.target, s = a.skewX, o = e.originY; if (a.lockSkewingX) return !1; if (0 === s) { var c = g(e, H, H, i, r); n = c.x > 0 ? L : B } else s > 0 && (n = o === I ? L : B), 0 > s && (n = o === I ? B : L), p(a) && (n = n === L ? B : L); e.originX = n; var l = d("skewing", f(v)); return l(t, e, i, r) } function x(t, e, i, r) { var n, a = e.target, s = a.skewY, o = e.originX; if (a.lockSkewingY) return !1; if (0 === s) { var c = g(e, H, H, i, r); n = c.y > 0 ? I : j } else s > 0 && (n = o === L ? I : j), 0 > s && (n = o === L ? j : I), p(a) && (n = n === I ? j : I); e.originY = n; var l = d("skewing", f(y)); return l(t, e, i, r) } function _(t, e, i, r) { var n = e, a = n.target, s = a.translateToOriginPoint(a.getCenterPoint(), n.originX, n.originY); if (a.lockRotation) return !1; var o = Math.atan2(n.ey - s.y, n.ex - s.x), c = Math.atan2(r - s.y, i - s.x), l = R(c - o + n.theta), h = !0; if (a.snapAngle > 0) { var u = a.snapAngle, f = a.snapThreshold || u, d = Math.ceil(l / u) * u, g = Math.floor(l / u) * u; Math.abs(l - g) < f ? l = g : Math.abs(l - d) < f && (l = d) } return 0 > l && (l = 360 + l), l %= 360, h = a.angle !== l, a.angle = l, h } function C(t, e, i, s, o) { o = o || {}; var c, l, h, u, f, d, p = e.target, m = p.lockScalingX, v = p.lockScalingY, y = o.by, b = r(t, p), x = a(p, y, b), _ = e.gestureScale; if (x) return !1; if (_) l = e.scaleX * _, h = e.scaleY * _; else { if (c = g(e, e.originX, e.originY, i, s), f = "y" !== y ? N(c.x) : 1, d = "x" !== y ? N(c.y) : 1, e.signX || (e.signX = f), e.signY || (e.signY = d), p.lockScalingFlip && (e.signX !== f || e.signY !== d)) return !1; if (u = p._getTransformedDimensions(), b && !y) { var C = Math.abs(c.x) + Math.abs(c.y), S = e.original, T = Math.abs(u.x * S.scaleX / p.scaleX) + Math.abs(u.y * S.scaleY / p.scaleY), w = C / T; l = S.scaleX * w, h = S.scaleY * w } else l = Math.abs(c.x * p.scaleX / u.x), h = Math.abs(c.y * p.scaleY / u.y); n(e) && (l *= 2, h *= 2), e.signX !== f && "y" !== y && (e.originX = W[e.originX], l *= -1, e.signX = f), e.signY !== d && "x" !== y && (e.originY = W[e.originY], h *= -1, e.signY = d) } var F = p.scaleX, O = p.scaleY; return y ? ("x" === y && p.set("scaleX", l), "y" === y && p.set("scaleY", h)) : (!m && p.set("scaleX", l), !v && p.set("scaleY", h)), F !== p.scaleX || O !== p.scaleY } function S(t, e, i, r) { return C(t, e, i, r) } function T(t, e, i, r) { return C(t, e, i, r, { by: "x" }) } function w(t, e, i, r) { return C(t, e, i, r, { by: "y" }) } function F(t, e, i, r) { return t[e.target.canvas.altActionKey] ? P.skewHandlerX(t, e, i, r) : P.scalingY(t, e, i, r) } function O(t, e, i, r) { return t[e.target.canvas.altActionKey] ? P.skewHandlerY(t, e, i, r) : P.scalingX(t, e, i, r) } function k(t, e, i, r) { var a = e.target, s = g(e, e.originX, e.originY, i, r), o = a.strokeWidth / (a.strokeUniform ? a.scaleX : 1), c = n(e) ? 2 : 1, l = a.width, h = Math.abs(s.x * c / a.scaleX) - o; return a.set("width", Math.max(h, 0)), l !== h } function E(t, e, r, n) { var a = e.target, s = r - e.offsetX, o = n - e.offsetY, c = !a.get("lockMovementX") && a.left !== s, l = !a.get("lockMovementY") && a.top !== o; return c && a.set("left", s), l && a.set("top", o), (c || l) && i("moving", u(t, e, r, n)), c || l } var A = t.fabric || (t.fabric = {}), D = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], M = ["ns", "nesw", "ew", "nwse"], P = {}, L = "left", I = "top", B = "right", j = "bottom", H = "center", W = { top: j, bottom: I, left: B, right: L, center: H }, R = A.util.radiansToDegrees, N = Math.sign || function (t) { return (t > 0) - (0 > t) || +t }; P.scaleCursorStyleHandler = s, P.skewCursorStyleHandler = o, P.scaleSkewCursorStyleHandler = c, P.rotationWithSnapping = d("rotating", f(_)), P.scalingEqually = d("scaling", f(S)), P.scalingX = d("scaling", f(T)), P.scalingY = d("scaling", f(w)), P.scalingYOrSkewingX = F, P.scalingXOrSkewingY = O, P.changeWidth = d("resizing", f(k)), P.skewHandlerX = b, P.skewHandlerY = x, P.dragHandler = E, P.scaleOrSkewActionName = l, P.rotationStyleHandler = h, P.fireEvent = i, P.wrapWithFixedAnchor = f, P.wrapWithFireEvent = d, P.getLocalPoint = g, A.controlsUtils = P }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t, e, i, r, n) { r = r || {}; var s, a = this.sizeX || r.cornerSize || n.cornerSize, o = this.sizeY || r.cornerSize || n.cornerSize, c = "undefined" != typeof r.transparentCorners ? r.transparentCorners : n.transparentCorners, l = c ? "stroke" : "fill", h = !c && (r.cornerStrokeColor || n.cornerStrokeColor), u = e, f = i; t.save(), t.fillStyle = r.cornerColor || n.cornerColor, t.strokeStyle = r.cornerStrokeColor || n.cornerStrokeColor, a > o ? (s = a, t.scale(1, o / a), f = i * a / o) : o > a ? (s = o, t.scale(a / o, 1), u = e * o / a) : s = a, t.lineWidth = 1, t.beginPath(), t.arc(u, f, s / 2, 0, 2 * Math.PI, !1), t[l](), h && t.stroke(), t.restore() } function i(t, e, i, r, s) { r = r || {}; var a = this.sizeX || r.cornerSize || s.cornerSize, o = this.sizeY || r.cornerSize || s.cornerSize, c = "undefined" != typeof r.transparentCorners ? r.transparentCorners : s.transparentCorners, l = c ? "stroke" : "fill", h = !c && (r.cornerStrokeColor || s.cornerStrokeColor), u = a / 2, f = o / 2; t.save(), t.fillStyle = r.cornerColor || s.cornerColor, t.strokeStyle = r.cornerStrokeColor || s.cornerStrokeColor, t.lineWidth = 1, t.translate(e, i), t.rotate(n(s.angle)), t[l + "Rect"](-u, -f, a, o), h && t.strokeRect(-u, -f, a, o), t.restore() } var r = t.fabric || (t.fabric = {}), n = r.util.degreesToRadians, s = r.controlsUtils; s.renderCircleControl = e, s.renderSquareControl = i }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t) { for (var e in t) this[e] = t[e] } var i = t.fabric || (t.fabric = {}); i.Control = e, i.Control.prototype = { visible: !0, actionName: "scale", angle: 0, x: 0, y: 0, offsetX: 0, offsetY: 0, sizeX: null, sizeY: null, touchSizeX: null, touchSizeY: null, cursorStyle: "crosshair", withConnection: !1, actionHandler: function () { }, mouseDownHandler: function () { }, mouseUpHandler: function () { }, getActionHandler: function () { return this.actionHandler }, getMouseDownHandler: function () { return this.mouseDownHandler }, getMouseUpHandler: function () { return this.mouseUpHandler }, cursorStyleHandler: function (t, e) { return e.cursorStyle }, getActionName: function (t, e) { return e.actionName }, getVisibility: function (t, e) { var i = t._controlsVisibility; return i && "undefined" != typeof i[e] ? i[e] : this.visible }, setVisibility: function (t) { this.visible = t }, positionHandler: function (t, e) { var r = i.util.transformPoint({ x: this.x * t.x + this.offsetX, y: this.y * t.y + this.offsetY }, e); return r }, calcCornerCoords: function (t, e, r, n, s) { var a, o, c, l, h = s ? this.touchSizeX : this.sizeX, u = s ? this.touchSizeY : this.sizeY; if (h && u && h !== u) { var f = Math.atan2(u, h), d = Math.sqrt(h * h + u * u) / 2, g = f - i.util.degreesToRadians(t), p = Math.PI / 2 - f - i.util.degreesToRadians(t); a = d * i.util.cos(g), o = d * i.util.sin(g), c = d * i.util.cos(p), l = d * i.util.sin(p) } else { var m = h && u ? h : e; d = .7071067812 * m; var g = i.util.degreesToRadians(45 - t); a = c = d * i.util.cos(g), o = l = d * i.util.sin(g) } return { tl: { x: r - l, y: n - c }, tr: { x: r + a, y: n - o }, bl: { x: r - a, y: n + o }, br: { x: r + l, y: n + c } } }, render: function (t, e, r, n, s) { switch (n = n || {}, n.cornerStyle || s.cornerStyle) { case "circle": i.controlsUtils.renderCircleControl.call(this, t, e, r, n, s); break; default: i.controlsUtils.renderSquareControl.call(this, t, e, r, n, s) } } } }("undefined" != typeof exports ? exports : this); !function () { function t(t, e) { var i, r, n, s, a = t.getAttribute("style"), o = t.getAttribute("offset") || 0; if (o = parseFloat(o) / (/%$/.test(o) ? 100 : 1), o = 0 > o ? 0 : o > 1 ? 1 : o, a) { var c = a.split(/\s*;\s*/); for ("" === c[c.length - 1] && c.pop(), s = c.length; s--;) { var l = c[s].split(/\s*:\s*/), h = l[0].trim(), u = l[1].trim(); "stop-color" === h ? i = u : "stop-opacity" === h && (n = u) } } return i || (i = t.getAttribute("stop-color") || "rgb(0,0,0)"), n || (n = t.getAttribute("stop-opacity")), i = new fabric.Color(i), r = i.getAlpha(), n = isNaN(parseFloat(n)) ? 1 : parseFloat(n), n *= r * e, { offset: o, color: i.toRgb(), opacity: n } } function e(t) { return { x1: t.getAttribute("x1") || 0, y1: t.getAttribute("y1") || 0, x2: t.getAttribute("x2") || "100%", y2: t.getAttribute("y2") || 0 } } function i(t) { return { x1: t.getAttribute("fx") || t.getAttribute("cx") || "50%", y1: t.getAttribute("fy") || t.getAttribute("cy") || "50%", r1: 0, x2: t.getAttribute("cx") || "50%", y2: t.getAttribute("cy") || "50%", r2: t.getAttribute("r") || "50%" } } function r(t, e, i, r) { var n, s; Object.keys(e).forEach(function (t) { n = e[t], "Infinity" === n ? s = 1 : "-Infinity" === n ? s = 0 : (s = parseFloat(e[t], 10), "string" == typeof n && /^(\d+\.\d+)%|(\d+)%$/.test(n) && (s *= .01, "pixels" === r && (("x1" === t || "x2" === t || "r2" === t) && (s *= i.viewBoxWidth || i.width), ("y1" === t || "y2" === t) && (s *= i.viewBoxHeight || i.height)))), e[t] = s }) } var n = fabric.util.object.clone; fabric.Gradient = fabric.util.createClass({ offsetX: 0, offsetY: 0, gradientTransform: null, gradientUnits: "pixels", type: "linear", initialize: function (t) { t || (t = {}), t.coords || (t.coords = {}); var e, i = this; Object.keys(t).forEach(function (e) { i[e] = t[e] }), this.id ? this.id += "_" + fabric.Object.__uid++ : this.id = fabric.Object.__uid++, e = { x1: t.coords.x1 || 0, y1: t.coords.y1 || 0, x2: t.coords.x2 || 0, y2: t.coords.y2 || 0 }, "radial" === this.type && (e.r1 = t.coords.r1 || 0, e.r2 = t.coords.r2 || 0), this.coords = e, this.colorStops = t.colorStops.slice() }, addColorStop: function (t) { for (var e in t) { var i = new fabric.Color(t[e]); this.colorStops.push({ offset: parseFloat(e), color: i.toRgb(), opacity: i.getAlpha() }) } return this }, toObject: function (t) { var e = { type: this.type, coords: this.coords, colorStops: this.colorStops, offsetX: this.offsetX, offsetY: this.offsetY, gradientUnits: this.gradientUnits, gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform }; return fabric.util.populateWithProperties(this, e, t), e }, toSVG: function (t, e) { var i, r, s, a, o = n(this.coords, !0), e = e || {}, c = n(this.colorStops, !0), l = o.r1 > o.r2, h = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), u = -this.offsetX, f = -this.offsetY, d = !!e.additionalTransform, g = "pixels" === this.gradientUnits ? "userSpaceOnUse" : "objectBoundingBox"; if (c.sort(function (t, e) { return t.offset - e.offset }), "objectBoundingBox" === g ? (u /= t.width, f /= t.height) : (u += t.width / 2, f += t.height / 2), "path" === t.type && "percentage" !== this.gradientUnits && (u -= t.pathOffset.x, f -= t.pathOffset.y), h[4] -= u, h[5] -= f, a = 'id="SVGID_' + this.id + '" gradientUnits="' + g + '"', a += ' gradientTransform="' + (d ? e.additionalTransform + " " : "") + fabric.util.matrixToSVG(h) + '" ', "linear" === this.type ? s = ["<linearGradient ", a, ' x1="', o.x1, '" y1="', o.y1, '" x2="', o.x2, '" y2="', o.y2, '">\n'] : "radial" === this.type && (s = ["<radialGradient ", a, ' cx="', l ? o.x1 : o.x2, '" cy="', l ? o.y1 : o.y2, '" r="', l ? o.r1 : o.r2, '" fx="', l ? o.x2 : o.x1, '" fy="', l ? o.y2 : o.y1, '">\n']), "radial" === this.type) { if (l) for (c = c.concat(), c.reverse(), i = 0, r = c.length; r > i; i++)c[i].offset = 1 - c[i].offset; var p = Math.min(o.r1, o.r2); if (p > 0) { var m = Math.max(o.r1, o.r2), v = p / m; for (i = 0, r = c.length; r > i; i++)c[i].offset += v * (1 - c[i].offset) } } for (i = 0, r = c.length; r > i; i++) { var y = c[i]; s.push("<stop ", 'offset="', 100 * y.offset + "%", '" style="stop-color:', y.color, "undefined" != typeof y.opacity ? ";stop-opacity: " + y.opacity : ";", '"/>\n') } return s.push("linear" === this.type ? "</linearGradient>\n" : "</radialGradient>\n"), s.join("") }, toLive: function (t) { var e, i, r, n = fabric.util.object.clone(this.coords); if (this.type) { for ("linear" === this.type ? e = t.createLinearGradient(n.x1, n.y1, n.x2, n.y2) : "radial" === this.type && (e = t.createRadialGradient(n.x1, n.y1, n.r1, n.x2, n.y2, n.r2)), i = 0, r = this.colorStops.length; r > i; i++) { var s = this.colorStops[i].color, a = this.colorStops[i].opacity, o = this.colorStops[i].offset; "undefined" != typeof a && (s = new fabric.Color(s).setAlpha(a).toRgba()), e.addColorStop(o, s) } return e } } }), fabric.util.object.extend(fabric.Gradient, { fromElement: function (n, s, a, o) { var c = parseFloat(a) / (/%$/.test(a) ? 100 : 1); c = 0 > c ? 0 : c > 1 ? 1 : c, isNaN(c) && (c = 1); var l, h, u, f, d = n.getElementsByTagName("stop"), g = "userSpaceOnUse" === n.getAttribute("gradientUnits") ? "pixels" : "percentage", p = n.getAttribute("gradientTransform") || "", m = [], v = 0, y = 0; for ("linearGradient" === n.nodeName || "LINEARGRADIENT" === n.nodeName ? (l = "linear", h = e(n)) : (l = "radial", h = i(n)), u = d.length; u--;)m.push(t(d[u], c)); f = fabric.parseTransformAttribute(p), r(s, h, o, g), "pixels" === g && (v = -s.left, y = -s.top); var b = new fabric.Gradient({ id: n.getAttribute("id"), type: l, coords: h, colorStops: m, gradientUnits: g, gradientTransform: f, offsetX: v, offsetY: y }); return b } }) }(); !function () { "use strict"; var t = fabric.util.toFixed; fabric.Pattern = fabric.util.createClass({ repeat: "repeat", offsetX: 0, offsetY: 0, crossOrigin: "", patternTransform: null, initialize: function (t, e) { if (t || (t = {}), this.id = fabric.Object.__uid++, this.setOptions(t), !t.source || t.source && "string" != typeof t.source) return void (e && e(this)); var i = this; this.source = fabric.util.createImage(), fabric.util.loadImage(t.source, function (t, r) { i.source = t, e && e(i, r) }, null, this.crossOrigin) }, toObject: function (e) { var i, r, n = fabric.Object.NUM_FRACTION_DIGITS; return "string" == typeof this.source.src ? i = this.source.src : "object" == typeof this.source && this.source.toDataURL && (i = this.source.toDataURL()), r = { type: "pattern", source: i, repeat: this.repeat, crossOrigin: this.crossOrigin, offsetX: t(this.offsetX, n), offsetY: t(this.offsetY, n), patternTransform: this.patternTransform ? this.patternTransform.concat() : null }, fabric.util.populateWithProperties(this, r, e), r }, toSVG: function (t) { var e = "function" == typeof this.source ? this.source() : this.source, i = e.width / t.width, r = e.height / t.height, n = this.offsetX / t.width, a = this.offsetY / t.height, s = ""; return ("repeat-x" === this.repeat || "no-repeat" === this.repeat) && (r = 1, a && (r += Math.abs(a))), ("repeat-y" === this.repeat || "no-repeat" === this.repeat) && (i = 1, n && (i += Math.abs(n))), e.src ? s = e.src : e.toDataURL && (s = e.toDataURL()), '<pattern id="SVGID_' + this.id + '" x="' + n + '" y="' + a + '" width="' + i + '" height="' + r + '">\n<image x="0" y="0" width="' + e.width + '" height="' + e.height + '" xlink:href="' + s + '"></image>\n</pattern>\n' }, setOptions: function (t) { for (var e in t) this[e] = t[e] }, toLive: function (t) { var e = this.source; if (!e) return ""; if ("undefined" != typeof e.src) { if (!e.complete) return ""; if (0 === e.naturalWidth || 0 === e.naturalHeight) return "" } return t.createPattern(e, this.repeat) } }) }(); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.toFixed; return e.Shadow ? void e.warn("fabric.Shadow is already defined.") : (e.Shadow = e.util.createClass({ color: "rgb(0,0,0)", blur: 0, offsetX: 0, offsetY: 0, affectStroke: !1, includeDefaultValues: !0, nonScaling: !1, initialize: function (t) { "string" == typeof t && (t = this._parseShadow(t)); for (var i in t) this[i] = t[i]; this.id = e.Object.__uid++ }, _parseShadow: function (t) { var i = t.trim(), r = e.Shadow.reOffsetsAndBlur.exec(i) || [], n = i.replace(e.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)"; return { color: n.trim(), offsetX: parseFloat(r[1], 10) || 0, offsetY: parseFloat(r[2], 10) || 0, blur: parseFloat(r[3], 10) || 0 } }, toString: function () { return [this.offsetX, this.offsetY, this.blur, this.color].join("px ") }, toSVG: function (t) { var r = 40, n = 40, o = e.Object.NUM_FRACTION_DIGITS, a = e.util.rotateVector({ x: this.offsetX, y: this.offsetY }, e.util.degreesToRadians(-t.angle)), s = 20, c = new e.Color(this.color); return t.width && t.height && (r = 100 * i((Math.abs(a.x) + this.blur) / t.width, o) + s, n = 100 * i((Math.abs(a.y) + this.blur) / t.height, o) + s), t.flipX && (a.x *= -1), t.flipY && (a.y *= -1), '<filter id="SVGID_' + this.id + '" y="-' + n + '%" height="' + (100 + 2 * n) + '%" x="-' + r + '%" width="' + (100 + 2 * r) + '%" >\n	<feGaussianBlur in="SourceAlpha" stdDeviation="' + i(this.blur ? this.blur / 2 : 0, o) + '"></feGaussianBlur>\n	<feOffset dx="' + i(a.x, o) + '" dy="' + i(a.y, o) + '" result="oBlur" ></feOffset>\n	<feFlood flood-color="' + c.toRgb() + '" flood-opacity="' + c.getAlpha() + '"/>\n	<feComposite in2="oBlur" operator="in" />\n	<feMerge>\n		<feMergeNode></feMergeNode>\n		<feMergeNode in="SourceGraphic"></feMergeNode>\n	</feMerge>\n</filter>\n' }, toObject: function () { if (this.includeDefaultValues) return { color: this.color, blur: this.blur, offsetX: this.offsetX, offsetY: this.offsetY, affectStroke: this.affectStroke, nonScaling: this.nonScaling }; var t = {}, i = e.Shadow.prototype; return ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function (e) { this[e] !== i[e] && (t[e] = this[e]) }, this), t } }), void (e.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/)) }("undefined" != typeof exports ? exports : this); !function () { "use strict"; if (fabric.StaticCanvas) return void fabric.warn("fabric.StaticCanvas is already defined."); var t = fabric.util.object.extend, e = fabric.util.getElementOffset, i = fabric.util.removeFromArray, r = fabric.util.toFixed, n = fabric.util.transformPoint, o = fabric.util.invertTransform, a = fabric.util.getNodeCanvas, s = fabric.util.createCanvasElement, c = new Error("Could not initialize `canvas` element"); fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, { initialize: function (t, e) { e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t, e) }, backgroundColor: "", backgroundImage: null, overlayColor: "", overlayImage: null, includeDefaultValues: !0, stateful: !1, renderOnAddRemove: !0, controlsAboveOverlay: !1, allowTouchScrolling: !1, imageSmoothingEnabled: !0, viewportTransform: fabric.iMatrix.concat(), backgroundVpt: !0, overlayVpt: !0, enableRetinaScaling: !0, vptCoords: {}, skipOffscreen: !0, clipPath: void 0, _initStatic: function (t, e) { var i = this.requestRenderAllBound; this._objects = [], this._createLowerCanvas(t), this._initOptions(e), this.interactive || this._initRetinaScaling(), e.overlayImage && this.setOverlayImage(e.overlayImage, i), e.backgroundImage && this.setBackgroundImage(e.backgroundImage, i), e.backgroundColor && this.setBackgroundColor(e.backgroundColor, i), e.overlayColor && this.setOverlayColor(e.overlayColor, i), this.calcOffset() }, _isRetinaScaling: function () { return fabric.devicePixelRatio > 1 && this.enableRetinaScaling }, getRetinaScaling: function () { return this._isRetinaScaling() ? Math.max(1, fabric.devicePixelRatio) : 1 }, _initRetinaScaling: function () { if (this._isRetinaScaling()) { var t = fabric.devicePixelRatio; this.__initRetinaScaling(t, this.lowerCanvasEl, this.contextContainer), this.upperCanvasEl && this.__initRetinaScaling(t, this.upperCanvasEl, this.contextTop) } }, __initRetinaScaling: function (t, e, i) { e.setAttribute("width", this.width * t), e.setAttribute("height", this.height * t), i.scale(t, t) }, calcOffset: function () { return this._offset = e(this.lowerCanvasEl), this }, setOverlayImage: function (t, e, i) { return this.__setBgOverlayImage("overlayImage", t, e, i) }, setBackgroundImage: function (t, e, i) { return this.__setBgOverlayImage("backgroundImage", t, e, i) }, setOverlayColor: function (t, e) { return this.__setBgOverlayColor("overlayColor", t, e) }, setBackgroundColor: function (t, e) { return this.__setBgOverlayColor("backgroundColor", t, e) }, __setBgOverlayImage: function (t, e, i, r) { return "string" == typeof e ? fabric.util.loadImage(e, function (e, n) { if (e) { var o = new fabric.Image(e, r); this[t] = o, o.canvas = this } i && i(e, n) }, this, r && r.crossOrigin) : (r && e.setOptions(r), this[t] = e, e && (e.canvas = this), i && i(e, !1)), this }, __setBgOverlayColor: function (t, e, i) { return this[t] = e, this._initGradient(e, t), this._initPattern(e, t, i), this }, _createCanvasElement: function () { var t = s(); if (!t) throw c; if (t.style || (t.style = {}), "undefined" == typeof t.getContext) throw c; return t }, _initOptions: function (t) { var e = this.lowerCanvasEl; this._setOptions(t), this.width = this.width || parseInt(e.width, 10) || 0, this.height = this.height || parseInt(e.height, 10) || 0, this.lowerCanvasEl.style && (e.width = this.width, e.height = this.height, e.style.width = this.width + "px", e.style.height = this.height + "px", this.viewportTransform = this.viewportTransform.slice()) }, _createLowerCanvas: function (t) { this.lowerCanvasEl = t && t.getContext ? t : fabric.util.getById(t) || this._createCanvasElement(), fabric.util.addClass(this.lowerCanvasEl, "lower-canvas"), this._originalCanvasStyle = this.lowerCanvasEl.style, this.interactive && this._applyCanvasStyle(this.lowerCanvasEl), this.contextContainer = this.lowerCanvasEl.getContext("2d") }, getWidth: function () { return this.width }, getHeight: function () { return this.height }, setWidth: function (t, e) { return this.setDimensions({ width: t }, e) }, setHeight: function (t, e) { return this.setDimensions({ height: t }, e) }, setDimensions: function (t, e) { var i; e = e || {}; for (var r in t) i = t[r], e.cssOnly || (this._setBackstoreDimension(r, t[r]), i += "px", this.hasLostContext = !0), e.backstoreOnly || this._setCssDimension(r, i); return this._isCurrentlyDrawing && this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles(this.contextTop), this._initRetinaScaling(), this.calcOffset(), e.cssOnly || this.requestRenderAll(), this }, _setBackstoreDimension: function (t, e) { return this.lowerCanvasEl[t] = e, this.upperCanvasEl && (this.upperCanvasEl[t] = e), this.cacheCanvasEl && (this.cacheCanvasEl[t] = e), this[t] = e, this }, _setCssDimension: function (t, e) { return this.lowerCanvasEl.style[t] = e, this.upperCanvasEl && (this.upperCanvasEl.style[t] = e), this.wrapperEl && (this.wrapperEl.style[t] = e), this }, getZoom: function () { return this.viewportTransform[0] }, setViewportTransform: function (t) { var e, i, r, n = this._activeObject, o = this.backgroundImage, a = this.overlayImage; for (this.viewportTransform = t, i = 0, r = this._objects.length; r > i; i++)e = this._objects[i], e.group || e.setCoords(!0); return n && n.setCoords(), o && o.setCoords(!0), a && a.setCoords(!0), this.calcViewportBoundaries(), this.renderOnAddRemove && this.requestRenderAll(), this }, zoomToPoint: function (t, e) { var i = t, r = this.viewportTransform.slice(0); t = n(t, o(this.viewportTransform)), r[0] = e, r[3] = e; var a = n(t, r); return r[4] += i.x - a.x, r[5] += i.y - a.y, this.setViewportTransform(r) }, setZoom: function (t) { return this.zoomToPoint(new fabric.Point(0, 0), t), this }, absolutePan: function (t) { var e = this.viewportTransform.slice(0); return e[4] = -t.x, e[5] = -t.y, this.setViewportTransform(e) }, relativePan: function (t) { return this.absolutePan(new fabric.Point(-t.x - this.viewportTransform[4], -t.y - this.viewportTransform[5])) }, getElement: function () { return this.lowerCanvasEl }, _onObjectAdded: function (t) { this.stateful && t.setupState(), t._set("canvas", this), t.setCoords(), this.fire("object:added", { target: t }), t.fire("added") }, _onObjectRemoved: function (t) { this.fire("object:removed", { target: t }), t.fire("removed"), delete t.canvas }, clearContext: function (t) { return t.clearRect(0, 0, this.width, this.height), this }, getContext: function () { return this.contextContainer }, clear: function () { return this.remove.apply(this, this.getObjects()), this.backgroundImage = null, this.overlayImage = null, this.backgroundColor = "", this.overlayColor = "", this._hasITextHandlers && (this.off("mouse:up", this._mouseUpITextHandler), this._iTextInstances = null, this._hasITextHandlers = !1), this.clearContext(this.contextContainer), this.fire("canvas:cleared"), this.renderOnAddRemove && this.requestRenderAll(), this }, renderAll: function () { var t = this.contextContainer; return this.renderCanvas(t, this._objects), this }, renderAndReset: function () { this.isRendering = 0, this.renderAll() }, requestRenderAll: function () { return this.isRendering || (this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound)), this }, calcViewportBoundaries: function () { var t = {}, e = this.width, i = this.height, r = o(this.viewportTransform); return t.tl = n({ x: 0, y: 0 }, r), t.br = n({ x: e, y: i }, r), t.tr = new fabric.Point(t.br.x, t.tl.y), t.bl = new fabric.Point(t.tl.x, t.br.y), this.vptCoords = t, t }, cancelRequestedRender: function () { this.isRendering && (fabric.util.cancelAnimFrame(this.isRendering), this.isRendering = 0) }, renderCanvas: function (t, e) { var i = this.viewportTransform, r = this.clipPath; this.cancelRequestedRender(), this.calcViewportBoundaries(), this.clearContext(t), fabric.util.setImageSmoothing(t, this.imageSmoothingEnabled), this.fire("before:render", { ctx: t }), this._renderBackground(t), t.save(), t.transform(i[0], i[1], i[2], i[3], i[4], i[5]), this._renderObjects(t, e), t.restore(), !this.controlsAboveOverlay && this.interactive && this.drawControls(t), r && (r.canvas = this, r.shouldCache(), r._transformDone = !0, r.renderCache({ forClipping: !0 }), this.drawClipPathOnCanvas(t)), this._renderOverlay(t), this.controlsAboveOverlay && this.interactive && this.drawControls(t), this.fire("after:render", { ctx: t }) }, drawClipPathOnCanvas: function (t) { var e = this.viewportTransform, i = this.clipPath; t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t.globalCompositeOperation = "destination-in", i.transform(t), t.scale(1 / i.zoomX, 1 / i.zoomY), t.drawImage(i._cacheCanvas, -i.cacheTranslationX, -i.cacheTranslationY), t.restore() }, _renderObjects: function (t, e) { var i, r; for (i = 0, r = e.length; r > i; ++i)e[i] && e[i].render(t) }, _renderBackgroundOrOverlay: function (t, e) { var i = this[e + "Color"], r = this[e + "Image"], n = this.viewportTransform, o = this[e + "Vpt"]; if (i || r) { if (i) { t.save(), t.beginPath(), t.moveTo(0, 0), t.lineTo(this.width, 0), t.lineTo(this.width, this.height), t.lineTo(0, this.height), t.closePath(), t.fillStyle = i.toLive ? i.toLive(t, this) : i, o && t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), t.transform(1, 0, 0, 1, i.offsetX || 0, i.offsetY || 0); var a = i.gradientTransform || i.patternTransform; a && t.transform(a[0], a[1], a[2], a[3], a[4], a[5]), t.fill(), t.restore() } r && (t.save(), o && t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), r.render(t), t.restore()) } }, _renderBackground: function (t) { this._renderBackgroundOrOverlay(t, "background") }, _renderOverlay: function (t) { this._renderBackgroundOrOverlay(t, "overlay") }, getCenter: function () { return { top: this.height / 2, left: this.width / 2 } }, getCenterPoint: function () { return new fabric.Point(this.width / 2, this.height / 2) }, centerObjectH: function (t) { return this._centerObject(t, new fabric.Point(this.getCenterPoint().x, t.getCenterPoint().y)) }, centerObjectV: function (t) { return this._centerObject(t, new fabric.Point(t.getCenterPoint().x, this.getCenterPoint().y)) }, centerObject: function (t) { var e = this.getCenterPoint(); return this._centerObject(t, e) }, viewportCenterObject: function (t) { var e = this.getVpCenter(); return this._centerObject(t, e) }, viewportCenterObjectH: function (t) { var e = this.getVpCenter(); return this._centerObject(t, new fabric.Point(e.x, t.getCenterPoint().y)), this }, viewportCenterObjectV: function (t) { var e = this.getVpCenter(); return this._centerObject(t, new fabric.Point(t.getCenterPoint().x, e.y)) }, getVpCenter: function () { var t = this.getCenterPoint(), e = o(this.viewportTransform); return n(t, e) }, _centerObject: function (t, e) { return t.setPositionByOrigin(e, "center", "center"), t.setCoords(), this.renderOnAddRemove && this.requestRenderAll(), this }, toDatalessJSON: function (t) { return this.toDatalessObject(t) }, toObject: function (t) { return this._toObjectMethod("toObject", t) }, toDatalessObject: function (t) { return this._toObjectMethod("toDatalessObject", t) }, _toObjectMethod: function (e, i) { var r = this.clipPath, n = { version: fabric.version, objects: this._toObjects(e, i) }; return r && !r.excludeFromExport && (n.clipPath = this._toObject(this.clipPath, e, i)), t(n, this.__serializeBgOverlay(e, i)), fabric.util.populateWithProperties(this, n, i), n }, _toObjects: function (t, e) { return this._objects.filter(function (t) { return !t.excludeFromExport }).map(function (i) { return this._toObject(i, t, e) }, this) }, _toObject: function (t, e, i) { var r; this.includeDefaultValues || (r = t.includeDefaultValues, t.includeDefaultValues = !1); var n = t[e](i); return this.includeDefaultValues || (t.includeDefaultValues = r), n }, __serializeBgOverlay: function (t, e) { var i = {}, r = this.backgroundImage, n = this.overlayImage, o = this.backgroundColor, a = this.overlayColor; return o && o.toObject ? o.excludeFromExport || (i.background = o.toObject(e)) : o && (i.background = o), a && a.toObject ? a.excludeFromExport || (i.overlay = a.toObject(e)) : a && (i.overlay = a), r && !r.excludeFromExport && (i.backgroundImage = this._toObject(r, t, e)), n && !n.excludeFromExport && (i.overlayImage = this._toObject(n, t, e)), i }, svgViewportTransformation: !0, toSVG: function (t, e) { t || (t = {}), t.reviver = e; var i = []; return this._setSVGPreamble(i, t), this._setSVGHeader(i, t), this.clipPath && i.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n'), this._setSVGBgOverlayColor(i, "background"), this._setSVGBgOverlayImage(i, "backgroundImage", e), this._setSVGObjects(i, e), this.clipPath && i.push("</g>\n"), this._setSVGBgOverlayColor(i, "overlay"), this._setSVGBgOverlayImage(i, "overlayImage", e), i.push("</svg>"), i.join("") }, _setSVGPreamble: function (t, e) { e.suppressPreamble || t.push('<?xml version="1.0" encoding="', e.encoding || "UTF-8", '" standalone="no" ?>\n', '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ', '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n') }, _setSVGHeader: function (t, e) { var i, n = e.width || this.width, o = e.height || this.height, a = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', s = fabric.Object.NUM_FRACTION_DIGITS; e.viewBox ? a = 'viewBox="' + e.viewBox.x + " " + e.viewBox.y + " " + e.viewBox.width + " " + e.viewBox.height + '" ' : this.svgViewportTransformation && (i = this.viewportTransform, a = 'viewBox="' + r(-i[4] / i[0], s) + " " + r(-i[5] / i[3], s) + " " + r(this.width / i[0], s) + " " + r(this.height / i[3], s) + '" '), t.push("<svg ", 'xmlns="http://www.w3.org/2000/svg" ', 'xmlns:xlink="http://www.w3.org/1999/xlink" ', 'version="1.1" ', 'width="', n, '" ', 'height="', o, '" ', a, 'xml:space="preserve">\n', "<desc>Created with Fabric.js ", fabric.version, "</desc>\n", "<defs>\n", this.createSVGFontFacesMarkup(), this.createSVGRefElementsMarkup(), this.createSVGClipPathMarkup(e), "</defs>\n") }, createSVGClipPathMarkup: function (t) { var e = this.clipPath; return e ? (e.clipPathId = "CLIPPATH_" + fabric.Object.__uid++, '<clipPath id="' + e.clipPathId + '" >\n' + this.clipPath.toClipPathSVG(t.reviver) + "</clipPath>\n") : "" }, createSVGRefElementsMarkup: function () { var t = this, e = ["background", "overlay"].map(function (e) { var i = t[e + "Color"]; if (i && i.toLive) { var r = t[e + "Vpt"], n = t.viewportTransform, o = { width: t.width / (r ? n[0] : 1), height: t.height / (r ? n[3] : 1) }; return i.toSVG(o, { additionalTransform: r ? fabric.util.matrixToSVG(n) : "" }) } }); return e.join("") }, createSVGFontFacesMarkup: function () { var t, e, i, r, n, o, a, s, c, l = "", h = {}, u = fabric.fontPaths, f = []; for (this._objects.forEach(function g(t) { f.push(t), t._objects && t._objects.forEach(g) }), s = 0, c = f.length; c > s; s++)if (t = f[s], e = t.fontFamily, -1 !== t.type.indexOf("text") && !h[e] && u[e] && (h[e] = !0, t.styles)) { i = t.styles; for (n in i) { r = i[n]; for (a in r) o = r[a], e = o.fontFamily, !h[e] && u[e] && (h[e] = !0) } } for (var d in h) l += ["		@font-face {\n", "			font-family: '", d, "';\n", "			src: url('", u[d], "');\n", "		}\n"].join(""); return l && (l = ['	<style type="text/css">', "<![CDATA[\n", l, "]]>", "</style>\n"].join("")), l }, _setSVGObjects: function (t, e) { var i, r, n, o = this._objects; for (r = 0, n = o.length; n > r; r++)i = o[r], i.excludeFromExport || this._setSVGObject(t, i, e) }, _setSVGObject: function (t, e, i) { t.push(e.toSVG(i)) }, _setSVGBgOverlayImage: function (t, e, i) { this[e] && !this[e].excludeFromExport && this[e].toSVG && t.push(this[e].toSVG(i)) }, _setSVGBgOverlayColor: function (t, e) { var i = this[e + "Color"], r = this.viewportTransform, n = this.width, o = this.height; if (i) if (i.toLive) { var a = i.repeat, s = fabric.util.invertTransform(r), c = this[e + "Vpt"], l = c ? fabric.util.matrixToSVG(s) : ""; t.push('<rect transform="' + l + " translate(", n / 2, ",", o / 2, ')"', ' x="', i.offsetX - n / 2, '" y="', i.offsetY - o / 2, '" ', 'width="', "repeat-y" === a || "no-repeat" === a ? i.source.width : n, '" height="', "repeat-x" === a || "no-repeat" === a ? i.source.height : o, '" fill="url(#SVGID_' + i.id + ')"', "></rect>\n") } else t.push('<rect x="0" y="0" width="100%" height="100%" ', 'fill="', i, '"', "></rect>\n") }, sendToBack: function (t) { if (!t) return this; var e, r, n, o = this._activeObject; if (t === o && "activeSelection" === t.type) for (n = o._objects, e = n.length; e--;)r = n[e], i(this._objects, r), this._objects.unshift(r); else i(this._objects, t), this._objects.unshift(t); return this.renderOnAddRemove && this.requestRenderAll(), this }, bringToFront: function (t) { if (!t) return this; var e, r, n, o = this._activeObject; if (t === o && "activeSelection" === t.type) for (n = o._objects, e = 0; e < n.length; e++)r = n[e], i(this._objects, r), this._objects.push(r); else i(this._objects, t), this._objects.push(t); return this.renderOnAddRemove && this.requestRenderAll(), this }, sendBackwards: function (t, e) { if (!t) return this; var r, n, o, a, s, c = this._activeObject, l = 0; if (t === c && "activeSelection" === t.type) for (s = c._objects, r = 0; r < s.length; r++)n = s[r], o = this._objects.indexOf(n), o > 0 + l && (a = o - 1, i(this._objects, n), this._objects.splice(a, 0, n)), l++; else o = this._objects.indexOf(t), 0 !== o && (a = this._findNewLowerIndex(t, o, e), i(this._objects, t), this._objects.splice(a, 0, t)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewLowerIndex: function (t, e, i) { var r, n; if (i) for (r = e, n = e - 1; n >= 0; --n) { var o = t.intersectsWithObject(this._objects[n]) || t.isContainedWithinObject(this._objects[n]) || this._objects[n].isContainedWithinObject(t); if (o) { r = n; break } } else r = e - 1; return r }, bringForward: function (t, e) { if (!t) return this; var r, n, o, a, s, c = this._activeObject, l = 0; if (t === c && "activeSelection" === t.type) for (s = c._objects, r = s.length; r--;)n = s[r], o = this._objects.indexOf(n), o < this._objects.length - 1 - l && (a = o + 1, i(this._objects, n), this._objects.splice(a, 0, n)), l++; else o = this._objects.indexOf(t), o !== this._objects.length - 1 && (a = this._findNewUpperIndex(t, o, e), i(this._objects, t), this._objects.splice(a, 0, t)); return this.renderOnAddRemove && this.requestRenderAll(), this }, _findNewUpperIndex: function (t, e, i) { var r, n, o; if (i) for (r = e, n = e + 1, o = this._objects.length; o > n; ++n) { var a = t.intersectsWithObject(this._objects[n]) || t.isContainedWithinObject(this._objects[n]) || this._objects[n].isContainedWithinObject(t); if (a) { r = n; break } } else r = e + 1; return r }, moveTo: function (t, e) { return i(this._objects, t), this._objects.splice(e, 0, t), this.renderOnAddRemove && this.requestRenderAll() }, dispose: function () { return this.isRendering && (fabric.util.cancelAnimFrame(this.isRendering), this.isRendering = 0), this.forEachObject(function (t) { t.dispose && t.dispose() }), this._objects = [], this.backgroundImage && this.backgroundImage.dispose && this.backgroundImage.dispose(), this.backgroundImage = null, this.overlayImage && this.overlayImage.dispose && this.overlayImage.dispose(), this.overlayImage = null, this._iTextInstances = null, this.contextContainer = null, this.lowerCanvasEl.classList.remove("lower-canvas"), fabric.util.setStyle(this.lowerCanvasEl, this._originalCanvasStyle), delete this._originalCanvasStyle, this.lowerCanvasEl.setAttribute("width", this.width), this.lowerCanvasEl.setAttribute("height", this.height), fabric.util.cleanUpJsdomNode(this.lowerCanvasEl), this.lowerCanvasEl = void 0, this }, toString: function () { return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>" } }), t(fabric.StaticCanvas.prototype, fabric.Observable), t(fabric.StaticCanvas.prototype, fabric.Collection), t(fabric.StaticCanvas.prototype, fabric.DataURLExporter), t(fabric.StaticCanvas, { EMPTY_JSON: '{"objects": [], "background": "white"}', supports: function (t) { var e = s(); if (!e || !e.getContext) return null; var i = e.getContext("2d"); if (!i) return null; switch (t) { case "setLineDash": return "undefined" != typeof i.setLineDash; default: return null } } }), fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject, fabric.isLikelyNode && (fabric.StaticCanvas.prototype.createPNGStream = function () { var t = a(this.lowerCanvasEl); return t && t.createPNGStream() }, fabric.StaticCanvas.prototype.createJPEGStream = function (t) { var e = a(this.lowerCanvasEl); return e && e.createJPEGStream(t) }) }(); fabric.BaseBrush = fabric.util.createClass({ color: "rgb(0, 0, 0)", width: 1, shadow: null, strokeLineCap: "round", strokeLineJoin: "round", strokeMiterLimit: 10, strokeDashArray: null, limitedToCanvasSize: !1, _setBrushStyles: function (t) { t.strokeStyle = this.color, t.lineWidth = this.width, t.lineCap = this.strokeLineCap, t.miterLimit = this.strokeMiterLimit, t.lineJoin = this.strokeLineJoin, t.setLineDash(this.strokeDashArray || []) }, _saveAndTransform: function (t) { var e = this.canvas.viewportTransform; t.save(), t.transform(e[0], e[1], e[2], e[3], e[4], e[5]) }, _setShadow: function () { if (this.shadow) { var t = this.canvas, e = this.shadow, i = t.contextTop, r = t.getZoom(); t && t._isRetinaScaling() && (r *= fabric.devicePixelRatio), i.shadowColor = e.color, i.shadowBlur = e.blur * r, i.shadowOffsetX = e.offsetX * r, i.shadowOffsetY = e.offsetY * r } }, needsFullRender: function () { var t = new fabric.Color(this.color); return t.getAlpha() < 1 || !!this.shadow }, _resetShadow: function () { var t = this.canvas.contextTop; t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0 }, _isOutSideCanvas: function (t) { return t.x < 0 || t.x > this.canvas.getWidth() || t.y < 0 || t.y > this.canvas.getHeight() } }); !function () { fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, { decimate: .4, drawStraightLine: !1, straightLineKey: "shiftKey", initialize: function (t) { this.canvas = t, this._points = [] }, needsFullRender: function () { return this.callSuper("needsFullRender") || this._hasStraightLine }, _drawSegment: function (t, e, i) { var r = e.midPointFrom(i); return t.quadraticCurveTo(e.x, e.y, r.x, r.y), r }, onMouseDown: function (t, e) { this.canvas._isMainEvent(e.e) && (this.drawStraightLine = e.e[this.straightLineKey], this._prepareForDrawing(t), this._captureDrawingPath(t), this._render()) }, onMouseMove: function (t, e) { if (this.canvas._isMainEvent(e.e) && (this.drawStraightLine = e.e[this.straightLineKey], (this.limitedToCanvasSize !== !0 || !this._isOutSideCanvas(t)) && this._captureDrawingPath(t) && this._points.length > 1)) if (this.needsFullRender()) this.canvas.clearContext(this.canvas.contextTop), this._render(); else { var i = this._points, r = i.length, n = this.canvas.contextTop; this._saveAndTransform(n), this.oldEnd && (n.beginPath(), n.moveTo(this.oldEnd.x, this.oldEnd.y)), this.oldEnd = this._drawSegment(n, i[r - 2], i[r - 1], !0), n.stroke(), n.restore() } }, onMouseUp: function (t) { return this.canvas._isMainEvent(t.e) ? (this.drawStraightLine = !1, this.oldEnd = void 0, this._finalizeAndAddPath(), !1) : !0 }, _prepareForDrawing: function (t) { var e = new fabric.Point(t.x, t.y); this._reset(), this._addPoint(e), this.canvas.contextTop.moveTo(e.x, e.y) }, _addPoint: function (t) { return this._points.length > 1 && t.eq(this._points[this._points.length - 1]) ? !1 : (this.drawStraightLine && this._points.length > 1 && (this._hasStraightLine = !0, this._points.pop()), this._points.push(t), !0) }, _reset: function () { this._points = [], this._setBrushStyles(this.canvas.contextTop), this._setShadow(), this._hasStraightLine = !1 }, _captureDrawingPath: function (t) { var e = new fabric.Point(t.x, t.y); return this._addPoint(e) }, _render: function (t) { var e, i, r = this._points[0], n = this._points[1]; if (t = t || this.canvas.contextTop, this._saveAndTransform(t), t.beginPath(), 2 === this._points.length && r.x === n.x && r.y === n.y) { var o = this.width / 1e3; r = new fabric.Point(r.x, r.y), n = new fabric.Point(n.x, n.y), r.x -= o, n.x += o } for (t.moveTo(r.x, r.y), e = 1, i = this._points.length; i > e; e++)this._drawSegment(t, r, n), r = this._points[e], n = this._points[e + 1]; t.lineTo(r.x, r.y), t.stroke(), t.restore() }, convertPointsToSVGPath: function (t) { var e = this.width / 1e3; return fabric.util.getSmoothPathFromPoints(t, e) }, _isEmptySVGPath: function (t) { var e = fabric.util.joinPath(t); return "M 0 0 Q 0 0 0 0 L 0 0" === e }, createPath: function (t) { var e = new fabric.Path(t, { fill: null, stroke: this.color, strokeWidth: this.width, strokeLineCap: this.strokeLineCap, strokeMiterLimit: this.strokeMiterLimit, strokeLineJoin: this.strokeLineJoin, strokeDashArray: this.strokeDashArray }); return this.shadow && (this.shadow.affectStroke = !0, e.shadow = new fabric.Shadow(this.shadow)), e }, decimatePoints: function (t, e) { if (t.length <= 2) return t; var i, r, n = this.canvas.getZoom(), o = Math.pow(e / n, 2), a = t.length - 1, s = t[0], c = [s]; for (i = 1; a - 1 > i; i++)r = Math.pow(s.x - t[i].x, 2) + Math.pow(s.y - t[i].y, 2), r >= o && (s = t[i], c.push(s)); return c.push(t[a]), c }, _finalizeAndAddPath: function () { var t = this.canvas.contextTop; t.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate)); var e = this.convertPointsToSVGPath(this._points); if (this._isEmptySVGPath(e)) return void this.canvas.requestRenderAll(); var i = this.createPath(e); this.canvas.clearContext(this.canvas.contextTop), this.canvas.fire("before:path:created", { path: i }), this.canvas.add(i), this.canvas.requestRenderAll(), i.setCoords(), this._resetShadow(), this.canvas.fire("path:created", { path: i }) } }) }(); fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, { width: 10, initialize: function (t) { this.canvas = t, this.points = [] }, drawDot: function (t) { var e = this.addPoint(t), i = this.canvas.contextTop; this._saveAndTransform(i), this.dot(i, e), i.restore() }, dot: function (t, e) { t.fillStyle = e.fill, t.beginPath(), t.arc(e.x, e.y, e.radius, 0, 2 * Math.PI, !1), t.closePath(), t.fill() }, onMouseDown: function (t) { this.points.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.drawDot(t) }, _render: function () { var t, e, i = this.canvas.contextTop, r = this.points; for (this._saveAndTransform(i), t = 0, e = r.length; e > t; t++)this.dot(i, r[t]); i.restore() }, onMouseMove: function (t) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(t) || (this.needsFullRender() ? (this.canvas.clearContext(this.canvas.contextTop), this.addPoint(t), this._render()) : this.drawDot(t)) }, onMouseUp: function () { var t, e, i = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; var r = []; for (t = 0, e = this.points.length; e > t; t++) { var n = this.points[t], a = new fabric.Circle({ radius: n.radius, left: n.x, top: n.y, originX: "center", originY: "center", fill: n.fill }); this.shadow && (a.shadow = new fabric.Shadow(this.shadow)), r.push(a) } var o = new fabric.Group(r); o.canvas = this.canvas, this.canvas.fire("before:path:created", { path: o }), this.canvas.add(o), this.canvas.fire("path:created", { path: o }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = i, this.canvas.requestRenderAll() }, addPoint: function (t) { var e = new fabric.Point(t.x, t.y), i = fabric.util.getRandomInt(Math.max(0, this.width - 20), this.width + 20) / 2, r = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba(); return e.radius = i, e.fill = r, this.points.push(e), e } }); fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, { width: 10, density: 20, dotWidth: 1, dotWidthVariance: 1, randomOpacity: !1, optimizeOverlapping: !0, initialize: function (t) { this.canvas = t, this.sprayChunks = [] }, onMouseDown: function (t) { this.sprayChunks.length = 0, this.canvas.clearContext(this.canvas.contextTop), this._setShadow(), this.addSprayChunk(t), this.render(this.sprayChunkPoints) }, onMouseMove: function (t) { this.limitedToCanvasSize === !0 && this._isOutSideCanvas(t) || (this.addSprayChunk(t), this.render(this.sprayChunkPoints)) }, onMouseUp: function () { var t = this.canvas.renderOnAddRemove; this.canvas.renderOnAddRemove = !1; for (var e = [], i = 0, r = this.sprayChunks.length; r > i; i++)for (var n = this.sprayChunks[i], a = 0, o = n.length; o > a; a++) { var s = new fabric.Rect({ width: n[a].width, height: n[a].width, left: n[a].x + 1, top: n[a].y + 1, originX: "center", originY: "center", fill: this.color }); e.push(s) } this.optimizeOverlapping && (e = this._getOptimizedRects(e)); var c = new fabric.Group(e); this.shadow && c.set("shadow", new fabric.Shadow(this.shadow)), this.canvas.fire("before:path:created", { path: c }), this.canvas.add(c), this.canvas.fire("path:created", { path: c }), this.canvas.clearContext(this.canvas.contextTop), this._resetShadow(), this.canvas.renderOnAddRemove = t, this.canvas.requestRenderAll() }, _getOptimizedRects: function (t) { var e, i, r, n = {}; for (i = 0, r = t.length; r > i; i++)e = t[i].left + "" + t[i].top, n[e] || (n[e] = t[i]); var a = []; for (e in n) a.push(n[e]); return a }, render: function (t) { var e, i, r = this.canvas.contextTop; for (r.fillStyle = this.color, this._saveAndTransform(r), e = 0, i = t.length; i > e; e++) { var n = t[e]; "undefined" != typeof n.opacity && (r.globalAlpha = n.opacity), r.fillRect(n.x, n.y, n.width, n.width) } r.restore() }, _render: function () { var t, e, i = this.canvas.contextTop; for (i.fillStyle = this.color, this._saveAndTransform(i), t = 0, e = this.sprayChunks.length; e > t; t++)this.render(this.sprayChunks[t]); i.restore() }, addSprayChunk: function (t) { this.sprayChunkPoints = []; var e, i, r, n, a = this.width / 2; for (n = 0; n < this.density; n++) { e = fabric.util.getRandomInt(t.x - a, t.x + a), i = fabric.util.getRandomInt(t.y - a, t.y + a), r = this.dotWidthVariance ? fabric.util.getRandomInt(Math.max(1, this.dotWidth - this.dotWidthVariance), this.dotWidth + this.dotWidthVariance) : this.dotWidth; var o = new fabric.Point(e, i); o.width = r, this.randomOpacity && (o.opacity = fabric.util.getRandomInt(0, 100) / 100), this.sprayChunkPoints.push(o) } this.sprayChunks.push(this.sprayChunkPoints) } }); fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, { getPatternSrc: function () { var t = 20, e = 5, i = fabric.util.createCanvasElement(), r = i.getContext("2d"); return i.width = i.height = t + e, r.fillStyle = this.color, r.beginPath(), r.arc(t / 2, t / 2, t / 2, 0, 2 * Math.PI, !1), r.closePath(), r.fill(), i }, getPatternSrcFunction: function () { return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"') }, getPattern: function (t) { return t.createPattern(this.source || this.getPatternSrc(), "repeat") }, _setBrushStyles: function (t) { this.callSuper("_setBrushStyles", t), t.strokeStyle = this.getPattern(t) }, createPath: function (t) { var e = this.callSuper("createPath", t), i = e._getLeftTopCoords().scalarAdd(e.strokeWidth / 2); return e.stroke = new fabric.Pattern({ source: this.source || this.getPatternSrcFunction(), offsetX: -i.x, offsetY: -i.y }), e } }); !function () { var t = fabric.util.getPointer, e = fabric.util.degreesToRadians, i = fabric.util.isTouchEvent; fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, { initialize: function (t, e) { e || (e = {}), this.renderAndResetBound = this.renderAndReset.bind(this), this.requestRenderAllBound = this.requestRenderAll.bind(this), this._initStatic(t, e), this._initInteractive(), this._createCacheCanvas() }, uniformScaling: !0, uniScaleKey: "shiftKey", centeredScaling: !1, centeredRotation: !1, centeredKey: "altKey", altActionKey: "shiftKey", interactive: !0, selection: !0, selectionKey: "shiftKey", altSelectionKey: null, selectionColor: "rgba(100, 100, 255, 0.3)", selectionDashArray: [], selectionBorderColor: "rgba(255, 255, 255, 0.3)", selectionLineWidth: 1, selectionFullyContained: !1, hoverCursor: "move", moveCursor: "move", defaultCursor: "default", freeDrawingCursor: "crosshair", notAllowedCursor: "not-allowed", containerClass: "canvas-container", perPixelTargetFind: !1, targetFindTolerance: 0, skipTargetFind: !1, isDrawingMode: !1, preserveObjectStacking: !1, snapAngle: 0, snapThreshold: null, stopContextMenu: !1, fireRightClick: !1, fireMiddleClick: !1, targets: [], enablePointerEvents: !1, _hoveredTarget: null, _hoveredTargets: [], _initInteractive: function () { this._currentTransform = null, this._groupSelector = null, this._initWrapperElement(), this._createUpperCanvas(), this._initEventListeners(), this._initRetinaScaling(), this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this), this.calcOffset() }, _chooseObjectsToRender: function () { var t, e, i, r = this.getActiveObjects(); if (r.length > 0 && !this.preserveObjectStacking) { e = [], i = []; for (var n = 0, a = this._objects.length; a > n; n++)t = this._objects[n], -1 === r.indexOf(t) ? e.push(t) : i.push(t); r.length > 1 && (this._activeObject._objects = i), e.push.apply(e, i) } else e = this._objects; return e }, renderAll: function () { !this.contextTopDirty || this._groupSelector || this.isDrawingMode || (this.clearContext(this.contextTop), this.contextTopDirty = !1), this.hasLostContext && (this.renderTopLayer(this.contextTop), this.hasLostContext = !1); var t = this.contextContainer; return this.renderCanvas(t, this._chooseObjectsToRender()), this }, renderTopLayer: function (t) { t.save(), this.isDrawingMode && this._isCurrentlyDrawing && (this.freeDrawingBrush && this.freeDrawingBrush._render(), this.contextTopDirty = !0), this.selection && this._groupSelector && (this._drawSelection(t), this.contextTopDirty = !0), t.restore() }, renderTop: function () { var t = this.contextTop; return this.clearContext(t), this.renderTopLayer(t), this.fire("after:render"), this }, _normalizePointer: function (t, e) { var i = t.calcTransformMatrix(), r = fabric.util.invertTransform(i), n = this.restorePointerVpt(e); return fabric.util.transformPoint(n, r) }, isTargetTransparent: function (t, e, i) { if (t.shouldCache() && t._cacheCanvas && t !== this._activeObject) { var r = this._normalizePointer(t, { x: e, y: i }), n = Math.max(t.cacheTranslationX + r.x * t.zoomX, 0), a = Math.max(t.cacheTranslationY + r.y * t.zoomY, 0), s = fabric.util.isTransparent(t._cacheContext, Math.round(n), Math.round(a), this.targetFindTolerance); return s } var o = this.contextCache, c = t.selectionBackgroundColor, l = this.viewportTransform; t.selectionBackgroundColor = "", this.clearContext(o), o.save(), o.transform(l[0], l[1], l[2], l[3], l[4], l[5]), t.render(o), o.restore(), t.selectionBackgroundColor = c; var s = fabric.util.isTransparent(o, e, i, this.targetFindTolerance); return s }, _isSelectionKeyPressed: function (t) { var e = !1; return e = Array.isArray(this.selectionKey) ? !!this.selectionKey.find(function (e) { return t[e] === !0 }) : t[this.selectionKey] }, _shouldClearSelection: function (t, e) { var i = this.getActiveObjects(), r = this._activeObject; return !e || e && r && i.length > 1 && -1 === i.indexOf(e) && r !== e && !this._isSelectionKeyPressed(t) || e && !e.evented || e && !e.selectable && r && r !== e }, _shouldCenterTransform: function (t, e, i) { if (t) { var r; return "scale" === e || "scaleX" === e || "scaleY" === e || "resizing" === e ? r = this.centeredScaling || t.centeredScaling : "rotate" === e && (r = this.centeredRotation || t.centeredRotation), r ? !i : i } }, _getOriginFromCorner: function (t, e) { var i = { x: t.originX, y: t.originY }; return "ml" === e || "tl" === e || "bl" === e ? i.x = "right" : ("mr" === e || "tr" === e || "br" === e) && (i.x = "left"), "tl" === e || "mt" === e || "tr" === e ? i.y = "bottom" : ("bl" === e || "mb" === e || "br" === e) && (i.y = "top"), i }, _getActionFromCorner: function (t, e, i, r) { if (!e || !t) return "drag"; var n = r.controls[e]; return n.getActionName(i, n, r) }, _setupCurrentTransform: function (t, i, r) { if (i) { var n = this.getPointer(t), a = i.__corner, s = i.controls[a], o = r && a ? s.getActionHandler(t, i, s) : fabric.controlsUtils.dragHandler, c = this._getActionFromCorner(r, a, t, i), l = this._getOriginFromCorner(i, a), h = t[this.centeredKey], u = { target: i, action: c, actionHandler: o, corner: a, scaleX: i.scaleX, scaleY: i.scaleY, skewX: i.skewX, skewY: i.skewY, offsetX: n.x - i.left, offsetY: n.y - i.top, originX: l.x, originY: l.y, ex: n.x, ey: n.y, lastX: n.x, lastY: n.y, theta: e(i.angle), width: i.width * i.scaleX, shiftKey: t.shiftKey, altKey: h, original: fabric.util.saveObjectTransform(i) }; this._shouldCenterTransform(i, c, h) && (u.originX = "center", u.originY = "center"), u.original.originX = l.x, u.original.originY = l.y, this._currentTransform = u, this._beforeTransform(t) } }, setCursor: function (t) { this.upperCanvasEl.style.cursor = t }, _drawSelection: function (t) { var e = this._groupSelector, i = new fabric.Point(e.ex, e.ey), r = fabric.util.transformPoint(i, this.viewportTransform), n = new fabric.Point(e.ex + e.left, e.ey + e.top), a = fabric.util.transformPoint(n, this.viewportTransform), s = Math.min(r.x, a.x), o = Math.min(r.y, a.y), c = Math.max(r.x, a.x), l = Math.max(r.y, a.y), h = this.selectionLineWidth / 2; this.selectionColor && (t.fillStyle = this.selectionColor, t.fillRect(s, o, c - s, l - o)), this.selectionLineWidth && this.selectionBorderColor && (t.lineWidth = this.selectionLineWidth, t.strokeStyle = this.selectionBorderColor, s += h, o += h, c -= h, l -= h, fabric.Object.prototype._setLineDash.call(this, t, this.selectionDashArray), t.strokeRect(s, o, c - s, l - o)) }, findTarget: function (t, e) { if (!this.skipTargetFind) { var r, n, a = !0, s = this.getPointer(t, a), o = this._activeObject, c = this.getActiveObjects(), l = i(t), h = c.length > 1 && !e || 1 === c.length; if (this.targets = [], h && o._findTargetCorner(s, l)) return o; if (c.length > 1 && !e && o === this._searchPossibleTargets([o], s)) return o; if (1 === c.length && o === this._searchPossibleTargets([o], s)) { if (!this.preserveObjectStacking) return o; r = o, n = this.targets, this.targets = [] } var u = this._searchPossibleTargets(this._objects, s); return t[this.altSelectionKey] && u && r && u !== r && (u = r, this.targets = n), u } }, _checkTarget: function (t, e, i) { if (e && e.visible && e.evented && e.containsPoint(t)) { if (!this.perPixelTargetFind && !e.perPixelTargetFind || e.isEditing) return !0; var r = this.isTargetTransparent(e, i.x, i.y); if (!r) return !0 } }, _searchPossibleTargets: function (t, e) { for (var i, r, n = t.length; n--;) { var a = t[n], s = a.group ? this._normalizePointer(a.group, e) : e; if (this._checkTarget(s, a, e)) { i = t[n], i.subTargetCheck && i instanceof fabric.Group && (r = this._searchPossibleTargets(i._objects, e), r && this.targets.push(r)); break } } return i }, restorePointerVpt: function (t) { return fabric.util.transformPoint(t, fabric.util.invertTransform(this.viewportTransform)) }, getPointer: function (e, i) { if (this._absolutePointer && !i) return this._absolutePointer; if (this._pointer && i) return this._pointer; var r, n = t(e), a = this.upperCanvasEl, s = a.getBoundingClientRect(), o = s.width || 0, c = s.height || 0; o && c || ("top" in s && "bottom" in s && (c = Math.abs(s.top - s.bottom)), "right" in s && "left" in s && (o = Math.abs(s.right - s.left))), this.calcOffset(), n.x = n.x - this._offset.left, n.y = n.y - this._offset.top, i || (n = this.restorePointerVpt(n)); var l = this.getRetinaScaling(); return 1 !== l && (n.x /= l, n.y /= l), r = 0 === o || 0 === c ? { width: 1, height: 1 } : { width: a.width / o, height: a.height / c }, { x: n.x * r.width, y: n.y * r.height } }, _createUpperCanvas: function () { var t = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), e = this.lowerCanvasEl, i = this.upperCanvasEl; i ? i.className = "" : (i = this._createCanvasElement(), this.upperCanvasEl = i), fabric.util.addClass(i, "upper-canvas " + t), this.wrapperEl.appendChild(i), this._copyCanvasStyle(e, i), this._applyCanvasStyle(i), this.contextTop = i.getContext("2d") }, getTopContext: function () { return this.contextTop }, _createCacheCanvas: function () { this.cacheCanvasEl = this._createCanvasElement(), this.cacheCanvasEl.setAttribute("width", this.width), this.cacheCanvasEl.setAttribute("height", this.height), this.contextCache = this.cacheCanvasEl.getContext("2d") }, _initWrapperElement: function () { this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, "div", { "class": this.containerClass }), fabric.util.setStyle(this.wrapperEl, { width: this.width + "px", height: this.height + "px", position: "relative" }), fabric.util.makeElementUnselectable(this.wrapperEl) }, _applyCanvasStyle: function (t) { var e = this.width || t.width, i = this.height || t.height; fabric.util.setStyle(t, { position: "absolute", width: e + "px", height: i + "px", left: 0, top: 0, "touch-action": this.allowTouchScrolling ? "manipulation" : "none", "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none" }), t.width = e, t.height = i, fabric.util.makeElementUnselectable(t) }, _copyCanvasStyle: function (t, e) { e.style.cssText = t.style.cssText }, getSelectionContext: function () { return this.contextTop }, getSelectionElement: function () { return this.upperCanvasEl }, getActiveObject: function () { return this._activeObject }, getActiveObjects: function () { var t = this._activeObject; return t ? "activeSelection" === t.type && t._objects ? t._objects.slice(0) : [t] : [] }, _onObjectRemoved: function (t) { t === this._activeObject && (this.fire("before:selection:cleared", { target: t }), this._discardActiveObject(), this.fire("selection:cleared", { target: t }), t.fire("deselected")), t === this._hoveredTarget && (this._hoveredTarget = null, this._hoveredTargets = []), this.callSuper("_onObjectRemoved", t) }, _fireSelectionEvents: function (t, e) { var i = !1, r = this.getActiveObjects(), n = [], a = []; t.forEach(function (t) { -1 === r.indexOf(t) && (i = !0, t.fire("deselected", { e: e, target: t }), a.push(t)) }), r.forEach(function (r) { -1 === t.indexOf(r) && (i = !0, r.fire("selected", { e: e, target: r }), n.push(r)) }), t.length > 0 && r.length > 0 ? i && this.fire("selection:updated", { e: e, selected: n, deselected: a }) : r.length > 0 ? this.fire("selection:created", { e: e, selected: n }) : t.length > 0 && this.fire("selection:cleared", { e: e, deselected: a }) }, setActiveObject: function (t, e) { var i = this.getActiveObjects(); return this._setActiveObject(t, e), this._fireSelectionEvents(i, e), this }, _setActiveObject: function (t, e) { return this._activeObject === t ? !1 : this._discardActiveObject(e, t) ? t.onSelect({ e: e }) ? !1 : (this._activeObject = t, !0) : !1 }, _discardActiveObject: function (t, e) { var i = this._activeObject; if (i) { if (i.onDeselect({ e: t, object: e })) return !1; this._activeObject = null } return !0 }, discardActiveObject: function (t) { var e = this.getActiveObjects(), i = this.getActiveObject(); return e.length && this.fire("before:selection:cleared", { target: i, e: t }), this._discardActiveObject(t), this._fireSelectionEvents(e, t), this }, dispose: function () { var t = this.wrapperEl; return this.removeListeners(), t.removeChild(this.upperCanvasEl), t.removeChild(this.lowerCanvasEl), this.contextCache = null, this.contextTop = null, ["upperCanvasEl", "cacheCanvasEl"].forEach(function (t) { fabric.util.cleanUpJsdomNode(this[t]), this[t] = void 0 }.bind(this)), t.parentNode && t.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl), delete this.wrapperEl, fabric.StaticCanvas.prototype.dispose.call(this), this }, clear: function () { return this.discardActiveObject(), this.clearContext(this.contextTop), this.callSuper("clear") }, drawControls: function (t) { var e = this._activeObject; e && e._renderControls(t) }, _toObject: function (t, e, i) { var r = this._realizeGroupTransformOnObject(t), n = this.callSuper("_toObject", t, e, i); return this._unwindGroupTransformOnObject(t, r), n }, _realizeGroupTransformOnObject: function (t) { if (t.group && "activeSelection" === t.group.type && this._activeObject === t.group) { var e = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"], i = {}; return e.forEach(function (e) { i[e] = t[e] }), fabric.util.addTransformToObject(t, this._activeObject.calcOwnMatrix()), i } return null }, _unwindGroupTransformOnObject: function (t, e) { e && t.set(e) }, _setSVGObject: function (t, e, i) { var r = this._realizeGroupTransformOnObject(e); this.callSuper("_setSVGObject", t, e, i), this._unwindGroupTransformOnObject(e, r) }, setViewportTransform: function (t) { this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing && this._activeObject.clearContextTop(), fabric.StaticCanvas.prototype.setViewportTransform.call(this, t) } }); for (var r in fabric.StaticCanvas) "prototype" !== r && (fabric.Canvas[r] = fabric.StaticCanvas[r]) }(); !function () { function t(t, e) { return t.button && t.button === e - 1 } var e = fabric.util.addListener, i = fabric.util.removeListener, r = 3, n = 2, s = 1, a = { passive: !1 }; fabric.util.object.extend(fabric.Canvas.prototype, { mainTouchId: null, _initEventListeners: function () { this.removeListeners(), this._bindEvents(), this.addOrRemove(e, "add") }, _getEventPrefix: function () { return this.enablePointerEvents ? "pointer" : "mouse" }, addOrRemove: function (t, e) { var i = this.upperCanvasEl, r = this._getEventPrefix(); t(fabric.window, "resize", this._onResize), t(i, r + "down", this._onMouseDown), t(i, r + "move", this._onMouseMove, a), t(i, r + "out", this._onMouseOut), t(i, r + "enter", this._onMouseEnter), t(i, "wheel", this._onMouseWheel), t(i, "contextmenu", this._onContextMenu), t(i, "dblclick", this._onDoubleClick), t(i, "dragover", this._onDragOver), t(i, "dragenter", this._onDragEnter), t(i, "dragleave", this._onDragLeave), t(i, "drop", this._onDrop), this.enablePointerEvents || t(i, "touchstart", this._onTouchStart, a), "undefined" != typeof eventjs && e in eventjs && (eventjs[e](i, "gesture", this._onGesture), eventjs[e](i, "drag", this._onDrag), eventjs[e](i, "orientation", this._onOrientationChange), eventjs[e](i, "shake", this._onShake), eventjs[e](i, "longpress", this._onLongPress)) }, removeListeners: function () { this.addOrRemove(i, "remove"); var t = this._getEventPrefix(); i(fabric.document, t + "up", this._onMouseUp), i(fabric.document, "touchend", this._onTouchEnd, a), i(fabric.document, t + "move", this._onMouseMove, a), i(fabric.document, "touchmove", this._onMouseMove, a) }, _bindEvents: function () { this.eventsBound || (this._onMouseDown = this._onMouseDown.bind(this), this._onTouchStart = this._onTouchStart.bind(this), this._onMouseMove = this._onMouseMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._onResize = this._onResize.bind(this), this._onGesture = this._onGesture.bind(this), this._onDrag = this._onDrag.bind(this), this._onShake = this._onShake.bind(this), this._onLongPress = this._onLongPress.bind(this), this._onOrientationChange = this._onOrientationChange.bind(this), this._onMouseWheel = this._onMouseWheel.bind(this), this._onMouseOut = this._onMouseOut.bind(this), this._onMouseEnter = this._onMouseEnter.bind(this), this._onContextMenu = this._onContextMenu.bind(this), this._onDoubleClick = this._onDoubleClick.bind(this), this._onDragOver = this._onDragOver.bind(this), this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter"), this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave"), this._onDrop = this._onDrop.bind(this), this.eventsBound = !0) }, _onGesture: function (t, e) { this.__onTransformGesture && this.__onTransformGesture(t, e) }, _onDrag: function (t, e) { this.__onDrag && this.__onDrag(t, e) }, _onMouseWheel: function (t) { this.__onMouseWheel(t) }, _onMouseOut: function (t) { var e = this._hoveredTarget; this.fire("mouse:out", { target: e, e: t }), this._hoveredTarget = null, e && e.fire("mouseout", { e: t }); var i = this; this._hoveredTargets.forEach(function (r) { i.fire("mouse:out", { target: e, e: t }), r && e.fire("mouseout", { e: t }) }), this._hoveredTargets = [], this._iTextInstances && this._iTextInstances.forEach(function (t) { t.isEditing && t.hiddenTextarea.focus() }) }, _onMouseEnter: function (t) { this._currentTransform || this.findTarget(t) || (this.fire("mouse:over", { target: null, e: t }), this._hoveredTarget = null, this._hoveredTargets = []) }, _onOrientationChange: function (t, e) { this.__onOrientationChange && this.__onOrientationChange(t, e) }, _onShake: function (t, e) { this.__onShake && this.__onShake(t, e) }, _onLongPress: function (t, e) { this.__onLongPress && this.__onLongPress(t, e) }, _onDragOver: function (t) { t.preventDefault(); var e = this._simpleEventHandler("dragover", t); this._fireEnterLeaveEvents(e, t) }, _onDrop: function (t) { return this._simpleEventHandler("drop:before", t), this._simpleEventHandler("drop", t) }, _onContextMenu: function (t) { return this.stopContextMenu && (t.stopPropagation(), t.preventDefault()), !1 }, _onDoubleClick: function (t) { this._cacheTransformEventData(t), this._handleEvent(t, "dblclick"), this._resetTransformEventData(t) }, getPointerId: function (t) { var e = t.changedTouches; return e ? e[0] && e[0].identifier : this.enablePointerEvents ? t.pointerId : -1 }, _isMainEvent: function (t) { return t.isPrimary === !0 ? !0 : t.isPrimary === !1 ? !1 : "touchend" === t.type && 0 === t.touches.length ? !0 : t.changedTouches ? t.changedTouches[0].identifier === this.mainTouchId : !0 }, _onTouchStart: function (t) { t.preventDefault(), null === this.mainTouchId && (this.mainTouchId = this.getPointerId(t)), this.__onMouseDown(t), this._resetTransformEventData(); var r = this.upperCanvasEl, n = this._getEventPrefix(); e(fabric.document, "touchend", this._onTouchEnd, a), e(fabric.document, "touchmove", this._onMouseMove, a), i(r, n + "down", this._onMouseDown) }, _onMouseDown: function (t) { this.__onMouseDown(t), this._resetTransformEventData(); var r = this.upperCanvasEl, n = this._getEventPrefix(); i(r, n + "move", this._onMouseMove, a), e(fabric.document, n + "up", this._onMouseUp), e(fabric.document, n + "move", this._onMouseMove, a) }, _onTouchEnd: function (t) { if (!(t.touches.length > 0)) { this.__onMouseUp(t), this._resetTransformEventData(), this.mainTouchId = null; var r = this._getEventPrefix(); i(fabric.document, "touchend", this._onTouchEnd, a), i(fabric.document, "touchmove", this._onMouseMove, a); var n = this; this._willAddMouseDown && clearTimeout(this._willAddMouseDown), this._willAddMouseDown = setTimeout(function () { e(n.upperCanvasEl, r + "down", n._onMouseDown), n._willAddMouseDown = 0 }, 400) } }, _onMouseUp: function (t) { this.__onMouseUp(t), this._resetTransformEventData(); var r = this.upperCanvasEl, n = this._getEventPrefix(); this._isMainEvent(t) && (i(fabric.document, n + "up", this._onMouseUp), i(fabric.document, n + "move", this._onMouseMove, a), e(r, n + "move", this._onMouseMove, a)) }, _onMouseMove: function (t) { !this.allowTouchScrolling && t.preventDefault && t.preventDefault(), this.__onMouseMove(t) }, _onResize: function () { this.calcOffset() }, _shouldRender: function (t) { var e = this._activeObject; return !!e != !!t || e && t && e !== t ? !0 : e && e.isEditing ? !1 : !1 }, __onMouseUp: function (e) { var i, a = this._currentTransform, o = this._groupSelector, c = !1, h = !o || 0 === o.left && 0 === o.top; if (this._cacheTransformEventData(e), i = this._target, this._handleEvent(e, "up:before"), t(e, r)) return void (this.fireRightClick && this._handleEvent(e, "up", r, h)); if (t(e, n)) return this.fireMiddleClick && this._handleEvent(e, "up", n, h), void this._resetTransformEventData(); if (this.isDrawingMode && this._isCurrentlyDrawing) return void this._onMouseUpInDrawingMode(e); if (this._isMainEvent(e)) { if (a && (this._finalizeCurrentTransform(e), c = a.actionPerformed), !h) { var l = i === this._activeObject; this._maybeGroupObjects(e), c || (c = this._shouldRender(i) || !l && i === this._activeObject) } var u, f; if (i) { if (u = i._findTargetCorner(this.getPointer(e, !0), fabric.util.isTouchEvent(e)), i.selectable && i !== this._activeObject && "up" === i.activeOn) this.setActiveObject(i, e), c = !0; else { var d = i.controls[u], g = d && d.getMouseUpHandler(e, i, d); g && (f = this.getPointer(e), g(e, a, f.x, f.y)) } i.isMoving = !1 } if (a && (a.target !== i || a.corner !== u)) { var p = a.target && a.target.controls[a.corner], v = p && p.getMouseUpHandler(e, i, d); f = f || this.getPointer(e), v && v(e, a, f.x, f.y) } this._setCursorFromEvent(e, i), this._handleEvent(e, "up", s, h), this._groupSelector = null, this._currentTransform = null, i && (i.__corner = 0), c ? this.requestRenderAll() : h || this.renderTop() } }, _simpleEventHandler: function (t, e) { var i = this.findTarget(e), r = this.targets, n = { e: e, target: i, subTargets: r }; if (this.fire(t, n), i && i.fire(t, n), !r) return i; for (var s = 0; s < r.length; s++)r[s].fire(t, n); return i }, _handleEvent: function (t, e, i, r) { var n = this._target, a = this.targets || [], o = { e: t, target: n, subTargets: a, button: i || s, isClick: r || !1, pointer: this._pointer, absolutePointer: this._absolutePointer, transform: this._currentTransform }; "up" === e && (o.currentTarget = this.findTarget(t), o.currentSubTargets = this.targets), this.fire("mouse:" + e, o), n && n.fire("mouse" + e, o); for (var c = 0; c < a.length; c++)a[c].fire("mouse" + e, o) }, _finalizeCurrentTransform: function (t) { var e = this._currentTransform, i = e.target, r = { e: t, target: i, transform: e, action: e.action }; i._scaling && (i._scaling = !1), i.setCoords(), (e.actionPerformed || this.stateful && i.hasStateChanged()) && this._fire("modified", r) }, _onMouseDownInDrawingMode: function (t) { this._isCurrentlyDrawing = !0, this.getActiveObject() && this.discardActiveObject(t).requestRenderAll(); var e = this.getPointer(t); this.freeDrawingBrush.onMouseDown(e, { e: t, pointer: e }), this._handleEvent(t, "down") }, _onMouseMoveInDrawingMode: function (t) { if (this._isCurrentlyDrawing) { var e = this.getPointer(t); this.freeDrawingBrush.onMouseMove(e, { e: t, pointer: e }) } this.setCursor(this.freeDrawingCursor), this._handleEvent(t, "move") }, _onMouseUpInDrawingMode: function (t) { var e = this.getPointer(t); this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: t, pointer: e }), this._handleEvent(t, "up") }, __onMouseDown: function (e) { this._cacheTransformEventData(e), this._handleEvent(e, "down:before"); var i = this._target; if (t(e, r)) return void (this.fireRightClick && this._handleEvent(e, "down", r)); if (t(e, n)) return void (this.fireMiddleClick && this._handleEvent(e, "down", n)); if (this.isDrawingMode) return void this._onMouseDownInDrawingMode(e); if (this._isMainEvent(e) && !this._currentTransform) { var s = this._pointer; this._previousPointer = s; var a = this._shouldRender(i), o = this._shouldGroup(e, i); if (this._shouldClearSelection(e, i) ? this.discardActiveObject(e) : o && (this._handleGrouping(e, i), i = this._activeObject), !this.selection || i && (i.selectable || i.isEditing || i === this._activeObject) || (this._groupSelector = { ex: this._absolutePointer.x, ey: this._absolutePointer.y, top: 0, left: 0 }), i) { var c = i === this._activeObject; i.selectable && "down" === i.activeOn && this.setActiveObject(i, e); var h = i._findTargetCorner(this.getPointer(e, !0), fabric.util.isTouchEvent(e)); if (i.__corner = h, i === this._activeObject && (h || !o)) { this._setupCurrentTransform(e, i, c); var l = i.controls[h], s = this.getPointer(e), u = l && l.getMouseDownHandler(e, i, l); u && u(e, this._currentTransform, s.x, s.y) } } this._handleEvent(e, "down"), (a || o) && this.requestRenderAll() } }, _resetTransformEventData: function () { this._target = null, this._pointer = null, this._absolutePointer = null }, _cacheTransformEventData: function (t) { this._resetTransformEventData(), this._pointer = this.getPointer(t, !0), this._absolutePointer = this.restorePointerVpt(this._pointer), this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(t) || null }, _beforeTransform: function (t) { var e = this._currentTransform; this.stateful && e.target.saveState(), this.fire("before:transform", { e: t, transform: e }) }, __onMouseMove: function (t) { this._handleEvent(t, "move:before"), this._cacheTransformEventData(t); var e, i; if (this.isDrawingMode) return void this._onMouseMoveInDrawingMode(t); if (this._isMainEvent(t)) { var r = this._groupSelector; r ? (i = this._absolutePointer, r.left = i.x - r.ex, r.top = i.y - r.ey, this.renderTop()) : this._currentTransform ? this._transformObject(t) : (e = this.findTarget(t) || null, this._setCursorFromEvent(t, e), this._fireOverOutEvents(e, t)), this._handleEvent(t, "move"), this._resetTransformEventData() } }, _fireOverOutEvents: function (t, e) { var i = this._hoveredTarget, r = this._hoveredTargets, n = this.targets, s = Math.max(r.length, n.length); this.fireSyntheticInOutEvents(t, e, { oldTarget: i, evtOut: "mouseout", canvasEvtOut: "mouse:out", evtIn: "mouseover", canvasEvtIn: "mouse:over" }); for (var a = 0; s > a; a++)this.fireSyntheticInOutEvents(n[a], e, { oldTarget: r[a], evtOut: "mouseout", evtIn: "mouseover" }); this._hoveredTarget = t, this._hoveredTargets = this.targets.concat() }, _fireEnterLeaveEvents: function (t, e) { var i = this._draggedoverTarget, r = this._hoveredTargets, n = this.targets, s = Math.max(r.length, n.length); this.fireSyntheticInOutEvents(t, e, { oldTarget: i, evtOut: "dragleave", evtIn: "dragenter" }); for (var a = 0; s > a; a++)this.fireSyntheticInOutEvents(n[a], e, { oldTarget: r[a], evtOut: "dragleave", evtIn: "dragenter" }); this._draggedoverTarget = t }, fireSyntheticInOutEvents: function (t, e, i) { var r, n, s, a, o = i.oldTarget, c = o !== t, h = i.canvasEvtIn, l = i.canvasEvtOut; c && (r = { e: e, target: t, previousTarget: o }, n = { e: e, target: o, nextTarget: t }), a = t && c, s = o && c, s && (l && this.fire(l, n), o.fire(i.evtOut, n)), a && (h && this.fire(h, r), t.fire(i.evtIn, r)) }, __onMouseWheel: function (t) { this._cacheTransformEventData(t), this._handleEvent(t, "wheel"), this._resetTransformEventData() }, _transformObject: function (t) { var e = this.getPointer(t), i = this._currentTransform; i.reset = !1, i.shiftKey = t.shiftKey, i.altKey = t[this.centeredKey], this._performTransformAction(t, i, e), i.actionPerformed && this.requestRenderAll() }, _performTransformAction: function (t, e, i) { var r = i.x, n = i.y, s = e.action, a = !1, o = e.actionHandler; o && (a = o(t, e, r, n)), "drag" === s && a && (e.target.isMoving = !0, this.setCursor(e.target.moveCursor || this.moveCursor)), e.actionPerformed = e.actionPerformed || a }, _fire: fabric.controlsUtils.fireEvent, _setCursorFromEvent: function (t, e) { if (!e) return this.setCursor(this.defaultCursor), !1; var i = e.hoverCursor || this.hoverCursor, r = this._activeObject && "activeSelection" === this._activeObject.type ? this._activeObject : null, n = (!r || !r.contains(e)) && e._findTargetCorner(this.getPointer(t, !0)); n ? this.setCursor(this.getCornerCursor(n, e, t)) : (e.subTargetCheck && this.targets.concat().reverse().map(function (t) { i = t.hoverCursor || i }), this.setCursor(i)) }, getCornerCursor: function (t, e, i) { var r = e.controls[t]; return r.cursorStyleHandler(i, r, e) } }) }(); !function () { var t = Math.min, e = Math.max; fabric.util.object.extend(fabric.Canvas.prototype, { _shouldGroup: function (t, e) { var i = this._activeObject; return i && this._isSelectionKeyPressed(t) && e && e.selectable && this.selection && (i !== e || "activeSelection" === i.type) && !e.onSelect({ e: t }) }, _handleGrouping: function (t, e) { var i = this._activeObject; i.__corner || (e !== i || (e = this.findTarget(t, !0), e && e.selectable)) && (i && "activeSelection" === i.type ? this._updateActiveSelection(e, t) : this._createActiveSelection(e, t)) }, _updateActiveSelection: function (t, e) { var i = this._activeObject, r = i._objects.slice(0); i.contains(t) ? (i.removeWithUpdate(t), this._hoveredTarget = t, this._hoveredTargets = this.targets.concat(), 1 === i.size() && this._setActiveObject(i.item(0), e)) : (i.addWithUpdate(t), this._hoveredTarget = i, this._hoveredTargets = this.targets.concat()), this._fireSelectionEvents(r, e) }, _createActiveSelection: function (t, e) { var i = this.getActiveObjects(), r = this._createGroup(t); this._hoveredTarget = r, this._setActiveObject(r, e), this._fireSelectionEvents(i, e) }, _createGroup: function (t) { var e = this._objects, i = e.indexOf(this._activeObject) < e.indexOf(t), r = i ? [this._activeObject, t] : [t, this._activeObject]; return this._activeObject.isEditing && this._activeObject.exitEditing(), new fabric.ActiveSelection(r, { canvas: this }) }, _groupSelectedObjects: function (t) { var e, i = this._collectObjects(t); 1 === i.length ? this.setActiveObject(i[0], t) : i.length > 1 && (e = new fabric.ActiveSelection(i.reverse(), { canvas: this }), this.setActiveObject(e, t)) }, _collectObjects: function (i) { for (var r, n = [], s = this._groupSelector.ex, o = this._groupSelector.ey, a = s + this._groupSelector.left, c = o + this._groupSelector.top, h = new fabric.Point(t(s, a), t(o, c)), l = new fabric.Point(e(s, a), e(o, c)), u = !this.selectionFullyContained, f = s === a && o === c, d = this._objects.length; d-- && (r = this._objects[d], !(r && r.selectable && r.visible && (u && r.intersectsWithRect(h, l, !0) || r.isContainedWithinRect(h, l, !0) || u && r.containsPoint(h, null, !0) || u && r.containsPoint(l, null, !0)) && (n.push(r), f)));); return n.length > 1 && (n = n.filter(function (t) { return !t.onSelect({ e: i }) })), n }, _maybeGroupObjects: function (t) { this.selection && this._groupSelector && this._groupSelectedObjects(t), this.setCursor(this.defaultCursor), this._groupSelector = null } }) }(); !function () { fabric.util.object.extend(fabric.StaticCanvas.prototype, { toDataURL: function (t) { t || (t = {}); var e = t.format || "png", i = t.quality || 1, r = (t.multiplier || 1) * (t.enableRetinaScaling ? this.getRetinaScaling() : 1), n = this.toCanvasElement(r, t); return fabric.util.toDataURL(n, e, i) }, toCanvasElement: function (t, e) { t = t || 1, e = e || {}; var i = (e.width || this.width) * t, r = (e.height || this.height) * t, n = this.getZoom(), s = this.width, a = this.height, o = n * t, c = this.viewportTransform, h = (c[4] - (e.left || 0)) * t, l = (c[5] - (e.top || 0)) * t, u = this.interactive, f = [o, 0, 0, o, h, l], d = this.enableRetinaScaling, g = fabric.util.createCanvasElement(), p = this.contextTop; return g.width = i, g.height = r, this.contextTop = null, this.enableRetinaScaling = !1, this.interactive = !1, this.viewportTransform = f, this.width = i, this.height = r, this.calcViewportBoundaries(), this.renderCanvas(g.getContext("2d"), this._objects), this.viewportTransform = c, this.width = s, this.height = a, this.calcViewportBoundaries(), this.interactive = u, this.enableRetinaScaling = d, this.contextTop = p, g } }) }(); fabric.util.object.extend(fabric.StaticCanvas.prototype, { loadFromJSON: function (t, e, i) { if (t) { var r = "string" == typeof t ? JSON.parse(t) : fabric.util.object.clone(t), n = this, s = r.clipPath, a = this.renderOnAddRemove; return this.renderOnAddRemove = !1, delete r.clipPath, this._enlivenObjects(r.objects, function (t) { n.clear(), n._setBgOverlay(r, function () { s ? n._enlivenObjects([s], function (i) { n.clipPath = i[0], n.__setupCanvas.call(n, r, t, a, e) }) : n.__setupCanvas.call(n, r, t, a, e) }) }, i), this } }, __setupCanvas: function (t, e, i, r) { var n = this; e.forEach(function (t, e) { n.insertAt(t, e) }), this.renderOnAddRemove = i, delete t.objects, delete t.backgroundImage, delete t.overlayImage, delete t.background, delete t.overlay, this._setOptions(t), this.renderAll(), r && r() }, _setBgOverlay: function (t, e) { var i = { backgroundColor: !1, overlayColor: !1, backgroundImage: !1, overlayImage: !1 }; if (!(t.backgroundImage || t.overlayImage || t.background || t.overlay)) return void (e && e()); var r = function () { i.backgroundImage && i.overlayImage && i.backgroundColor && i.overlayColor && e && e() }; this.__setBgOverlay("backgroundImage", t.backgroundImage, i, r), this.__setBgOverlay("overlayImage", t.overlayImage, i, r), this.__setBgOverlay("backgroundColor", t.background, i, r), this.__setBgOverlay("overlayColor", t.overlay, i, r) }, __setBgOverlay: function (t, e, i, r) { var n = this; return e ? void ("backgroundImage" === t || "overlayImage" === t ? fabric.util.enlivenObjects([e], function (e) { n[t] = e[0], i[t] = !0, r && r() }) : this["set" + fabric.util.string.capitalize(t, !0)](e, function () { i[t] = !0, r && r() })) : (i[t] = !0, void (r && r())) }, _enlivenObjects: function (t, e, i) { return t && 0 !== t.length ? void fabric.util.enlivenObjects(t, function (t) { e && e(t) }, null, i) : void (e && e([])) }, _toDataURL: function (t, e) { this.clone(function (i) { e(i.toDataURL(t)) }) }, _toDataURLWithMultiplier: function (t, e, i) { this.clone(function (r) { i(r.toDataURLWithMultiplier(t, e)) }) }, clone: function (t, e) { var i = JSON.stringify(this.toJSON(e)); this.cloneWithoutData(function (e) { e.loadFromJSON(i, function () { t && t(e) }) }) }, cloneWithoutData: function (t) { var e = fabric.util.createCanvasElement(); e.width = this.width, e.height = this.height; var i = new fabric.Canvas(e); this.backgroundImage ? (i.setBackgroundImage(this.backgroundImage.src, function () { i.renderAll(), t && t(i) }), i.backgroundImageOpacity = this.backgroundImageOpacity, i.backgroundImageStretch = this.backgroundImageStretch) : t && t(i) } }); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.object.clone, n = e.util.toFixed, s = e.util.string.capitalize, o = e.util.degreesToRadians, a = !e.isLikelyNode, c = 2; e.Object || (e.Object = e.util.createClass(e.CommonMethods, { type: "object", originX: "left", originY: "top", top: 0, left: 0, width: 0, height: 0, scaleX: 1, scaleY: 1, flipX: !1, flipY: !1, opacity: 1, angle: 0, skewX: 0, skewY: 0, cornerSize: 13, touchCornerSize: 24, transparentCorners: !0, hoverCursor: null, moveCursor: null, padding: 0, borderColor: "rgb(178,204,255)", borderDashArray: null, cornerColor: "rgb(178,204,255)", cornerStrokeColor: null, cornerStyle: "rect", cornerDashArray: null, centeredScaling: !1, centeredRotation: !0, fill: "rgb(0,0,0)", fillRule: "nonzero", globalCompositeOperation: "source-over", backgroundColor: "", selectionBackgroundColor: "", stroke: null, strokeWidth: 1, strokeDashArray: null, strokeDashOffset: 0, strokeLineCap: "butt", strokeLineJoin: "miter", strokeMiterLimit: 4, shadow: null, borderOpacityWhenMoving: .4, borderScaleFactor: 1, minScaleLimit: 0, selectable: !0, evented: !0, visible: !0, hasControls: !0, hasBorders: !0, perPixelTargetFind: !1, includeDefaultValues: !0, lockMovementX: !1, lockMovementY: !1, lockRotation: !1, lockScalingX: !1, lockScalingY: !1, lockSkewingX: !1, lockSkewingY: !1, lockScalingFlip: !1, excludeFromExport: !1, objectCaching: a, statefullCache: !1, noScaleCache: !0, strokeUniform: !1, dirty: !0, __corner: 0, paintFirst: "fill", activeOn: "down", stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "), cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "), colorProperties: "fill stroke backgroundColor".split(" "), clipPath: void 0, inverted: !1, absolutePositioned: !1, initialize: function (t) { t && this.setOptions(t) }, _createCacheCanvas: function () { this._cacheProperties = {}, this._cacheCanvas = e.util.createCanvasElement(), this._cacheContext = this._cacheCanvas.getContext("2d"), this._updateCacheCanvas(), this.dirty = !0 }, _limitCacheSize: function (t) { var i = e.perfLimitSizeTotal, r = t.width, n = t.height, s = e.maxCacheSideLimit, o = e.minCacheSideLimit; if (s >= r && s >= n && i >= r * n) return o > r && (t.width = o), o > n && (t.height = o), t; var a = r / n, c = e.util.limitDimsByArea(a, i), h = e.util.capValue, l = h(o, c.x, s), u = h(o, c.y, s); return r > l && (t.zoomX /= r / l, t.width = l, t.capped = !0), n > u && (t.zoomY /= n / u, t.height = u, t.capped = !0), t }, _getCacheCanvasDimensions: function () { var t = this.getTotalObjectScaling(), e = this._getTransformedDimensions(0, 0), i = e.x * t.scaleX / this.scaleX, r = e.y * t.scaleY / this.scaleY; return { width: i + c, height: r + c, zoomX: t.scaleX, zoomY: t.scaleY, x: i, y: r } }, _updateCacheCanvas: function () { var t = this.canvas; if (this.noScaleCache && t && t._currentTransform) { var i = t._currentTransform.target, r = t._currentTransform.action; if (this === i && r.slice && "scale" === r.slice(0, 5)) return !1 } var n, s, o = this._cacheCanvas, a = this._limitCacheSize(this._getCacheCanvasDimensions()), c = e.minCacheSideLimit, h = a.width, l = a.height, u = a.zoomX, f = a.zoomY, d = h !== this.cacheWidth || l !== this.cacheHeight, g = this.zoomX !== u || this.zoomY !== f, p = d || g, v = 0, m = 0, b = !1; if (d) { var _ = this._cacheCanvas.width, y = this._cacheCanvas.height, x = h > _ || l > y, C = (.9 * _ > h || .9 * y > l) && _ > c && y > c; b = x || C, x && !a.capped && (h > c || l > c) && (v = .1 * h, m = .1 * l) } return this instanceof e.Text && this.path && (p = !0, b = !0, v += this.getHeightOfLine(0) * this.zoomX, m += this.getHeightOfLine(0) * this.zoomY), p ? (b ? (o.width = Math.ceil(h + v), o.height = Math.ceil(l + m)) : (this._cacheContext.setTransform(1, 0, 0, 1, 0, 0), this._cacheContext.clearRect(0, 0, o.width, o.height)), n = a.x / 2, s = a.y / 2, this.cacheTranslationX = Math.round(o.width / 2 - n) + n, this.cacheTranslationY = Math.round(o.height / 2 - s) + s, this.cacheWidth = h, this.cacheHeight = l, this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY), this._cacheContext.scale(u, f), this.zoomX = u, this.zoomY = f, !0) : !1 }, setOptions: function (t) { this._setOptions(t), this._initGradient(t.fill, "fill"), this._initGradient(t.stroke, "stroke"), this._initPattern(t.fill, "fill"), this._initPattern(t.stroke, "stroke") }, transform: function (t) { var e = this.group && !this.group._transformDone || this.group && this.canvas && t === this.canvas.contextTop, i = this.calcTransformMatrix(!e); t.transform(i[0], i[1], i[2], i[3], i[4], i[5]) }, toObject: function (t) { var i = e.Object.NUM_FRACTION_DIGITS, r = { type: this.type, version: e.version, originX: this.originX, originY: this.originY, left: n(this.left, i), top: n(this.top, i), width: n(this.width, i), height: n(this.height, i), fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill, stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke, strokeWidth: n(this.strokeWidth, i), strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray, strokeLineCap: this.strokeLineCap, strokeDashOffset: this.strokeDashOffset, strokeLineJoin: this.strokeLineJoin, strokeUniform: this.strokeUniform, strokeMiterLimit: n(this.strokeMiterLimit, i), scaleX: n(this.scaleX, i), scaleY: n(this.scaleY, i), angle: n(this.angle, i), flipX: this.flipX, flipY: this.flipY, opacity: n(this.opacity, i), shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow, visible: this.visible, backgroundColor: this.backgroundColor, fillRule: this.fillRule, paintFirst: this.paintFirst, globalCompositeOperation: this.globalCompositeOperation, skewX: n(this.skewX, i), skewY: n(this.skewY, i) }; return this.clipPath && !this.clipPath.excludeFromExport && (r.clipPath = this.clipPath.toObject(t), r.clipPath.inverted = this.clipPath.inverted, r.clipPath.absolutePositioned = this.clipPath.absolutePositioned), e.util.populateWithProperties(this, r, t), this.includeDefaultValues || (r = this._removeDefaultValues(r)), r }, toDatalessObject: function (t) { return this.toObject(t) }, _removeDefaultValues: function (t) { var i = e.util.getKlass(t.type).prototype, r = i.stateProperties; return r.forEach(function (e) { "left" !== e && "top" !== e && (t[e] === i[e] && delete t[e], Array.isArray(t[e]) && Array.isArray(i[e]) && 0 === t[e].length && 0 === i[e].length && delete t[e]) }), t }, toString: function () { return "#<fabric." + s(this.type) + ">" }, getObjectScaling: function () { if (!this.group) return { scaleX: this.scaleX, scaleY: this.scaleY }; var t = e.util.qrDecompose(this.calcTransformMatrix()); return { scaleX: Math.abs(t.scaleX), scaleY: Math.abs(t.scaleY) } }, getTotalObjectScaling: function () { var t = this.getObjectScaling(), e = t.scaleX, i = t.scaleY; if (this.canvas) { var r = this.canvas.getZoom(), n = this.canvas.getRetinaScaling(); e *= r * n, i *= r * n } return { scaleX: e, scaleY: i } }, getObjectOpacity: function () { var t = this.opacity; return this.group && (t *= this.group.getObjectOpacity()), t }, _set: function (t, i) { var r = "scaleX" === t || "scaleY" === t, n = this[t] !== i, s = !1; return r && (i = this._constrainScale(i)), "scaleX" === t && 0 > i ? (this.flipX = !this.flipX, i *= -1) : "scaleY" === t && 0 > i ? (this.flipY = !this.flipY, i *= -1) : "shadow" !== t || !i || i instanceof e.Shadow ? "dirty" === t && this.group && this.group.set("dirty", i) : i = new e.Shadow(i), this[t] = i, n && (s = this.group && this.group.isOnACache(), this.cacheProperties.indexOf(t) > -1 ? (this.dirty = !0, s && this.group.set("dirty", !0)) : s && this.stateProperties.indexOf(t) > -1 && this.group.set("dirty", !0)), this }, setOnGroup: function () { }, getViewportTransform: function () { return this.canvas && this.canvas.viewportTransform ? this.canvas.viewportTransform : e.iMatrix.concat() }, isNotVisible: function () { return 0 === this.opacity || !this.width && !this.height && 0 === this.strokeWidth || !this.visible }, render: function (t) { this.isNotVisible() || (!this.canvas || !this.canvas.skipOffscreen || this.group || this.isOnScreen()) && (t.save(), this._setupCompositeOperation(t), this.drawSelectionBackground(t), this.transform(t), this._setOpacity(t), this._setShadow(t, this), this.shouldCache() ? (this.renderCache(), this.drawCacheOnCanvas(t)) : (this._removeCacheCanvas(), this.dirty = !1, this.drawObject(t), this.objectCaching && this.statefullCache && this.saveState({ propertySet: "cacheProperties" })), t.restore()) }, renderCache: function (t) { t = t || {}, this._cacheCanvas && this._cacheContext || this._createCacheCanvas(), this.isCacheDirty() && (this.statefullCache && this.saveState({ propertySet: "cacheProperties" }), this.drawObject(this._cacheContext, t.forClipping), this.dirty = !1) }, _removeCacheCanvas: function () { this._cacheCanvas = null, this._cacheContext = null, this.cacheWidth = 0, this.cacheHeight = 0 }, hasStroke: function () { return this.stroke && "transparent" !== this.stroke && 0 !== this.strokeWidth }, hasFill: function () { return this.fill && "transparent" !== this.fill }, needsItsOwnCache: function () { return "stroke" === this.paintFirst && this.hasFill() && this.hasStroke() && "object" == typeof this.shadow ? !0 : this.clipPath ? !0 : !1 }, shouldCache: function () { return this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache()), this.ownCaching }, willDrawShadow: function () { return !!this.shadow && (0 !== this.shadow.offsetX || 0 !== this.shadow.offsetY) }, drawClipPathOnCache: function (t, i) { if (t.save(), t.globalCompositeOperation = i.inverted ? "destination-out" : "destination-in", i.absolutePositioned) { var r = e.util.invertTransform(this.calcTransformMatrix()); t.transform(r[0], r[1], r[2], r[3], r[4], r[5]) } i.transform(t), t.scale(1 / i.zoomX, 1 / i.zoomY), t.drawImage(i._cacheCanvas, -i.cacheTranslationX, -i.cacheTranslationY), t.restore() }, drawObject: function (t, e) { var i = this.fill, r = this.stroke; e ? (this.fill = "black", this.stroke = "", this._setClippingProperties(t)) : this._renderBackground(t), this._render(t), this._drawClipPath(t, this.clipPath), this.fill = i, this.stroke = r }, _drawClipPath: function (t, e) { e && (e.canvas = this.canvas, e.shouldCache(), e._transformDone = !0, e.renderCache({ forClipping: !0 }), this.drawClipPathOnCache(t, e)) }, drawCacheOnCanvas: function (t) { t.scale(1 / this.zoomX, 1 / this.zoomY), t.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY) }, isCacheDirty: function (t) { if (this.isNotVisible()) return !1; if (this._cacheCanvas && this._cacheContext && !t && this._updateCacheCanvas()) return !0; if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) { if (this._cacheCanvas && this._cacheContext && !t) { var e = this.cacheWidth / this.zoomX, i = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-e / 2, -i / 2, e, i) } return !0 } return !1 }, _renderBackground: function (t) { if (this.backgroundColor) { var e = this._getNonTransformedDimensions(); t.fillStyle = this.backgroundColor, t.fillRect(-e.x / 2, -e.y / 2, e.x, e.y), this._removeShadow(t) } }, _setOpacity: function (t) { this.group && !this.group._transformDone ? t.globalAlpha = this.getObjectOpacity() : t.globalAlpha *= this.opacity }, _setStrokeStyles: function (t, e) { var i = e.stroke; i && (t.lineWidth = e.strokeWidth, t.lineCap = e.strokeLineCap, t.lineDashOffset = e.strokeDashOffset, t.lineJoin = e.strokeLineJoin, t.miterLimit = e.strokeMiterLimit, i.toLive ? "percentage" === i.gradientUnits || i.gradientTransform || i.patternTransform ? this._applyPatternForTransformedGradient(t, i) : (t.strokeStyle = i.toLive(t, this), this._applyPatternGradientTransform(t, i)) : t.strokeStyle = e.stroke) }, _setFillStyles: function (t, e) { var i = e.fill; i && (i.toLive ? (t.fillStyle = i.toLive(t, this), this._applyPatternGradientTransform(t, e.fill)) : t.fillStyle = i) }, _setClippingProperties: function (t) { t.globalAlpha = 1, t.strokeStyle = "transparent", t.fillStyle = "#000000" }, _setLineDash: function (t, e) { e && 0 !== e.length && (1 & e.length && e.push.apply(e, e), t.setLineDash(e)) }, _renderControls: function (t, i) { var r, n, s, a = this.getViewportTransform(), c = this.calcTransformMatrix(); i = i || {}, n = "undefined" != typeof i.hasBorders ? i.hasBorders : this.hasBorders, s = "undefined" != typeof i.hasControls ? i.hasControls : this.hasControls, c = e.util.multiplyTransformMatrices(a, c), r = e.util.qrDecompose(c), t.save(), t.translate(r.translateX, r.translateY), t.lineWidth = 1 * this.borderScaleFactor, this.group || (t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1), this.flipX && (r.angle -= 180), t.rotate(o(this.group ? r.angle : this.angle)), i.forActiveSelection || this.group ? n && this.drawBordersInGroup(t, r, i) : n && this.drawBorders(t, i), s && this.drawControls(t, i), t.restore() }, _setShadow: function (t) { if (this.shadow) { var i, r = this.shadow, n = this.canvas, s = n && n.viewportTransform[0] || 1, o = n && n.viewportTransform[3] || 1; i = r.nonScaling ? { scaleX: 1, scaleY: 1 } : this.getObjectScaling(), n && n._isRetinaScaling() && (s *= e.devicePixelRatio, o *= e.devicePixelRatio), t.shadowColor = r.color, t.shadowBlur = r.blur * e.browserShadowBlurConstant * (s + o) * (i.scaleX + i.scaleY) / 4, t.shadowOffsetX = r.offsetX * s * i.scaleX, t.shadowOffsetY = r.offsetY * o * i.scaleY } }, _removeShadow: function (t) { this.shadow && (t.shadowColor = "", t.shadowBlur = t.shadowOffsetX = t.shadowOffsetY = 0) }, _applyPatternGradientTransform: function (t, e) { if (!e || !e.toLive) return { offsetX: 0, offsetY: 0 }; var i = e.gradientTransform || e.patternTransform, r = -this.width / 2 + e.offsetX || 0, n = -this.height / 2 + e.offsetY || 0; return "percentage" === e.gradientUnits ? t.transform(this.width, 0, 0, this.height, r, n) : t.transform(1, 0, 0, 1, r, n), i && t.transform(i[0], i[1], i[2], i[3], i[4], i[5]), { offsetX: r, offsetY: n } }, _renderPaintInOrder: function (t) { "stroke" === this.paintFirst ? (this._renderStroke(t), this._renderFill(t)) : (this._renderFill(t), this._renderStroke(t)) }, _render: function () { }, _renderFill: function (t) { this.fill && (t.save(), this._setFillStyles(t, this), "evenodd" === this.fillRule ? t.fill("evenodd") : t.fill(), t.restore()) }, _renderStroke: function (t) { if (this.stroke && 0 !== this.strokeWidth) { if (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this.strokeUniform && this.group) { var e = this.getObjectScaling(); t.scale(1 / e.scaleX, 1 / e.scaleY) } else this.strokeUniform && t.scale(1 / this.scaleX, 1 / this.scaleY); this._setLineDash(t, this.strokeDashArray), this._setStrokeStyles(t, this), t.stroke(), t.restore() } }, _applyPatternForTransformedGradient: function (t, i) { var r, n = this._limitCacheSize(this._getCacheCanvasDimensions()), s = e.util.createCanvasElement(), o = this.canvas.getRetinaScaling(), a = n.x / this.scaleX / o, c = n.y / this.scaleY / o; s.width = a, s.height = c, r = s.getContext("2d"), r.beginPath(), r.moveTo(0, 0), r.lineTo(a, 0), r.lineTo(a, c), r.lineTo(0, c), r.closePath(), r.translate(a / 2, c / 2), r.scale(n.zoomX / this.scaleX / o, n.zoomY / this.scaleY / o), this._applyPatternGradientTransform(r, i), r.fillStyle = i.toLive(t), r.fill(), t.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2), t.scale(o * this.scaleX / n.zoomX, o * this.scaleY / n.zoomY), t.strokeStyle = r.createPattern(s, "no-repeat") }, _findCenterFromElement: function () { return { x: this.left + this.width / 2, y: this.top + this.height / 2 } }, _assignTransformMatrixProps: function () { if (this.transformMatrix) { var t = e.util.qrDecompose(this.transformMatrix); this.flipX = !1, this.flipY = !1, this.set("scaleX", t.scaleX), this.set("scaleY", t.scaleY), this.angle = t.angle, this.skewX = t.skewX, this.skewY = 0 } }, _removeTransformMatrix: function (t) { var i = this._findCenterFromElement(); this.transformMatrix && (this._assignTransformMatrixProps(), i = e.util.transformPoint(i, this.transformMatrix)), this.transformMatrix = null, t && (this.scaleX *= t.scaleX, this.scaleY *= t.scaleY, this.cropX = t.cropX, this.cropY = t.cropY, i.x += t.offsetLeft, i.y += t.offsetTop, this.width = t.width, this.height = t.height), this.setPositionByOrigin(i, "center", "center") }, clone: function (t, i) { var r = this.toObject(i); this.constructor.fromObject ? this.constructor.fromObject(r, t) : e.Object._fromObject("Object", r, t) }, cloneAsImage: function (t, i) { var r = this.toCanvasElement(i); return t && t(new e.Image(r)), this }, toCanvasElement: function (t) { t || (t = {}); var i = e.util, r = i.saveObjectTransform(this), n = this.group, s = this.shadow, o = Math.abs, a = (t.multiplier || 1) * (t.enableRetinaScaling ? e.devicePixelRatio : 1); delete this.group, t.withoutTransform && i.resetObjectTransform(this), t.withoutShadow && (this.shadow = null); var c, h, l, u, f = e.util.createCanvasElement(), d = this.getBoundingRect(!0, !0), g = this.shadow, p = { x: 0, y: 0 }; g && (h = g.blur, c = g.nonScaling ? { scaleX: 1, scaleY: 1 } : this.getObjectScaling(), p.x = 2 * Math.round(o(g.offsetX) + h) * o(c.scaleX), p.y = 2 * Math.round(o(g.offsetY) + h) * o(c.scaleY)), l = d.width + p.x, u = d.height + p.y, f.width = Math.ceil(l), f.height = Math.ceil(u); var v = new e.StaticCanvas(f, { enableRetinaScaling: !1, renderOnAddRemove: !1, skipOffscreen: !1 }); "jpeg" === t.format && (v.backgroundColor = "#fff"), this.setPositionByOrigin(new e.Point(v.width / 2, v.height / 2), "center", "center"); var m = this.canvas; v.add(this); var b = v.toCanvasElement(a || 1, t); return this.shadow = s, this.set("canvas", m), n && (this.group = n), this.set(r).setCoords(), v._objects = [], v.dispose(), v = null, b }, toDataURL: function (t) { return t || (t = {}), e.util.toDataURL(this.toCanvasElement(t), t.format || "png", t.quality || 1) }, isType: function (t) { return arguments.length > 1 ? Array.from(arguments).includes(this.type) : this.type === t }, complexity: function () { return 1 }, toJSON: function (t) { return this.toObject(t) }, rotate: function (t) { var e = ("center" !== this.originX || "center" !== this.originY) && this.centeredRotation; return e && this._setOriginToCenter(), this.set("angle", t), e && this._resetOrigin(), this }, centerH: function () { return this.canvas && this.canvas.centerObjectH(this), this }, viewportCenterH: function () { return this.canvas && this.canvas.viewportCenterObjectH(this), this }, centerV: function () { return this.canvas && this.canvas.centerObjectV(this), this }, viewportCenterV: function () { return this.canvas && this.canvas.viewportCenterObjectV(this), this }, center: function () { return this.canvas && this.canvas.centerObject(this), this }, viewportCenter: function () { return this.canvas && this.canvas.viewportCenterObject(this), this }, getLocalPointer: function (t, i) { i = i || this.canvas.getPointer(t); var r = new e.Point(i.x, i.y), n = this._getLeftTopCoords(); return this.angle && (r = e.util.rotatePoint(r, n, o(-this.angle))), { x: r.x - n.x, y: r.y - n.y } }, _setupCompositeOperation: function (t) { this.globalCompositeOperation && (t.globalCompositeOperation = this.globalCompositeOperation) }, dispose: function () { e.runningAnimations && e.runningAnimations.cancelByTarget(this) } }), e.util.createAccessors && e.util.createAccessors(e.Object), i(e.Object.prototype, e.Observable), e.Object.NUM_FRACTION_DIGITS = 2, e.Object.ENLIVEN_PROPS = ["clipPath"], e.Object._fromObject = function (t, i, n, s) { var o = e[t]; i = r(i, !0), e.util.enlivenPatterns([i.fill, i.stroke], function (t) { "undefined" != typeof t[0] && (i.fill = t[0]), "undefined" != typeof t[1] && (i.stroke = t[1]), e.util.enlivenObjectEnlivables(i, i, function () { var t = s ? new o(i[s], i) : new o(i); n && n(t) }) }) }, e.Object.__uid = 0) }("undefined" != typeof exports ? exports : this); !function () { var t = fabric.util.degreesToRadians, e = { left: -.5, center: 0, right: .5 }, i = { top: -.5, center: 0, bottom: .5 }; fabric.util.object.extend(fabric.Object.prototype, { translateToGivenOrigin: function (t, r, n, s, o) { var a, c, h, l = t.x, u = t.y; return "string" == typeof r ? r = e[r] : r -= .5, "string" == typeof s ? s = e[s] : s -= .5, a = s - r, "string" == typeof n ? n = i[n] : n -= .5, "string" == typeof o ? o = i[o] : o -= .5, c = o - n, (a || c) && (h = this._getTransformedDimensions(), l = t.x + a * h.x, u = t.y + c * h.y), new fabric.Point(l, u) }, translateToCenterPoint: function (e, i, r) { var n = this.translateToGivenOrigin(e, i, r, "center", "center"); return this.angle ? fabric.util.rotatePoint(n, e, t(this.angle)) : n }, translateToOriginPoint: function (e, i, r) { var n = this.translateToGivenOrigin(e, "center", "center", i, r); return this.angle ? fabric.util.rotatePoint(n, e, t(this.angle)) : n }, getCenterPoint: function () { var t = new fabric.Point(this.left, this.top); return this.translateToCenterPoint(t, this.originX, this.originY) }, getPointByOrigin: function (t, e) { var i = this.getCenterPoint(); return this.translateToOriginPoint(i, t, e) }, toLocalPoint: function (e, i, r) { var n, s, o = this.getCenterPoint(); return n = "undefined" != typeof i && "undefined" != typeof r ? this.translateToGivenOrigin(o, "center", "center", i, r) : new fabric.Point(this.left, this.top), s = new fabric.Point(e.x, e.y), this.angle && (s = fabric.util.rotatePoint(s, o, -t(this.angle))), s.subtractEquals(n) }, setPositionByOrigin: function (t, e, i) { var r = this.translateToCenterPoint(t, e, i), n = this.translateToOriginPoint(r, this.originX, this.originY); this.set("left", n.x), this.set("top", n.y) }, adjustPosition: function (i) { var r, n, s = t(this.angle), o = this.getScaledWidth(), a = fabric.util.cos(s) * o, c = fabric.util.sin(s) * o; r = "string" == typeof this.originX ? e[this.originX] : this.originX - .5, n = "string" == typeof i ? e[i] : i - .5, this.left += a * (n - r), this.top += c * (n - r), this.setCoords(), this.originX = i }, _setOriginToCenter: function () { this._originalOriginX = this.originX, this._originalOriginY = this.originY; var t = this.getCenterPoint(); this.originX = "center", this.originY = "center", this.left = t.x, this.top = t.y }, _resetOrigin: function () { var t = this.translateToOriginPoint(this.getCenterPoint(), this._originalOriginX, this._originalOriginY); this.originX = this._originalOriginX, this.originY = this._originalOriginY, this.left = t.x, this.top = t.y, this._originalOriginX = null, this._originalOriginY = null }, _getLeftTopCoords: function () { return this.translateToOriginPoint(this.getCenterPoint(), "left", "top") } }) }(); !function () { function t(t) { return [new fabric.Point(t.tl.x, t.tl.y), new fabric.Point(t.tr.x, t.tr.y), new fabric.Point(t.br.x, t.br.y), new fabric.Point(t.bl.x, t.bl.y)] } var e = fabric.util, i = e.degreesToRadians, r = e.multiplyTransformMatrices, n = e.transformPoint; e.object.extend(fabric.Object.prototype, { oCoords: null, aCoords: null, lineCoords: null, ownMatrixCache: null, matrixCache: null, controls: {}, _getCoords: function (t, e) { return e ? t ? this.calcACoords() : this.calcLineCoords() : (this.aCoords && this.lineCoords || this.setCoords(!0), t ? this.aCoords : this.lineCoords) }, getCoords: function (e, i) { return t(this._getCoords(e, i)) }, intersectsWithRect: function (t, e, i, r) { var n = this.getCoords(i, r), s = fabric.Intersection.intersectPolygonRectangle(n, t, e); return "Intersection" === s.status }, intersectsWithObject: function (t, e, i) { var r = fabric.Intersection.intersectPolygonPolygon(this.getCoords(e, i), t.getCoords(e, i)); return "Intersection" === r.status || t.isContainedWithinObject(this, e, i) || this.isContainedWithinObject(t, e, i) }, isContainedWithinObject: function (t, e, i) { for (var r = this.getCoords(e, i), n = e ? t.aCoords : t.lineCoords, s = 0, o = t._getImageLines(n); 4 > s; s++)if (!t.containsPoint(r[s], o)) return !1; return !0 }, isContainedWithinRect: function (t, e, i, r) { var n = this.getBoundingRect(i, r); return n.left >= t.x && n.left + n.width <= e.x && n.top >= t.y && n.top + n.height <= e.y }, containsPoint: function (t, e, i, r) { var n = this._getCoords(i, r), e = e || this._getImageLines(n), s = this._findCrossPoints(t, e); return 0 !== s && s % 2 === 1 }, isOnScreen: function (t) { if (!this.canvas) return !1; var e = this.canvas.vptCoords.tl, i = this.canvas.vptCoords.br, r = this.getCoords(!0, t); return r.some(function (t) { return t.x <= i.x && t.x >= e.x && t.y <= i.y && t.y >= e.y }) ? !0 : this.intersectsWithRect(e, i, !0, t) ? !0 : this._containsCenterOfCanvas(e, i, t) }, _containsCenterOfCanvas: function (t, e, i) { var r = { x: (t.x + e.x) / 2, y: (t.y + e.y) / 2 }; return this.containsPoint(r, null, !0, i) ? !0 : !1 }, isPartiallyOnScreen: function (t) { if (!this.canvas) return !1; var e = this.canvas.vptCoords.tl, i = this.canvas.vptCoords.br; if (this.intersectsWithRect(e, i, !0, t)) return !0; var r = this.getCoords(!0, t).every(function (t) { return (t.x >= i.x || t.x <= e.x) && (t.y >= i.y || t.y <= e.y) }); return r && this._containsCenterOfCanvas(e, i, t) }, _getImageLines: function (t) { var e = { topline: { o: t.tl, d: t.tr }, rightline: { o: t.tr, d: t.br }, bottomline: { o: t.br, d: t.bl }, leftline: { o: t.bl, d: t.tl } }; return e }, _findCrossPoints: function (t, e) { var i, r, n, s, o, a, c = 0; for (var h in e) if (a = e[h], !(a.o.y < t.y && a.d.y < t.y || a.o.y >= t.y && a.d.y >= t.y || (a.o.x === a.d.x && a.o.x >= t.x ? o = a.o.x : (i = 0, r = (a.d.y - a.o.y) / (a.d.x - a.o.x), n = t.y - i * t.x, s = a.o.y - r * a.o.x, o = -(n - s) / (i - r)), o >= t.x && (c += 1), 2 !== c))) break; return c }, getBoundingRect: function (t, i) { var r = this.getCoords(t, i); return e.makeBoundingBoxFromPoints(r) }, getScaledWidth: function () { return this._getTransformedDimensions().x }, getScaledHeight: function () { return this._getTransformedDimensions().y }, _constrainScale: function (t) { return Math.abs(t) < this.minScaleLimit ? 0 > t ? -this.minScaleLimit : this.minScaleLimit : 0 === t ? 1e-4 : t }, scale: function (t) { return this._set("scaleX", t), this._set("scaleY", t), this.setCoords() }, scaleToWidth: function (t, e) { var i = this.getBoundingRect(e).width / this.getScaledWidth(); return this.scale(t / this.width / i) }, scaleToHeight: function (t, e) { var i = this.getBoundingRect(e).height / this.getScaledHeight(); return this.scale(t / this.height / i) }, calcLineCoords: function () { var t = this.getViewportTransform(), r = this.padding, s = i(this.angle), o = e.cos(s), a = e.sin(s), c = o * r, h = a * r, l = c + h, u = c - h, f = this.calcACoords(), d = { tl: n(f.tl, t), tr: n(f.tr, t), bl: n(f.bl, t), br: n(f.br, t) }; return r && (d.tl.x -= u, d.tl.y -= l, d.tr.x += l, d.tr.y -= u, d.bl.x -= l, d.bl.y += u, d.br.x += u, d.br.y += l), d }, calcOCoords: function () { var t = this._calcRotateMatrix(), e = this._calcTranslateMatrix(), i = this.getViewportTransform(), n = r(i, e), s = r(n, t), s = r(s, [1 / i[0], 0, 0, 1 / i[3], 0, 0]), o = this._calculateCurrentDimensions(), a = {}; return this.forEachControl(function (t, e, i) { a[e] = t.positionHandler(o, s, i) }), a }, calcACoords: function () { var t = this._calcRotateMatrix(), e = this._calcTranslateMatrix(), i = r(e, t), s = this._getTransformedDimensions(), o = s.x / 2, a = s.y / 2; return { tl: n({ x: -o, y: -a }, i), tr: n({ x: o, y: -a }, i), bl: n({ x: -o, y: a }, i), br: n({ x: o, y: a }, i) } }, setCoords: function (t) { return this.aCoords = this.calcACoords(), this.lineCoords = this.group ? this.aCoords : this.calcLineCoords(), t ? this : (this.oCoords = this.calcOCoords(), this._setCornerCoords && this._setCornerCoords(), this) }, _calcRotateMatrix: function () { return e.calcRotateMatrix(this) }, _calcTranslateMatrix: function () { var t = this.getCenterPoint(); return [1, 0, 0, 1, t.x, t.y] }, transformMatrixKey: function (t) { var e = "_", i = ""; return !t && this.group && (i = this.group.transformMatrixKey(t) + e), i + this.top + e + this.left + e + this.scaleX + e + this.scaleY + e + this.skewX + e + this.skewY + e + this.angle + e + this.originX + e + this.originY + e + this.width + e + this.height + e + this.strokeWidth + this.flipX + this.flipY }, calcTransformMatrix: function (t) { var e = this.calcOwnMatrix(); if (t || !this.group) return e; var i = this.transformMatrixKey(t), n = this.matrixCache || (this.matrixCache = {}); return n.key === i ? n.value : (this.group && (e = r(this.group.calcTransformMatrix(!1), e)), n.key = i, n.value = e, e) }, calcOwnMatrix: function () { var t = this.transformMatrixKey(!0), i = this.ownMatrixCache || (this.ownMatrixCache = {}); if (i.key === t) return i.value; var r = this._calcTranslateMatrix(), n = { angle: this.angle, translateX: r[4], translateY: r[5], scaleX: this.scaleX, scaleY: this.scaleY, skewX: this.skewX, skewY: this.skewY, flipX: this.flipX, flipY: this.flipY }; return i.key = t, i.value = e.composeMatrix(n), i.value }, _getNonTransformedDimensions: function () { var t = this.strokeWidth, e = this.width + t, i = this.height + t; return { x: e, y: i } }, _getTransformedDimensions: function (t, i) { "undefined" == typeof t && (t = this.skewX), "undefined" == typeof i && (i = this.skewY); var r, n, s, o = 0 === t && 0 === i; if (this.strokeUniform ? (n = this.width, s = this.height) : (r = this._getNonTransformedDimensions(), n = r.x, s = r.y), o) return this._finalizeDimensions(n * this.scaleX, s * this.scaleY); var a = e.sizeAfterTransform(n, s, { scaleX: this.scaleX, scaleY: this.scaleY, skewX: t, skewY: i }); return this._finalizeDimensions(a.x, a.y) }, _finalizeDimensions: function (t, e) { return this.strokeUniform ? { x: t + this.strokeWidth, y: e + this.strokeWidth } : { x: t, y: e } }, _calculateCurrentDimensions: function () { var t = this.getViewportTransform(), e = this._getTransformedDimensions(), i = n(e, t, !0); return i.scalarAdd(2 * this.padding) } }) }(); fabric.util.object.extend(fabric.Object.prototype, { sendToBack: function () { return this.group ? fabric.StaticCanvas.prototype.sendToBack.call(this.group, this) : this.canvas && this.canvas.sendToBack(this), this }, bringToFront: function () { return this.group ? fabric.StaticCanvas.prototype.bringToFront.call(this.group, this) : this.canvas && this.canvas.bringToFront(this), this }, sendBackwards: function (t) { return this.group ? fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, t) : this.canvas && this.canvas.sendBackwards(this, t), this }, bringForward: function (t) { return this.group ? fabric.StaticCanvas.prototype.bringForward.call(this.group, this, t) : this.canvas && this.canvas.bringForward(this, t), this }, moveTo: function (t) { return this.group && "activeSelection" !== this.group.type ? fabric.StaticCanvas.prototype.moveTo.call(this.group, this, t) : this.canvas && this.canvas.moveTo(this, t), this } }); !function () { function t(t, e) { if (e) { if (e.toLive) return t + ": url(#SVGID_" + e.id + "); "; var i = new fabric.Color(e), r = t + ": " + i.toRgb() + "; ", n = i.getAlpha(); return 1 !== n && (r += t + "-opacity: " + n.toString() + "; "), r } return t + ": none; " } var e = fabric.util.toFixed; fabric.util.object.extend(fabric.Object.prototype, { getSvgStyles: function (e) { var i = this.fillRule ? this.fillRule : "nonzero", r = this.strokeWidth ? this.strokeWidth : "0", n = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", s = this.strokeDashOffset ? this.strokeDashOffset : "0", o = this.strokeLineCap ? this.strokeLineCap : "butt", a = this.strokeLineJoin ? this.strokeLineJoin : "miter", c = this.strokeMiterLimit ? this.strokeMiterLimit : "4", h = "undefined" != typeof this.opacity ? this.opacity : "1", l = this.visible ? "" : " visibility: hidden;", u = e ? "" : this.getSvgFilter(), f = t("fill", this.fill), d = t("stroke", this.stroke); return [d, "stroke-width: ", r, "; ", "stroke-dasharray: ", n, "; ", "stroke-linecap: ", o, "; ", "stroke-dashoffset: ", s, "; ", "stroke-linejoin: ", a, "; ", "stroke-miterlimit: ", c, "; ", f, "fill-rule: ", i, "; ", "opacity: ", h, ";", u, l].join("") }, getSvgSpanStyles: function (e, i) { var r = "; ", n = e.fontFamily ? "font-family: " + (-1 === e.fontFamily.indexOf("'") && -1 === e.fontFamily.indexOf('"') ? "'" + e.fontFamily + "'" : e.fontFamily) + r : "", s = e.strokeWidth ? "stroke-width: " + e.strokeWidth + r : "", n = n, o = e.fontSize ? "font-size: " + e.fontSize + "px" + r : "", a = e.fontStyle ? "font-style: " + e.fontStyle + r : "", c = e.fontWeight ? "font-weight: " + e.fontWeight + r : "", h = e.fill ? t("fill", e.fill) : "", l = e.stroke ? t("stroke", e.stroke) : "", u = this.getSvgTextDecoration(e), f = e.deltaY ? "baseline-shift: " + -e.deltaY + "; " : ""; return u && (u = "text-decoration: " + u + r), [l, s, n, o, a, c, u, h, f, i ? "white-space: pre; " : ""].join("") }, getSvgTextDecoration: function (t) { return ["overline", "underline", "line-through"].filter(function (e) { return t[e.replace("-", "")] }).join(" ") }, getSvgFilter: function () { return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "" }, getSvgCommons: function () { return [this.id ? 'id="' + this.id + '" ' : "", this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""].join("") }, getSvgTransform: function (t, e) { var i = t ? this.calcTransformMatrix() : this.calcOwnMatrix(), r = 'transform="' + fabric.util.matrixToSVG(i); return r + (e || "") + '" ' }, _setSVGBg: function (t) { if (this.backgroundColor) { var i = fabric.Object.NUM_FRACTION_DIGITS; t.push("		<rect ", this._getFillAttributes(this.backgroundColor), ' x="', e(-this.width / 2, i), '" y="', e(-this.height / 2, i), '" width="', e(this.width, i), '" height="', e(this.height, i), '"></rect>\n') } }, toSVG: function (t) { return this._createBaseSVGMarkup(this._toSVG(t), { reviver: t }) }, toClipPathSVG: function (t) { return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(t), { reviver: t }) }, _createBaseClipPathSVGMarkup: function (t, e) { e = e || {}; var i = e.reviver, r = e.additionalTransform || "", n = [this.getSvgTransform(!0, r), this.getSvgCommons()].join(""), s = t.indexOf("COMMON_PARTS"); return t[s] = n, i ? i(t.join("")) : t.join("") }, _createBaseSVGMarkup: function (t, e) { e = e || {}; var i, r, n = e.noStyle, s = e.reviver, o = n ? "" : 'style="' + this.getSvgStyles() + '" ', a = e.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", c = this.clipPath, h = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", l = c && c.absolutePositioned, u = this.stroke, f = this.fill, d = this.shadow, g = [], p = t.indexOf("COMMON_PARTS"), v = e.additionalTransform; return c && (c.clipPathId = "CLIPPATH_" + fabric.Object.__uid++, r = '<clipPath id="' + c.clipPathId + '" >\n' + c.toClipPathSVG(s) + "</clipPath>\n"), l && g.push("<g ", a, this.getSvgCommons(), " >\n"), g.push("<g ", this.getSvgTransform(!1), l ? "" : a + this.getSvgCommons(), " >\n"), i = [o, h, n ? "" : this.addPaintOrder(), " ", v ? 'transform="' + v + '" ' : ""].join(""), t[p] = i, f && f.toLive && g.push(f.toSVG(this)), u && u.toLive && g.push(u.toSVG(this)), d && g.push(d.toSVG(this)), c && g.push(r), g.push(t.join("")), g.push("</g>\n"), l && g.push("</g>\n"), s ? s(g.join("")) : g.join("") }, addPaintOrder: function () { return "fill" !== this.paintFirst ? ' paint-order="' + this.paintFirst + '" ' : "" } }) }(); !function () { function t(t, e, r) { var n = {}, s = !0; r.forEach(function (e) { n[e] = t[e] }), i(t[e], n, s) } function e(t, i, r) { if (t === i) return !0; if (Array.isArray(t)) { if (!Array.isArray(i) || t.length !== i.length) return !1; for (var n = 0, s = t.length; s > n; n++)if (!e(t[n], i[n])) return !1; return !0 } if (t && "object" == typeof t) { var o, a = Object.keys(t); if (!i || "object" != typeof i || !r && a.length !== Object.keys(i).length) return !1; for (var n = 0, s = a.length; s > n; n++)if (o = a[n], "canvas" !== o && "group" !== o && !e(t[o], i[o])) return !1; return !0 } } var i = fabric.util.object.extend, r = "stateProperties"; fabric.util.object.extend(fabric.Object.prototype, { hasStateChanged: function (t) { t = t || r; var i = "_" + t; return Object.keys(this[i]).length < this[t].length ? !0 : !e(this[i], this, !0) }, saveState: function (e) { var i = e && e.propertySet || r, n = "_" + i; return this[n] ? (t(this, n, this[i]), e && e.stateProperties && t(this, n, e.stateProperties), this) : this.setupState(e) }, setupState: function (t) { t = t || {}; var e = t.propertySet || r; return t.propertySet = e, this["_" + e] = {}, this.saveState(t), this } }) }(); !function () { var t = fabric.util.degreesToRadians; fabric.util.object.extend(fabric.Object.prototype, { _findTargetCorner: function (t, e) { if (!this.hasControls || this.group || !this.canvas || this.canvas._activeObject !== this) return !1; var i, r, n, s = t.x, o = t.y, a = Object.keys(this.oCoords), c = a.length - 1; for (this.__corner = 0; c >= 0; c--)if (n = a[c], this.isControlVisible(n) && (r = this._getImageLines(e ? this.oCoords[n].touchCorner : this.oCoords[n].corner), i = this._findCrossPoints({ x: s, y: o }, r), 0 !== i && i % 2 === 1)) return this.__corner = n, n; return !1 }, forEachControl: function (t) { for (var e in this.controls) t(this.controls[e], e, this) }, _setCornerCoords: function () { var t = this.oCoords; for (var e in t) { var i = this.controls[e]; t[e].corner = i.calcCornerCoords(this.angle, this.cornerSize, t[e].x, t[e].y, !1), t[e].touchCorner = i.calcCornerCoords(this.angle, this.touchCornerSize, t[e].x, t[e].y, !0) } }, drawSelectionBackground: function (e) { if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) return this; e.save(); var i = this.getCenterPoint(), r = this._calculateCurrentDimensions(), n = this.canvas.viewportTransform; return e.translate(i.x, i.y), e.scale(1 / n[0], 1 / n[3]), e.rotate(t(this.angle)), e.fillStyle = this.selectionBackgroundColor, e.fillRect(-r.x / 2, -r.y / 2, r.x, r.y), e.restore(), this }, drawBorders: function (t, e) { e = e || {}; var i = this._calculateCurrentDimensions(), r = this.borderScaleFactor, n = i.x + r, s = i.y + r, o = "undefined" != typeof e.hasControls ? e.hasControls : this.hasControls, a = !1; return t.save(), t.strokeStyle = e.borderColor || this.borderColor, this._setLineDash(t, e.borderDashArray || this.borderDashArray), t.strokeRect(-n / 2, -s / 2, n, s), o && (t.beginPath(), this.forEachControl(function (e, i, r) { e.withConnection && e.getVisibility(r, i) && (a = !0, t.moveTo(e.x * n, e.y * s), t.lineTo(e.x * n + e.offsetX, e.y * s + e.offsetY)) }), a && t.stroke()), t.restore(), this }, drawBordersInGroup: function (t, e, i) { i = i || {}; var r = fabric.util.sizeAfterTransform(this.width, this.height, e), n = this.strokeWidth, s = this.strokeUniform, o = this.borderScaleFactor, a = r.x + n * (s ? this.canvas.getZoom() : e.scaleX) + o, c = r.y + n * (s ? this.canvas.getZoom() : e.scaleY) + o; return t.save(), this._setLineDash(t, i.borderDashArray || this.borderDashArray), t.strokeStyle = i.borderColor || this.borderColor, t.strokeRect(-a / 2, -c / 2, a, c), t.restore(), this }, drawControls: function (t, e) { e = e || {}, t.save(); var i, r, n = this.canvas.getRetinaScaling(); return t.setTransform(n, 0, 0, n, 0, 0), t.strokeStyle = t.fillStyle = e.cornerColor || this.cornerColor, this.transparentCorners || (t.strokeStyle = e.cornerStrokeColor || this.cornerStrokeColor), this._setLineDash(t, e.cornerDashArray || this.cornerDashArray), this.setCoords(), this.group && (i = this.group.calcTransformMatrix()), this.forEachControl(function (n, s, o) { r = o.oCoords[s], n.getVisibility(o, s) && (i && (r = fabric.util.transformPoint(r, i)), n.render(t, r.x, r.y, e, o)) }), t.restore(), this }, isControlVisible: function (t) { return this.controls[t] && this.controls[t].getVisibility(this, t) }, setControlVisible: function (t, e) { return this._controlsVisibility || (this._controlsVisibility = {}), this._controlsVisibility[t] = e, this }, setControlsVisibility: function (t) { t || (t = {}); for (var e in t) this.setControlVisible(e, t[e]); return this }, onDeselect: function () { }, onSelect: function () { } }) }(); fabric.util.object.extend(fabric.StaticCanvas.prototype, { FX_DURATION: 500, fxCenterObjectH: function (t, e) { e = e || {}; var i = function () { }, r = e.onComplete || i, n = e.onChange || i, s = this; return fabric.util.animate({ target: this, startValue: t.left, endValue: this.getCenterPoint().x, duration: this.FX_DURATION, onChange: function (e) { t.set("left", e), s.requestRenderAll(), n() }, onComplete: function () { t.setCoords(), r() } }) }, fxCenterObjectV: function (t, e) { e = e || {}; var i = function () { }, r = e.onComplete || i, n = e.onChange || i, s = this; return fabric.util.animate({ target: this, startValue: t.top, endValue: this.getCenterPoint().y, duration: this.FX_DURATION, onChange: function (e) { t.set("top", e), s.requestRenderAll(), n() }, onComplete: function () { t.setCoords(), r() } }) }, fxRemove: function (t, e) { e = e || {}; var i = function () { }, r = e.onComplete || i, n = e.onChange || i, s = this; return fabric.util.animate({ target: this, startValue: t.opacity, endValue: 0, duration: this.FX_DURATION, onChange: function (e) { t.set("opacity", e), s.requestRenderAll(), n() }, onComplete: function () { s.remove(t), r() } }) } }), fabric.util.object.extend(fabric.Object.prototype, { animate: function () { if (arguments[0] && "object" == typeof arguments[0]) { var t, e, i = [], r = []; for (t in arguments[0]) i.push(t); for (var n = 0, s = i.length; s > n; n++)t = i[n], e = n !== s - 1, r.push(this._animate(t, arguments[0][t], arguments[1], e)); return r } return this._animate.apply(this, arguments) }, _animate: function (t, e, i, r) { var n, s = this; e = e.toString(), i = i ? fabric.util.object.clone(i) : {}, ~t.indexOf(".") && (n = t.split(".")); var o = s.colorProperties.indexOf(t) > -1 || n && s.colorProperties.indexOf(n[1]) > -1, a = n ? this.get(n[0])[n[1]] : this.get(t); "from" in i || (i.from = a), o || (e = ~e.indexOf("=") ? a + parseFloat(e.replace("=", "")) : parseFloat(e)); var c = { target: this, startValue: i.from, endValue: e, byValue: i.by, easing: i.easing, duration: i.duration, abort: i.abort && function (t, e, r) { return i.abort.call(s, t, e, r) }, onChange: function (e, o, a) { n ? s[n[0]][n[1]] = e : s.set(t, e), r || i.onChange && i.onChange(e, o, a) }, onComplete: function (t, e, n) { r || (s.setCoords(), i.onComplete && i.onComplete(t, e, n)) } }; return o ? fabric.util.animateColor(c.startValue, c.endValue, c.duration, c) : fabric.util.animate(c) } }); !function (t) { "use strict"; function e(t, e) { var i = t.origin, r = t.axis1, n = t.axis2, s = t.dimension, o = e.nearest, a = e.center, c = e.farthest; return function () { switch (this.get(i)) { case o: return Math.min(this.get(r), this.get(n)); case a: return Math.min(this.get(r), this.get(n)) + .5 * this.get(s); case c: return Math.max(this.get(r), this.get(n)) } } } var i = t.fabric || (t.fabric = {}), r = i.util.object.extend, n = i.util.object.clone, s = { x1: 1, x2: 1, y1: 1, y2: 1 }; return i.Line ? void i.warn("fabric.Line is already defined") : (i.Line = i.util.createClass(i.Object, { type: "line", x1: 0, y1: 0, x2: 0, y2: 0, cacheProperties: i.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"), initialize: function (t, e) { t || (t = [0, 0, 0, 0]), this.callSuper("initialize", e), this.set("x1", t[0]), this.set("y1", t[1]), this.set("x2", t[2]), this.set("y2", t[3]), this._setWidthHeight(e) }, _setWidthHeight: function (t) { t || (t = {}), this.width = Math.abs(this.x2 - this.x1), this.height = Math.abs(this.y2 - this.y1), this.left = "left" in t ? t.left : this._getLeftToOriginX(), this.top = "top" in t ? t.top : this._getTopToOriginY() }, _set: function (t, e) { return this.callSuper("_set", t, e), "undefined" != typeof s[t] && this._setWidthHeight(), this }, _getLeftToOriginX: e({ origin: "originX", axis1: "x1", axis2: "x2", dimension: "width" }, { nearest: "left", center: "center", farthest: "right" }), _getTopToOriginY: e({ origin: "originY", axis1: "y1", axis2: "y2", dimension: "height" }, { nearest: "top", center: "center", farthest: "bottom" }), _render: function (t) { t.beginPath(); var e = this.calcLinePoints(); t.moveTo(e.x1, e.y1), t.lineTo(e.x2, e.y2), t.lineWidth = this.strokeWidth; var i = t.strokeStyle; t.strokeStyle = this.stroke || t.fillStyle, this.stroke && this._renderStroke(t), t.strokeStyle = i }, _findCenterFromElement: function () { return { x: (this.x1 + this.x2) / 2, y: (this.y1 + this.y2) / 2 } }, toObject: function (t) { return r(this.callSuper("toObject", t), this.calcLinePoints()) }, _getNonTransformedDimensions: function () { var t = this.callSuper("_getNonTransformedDimensions"); return "butt" === this.strokeLineCap && (0 === this.width && (t.y -= this.strokeWidth), 0 === this.height && (t.x -= this.strokeWidth)), t }, calcLinePoints: function () { var t = this.x1 <= this.x2 ? -1 : 1, e = this.y1 <= this.y2 ? -1 : 1, i = t * this.width * .5, r = e * this.height * .5, n = t * this.width * -.5, s = e * this.height * -.5; return { x1: i, x2: n, y1: r, y2: s } }, _toSVG: function () { var t = this.calcLinePoints(); return ["<line ", "COMMON_PARTS", 'x1="', t.x1, '" y1="', t.y1, '" x2="', t.x2, '" y2="', t.y2, '" />\n'] } }), i.Line.ATTRIBUTE_NAMES = i.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" ")), i.Line.fromElement = function (t, e, n) { n = n || {}; var s = i.parseAttributes(t, i.Line.ATTRIBUTE_NAMES), o = [s.x1 || 0, s.y1 || 0, s.x2 || 0, s.y2 || 0]; e(new i.Line(o, r(s, n))) }, void (i.Line.fromObject = function (t, e) { function r(t) { delete t.points, e && e(t) } var s = n(t, !0); s.points = [t.x1, t.y1, t.x2, t.y2], i.Object._fromObject("Line", s, r, "points") })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; function e(t) { return "radius" in t && t.radius >= 0 } var i = t.fabric || (t.fabric = {}), r = i.util.degreesToRadians; return i.Circle ? void i.warn("fabric.Circle is already defined.") : (i.Circle = i.util.createClass(i.Object, { type: "circle", radius: 0, startAngle: 0, endAngle: 360, cacheProperties: i.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"), _set: function (t, e) { return this.callSuper("_set", t, e), "radius" === t && this.setRadius(e), this }, toObject: function (t) { return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(t)) }, _toSVG: function () { var t, e = 0, n = 0, s = (this.endAngle - this.startAngle) % 360; if (0 === s) t = ["<circle ", "COMMON_PARTS", 'cx="' + e + '" cy="' + n + '" ', 'r="', this.radius, '" />\n']; else { var o = r(this.startAngle), a = r(this.endAngle), c = this.radius, h = i.util.cos(o) * c, l = i.util.sin(o) * c, u = i.util.cos(a) * c, f = i.util.sin(a) * c, d = s > 180 ? "1" : "0"; t = ['<path d="M ' + h + " " + l, " A " + c + " " + c, " 0 ", +d + " 1", " " + u + " " + f, '" ', "COMMON_PARTS", " />\n"] } return t }, _render: function (t) { t.beginPath(), t.arc(0, 0, this.radius, r(this.startAngle), r(this.endAngle), !1), this._renderPaintInOrder(t) }, getRadiusX: function () { return this.get("radius") * this.get("scaleX") }, getRadiusY: function () { return this.get("radius") * this.get("scaleY") }, setRadius: function (t) { return this.radius = t, this.set("width", 2 * t).set("height", 2 * t) } }), i.Circle.ATTRIBUTE_NAMES = i.SHARED_ATTRIBUTES.concat("cx cy r".split(" ")), i.Circle.fromElement = function (t, r) { var n = i.parseAttributes(t, i.Circle.ATTRIBUTE_NAMES); if (!e(n)) throw new Error("value of `r` attribute is required and can not be negative"); n.left = (n.left || 0) - n.radius, n.top = (n.top || 0) - n.radius, r(new i.Circle(n)) }, void (i.Circle.fromObject = function (t, e) { i.Object._fromObject("Circle", t, e) })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}); return e.Triangle ? void e.warn("fabric.Triangle is already defined") : (e.Triangle = e.util.createClass(e.Object, { type: "triangle", width: 100, height: 100, _render: function (t) { var e = this.width / 2, i = this.height / 2; t.beginPath(), t.moveTo(-e, i), t.lineTo(0, -i), t.lineTo(e, i), t.closePath(), this._renderPaintInOrder(t) }, _toSVG: function () { var t = this.width / 2, e = this.height / 2, i = [-t + " " + e, "0 " + -e, t + " " + e].join(","); return ["<polygon ", "COMMON_PARTS", 'points="', i, '" />'] } }), void (e.Triangle.fromObject = function (t, i) { return e.Object._fromObject("Triangle", t, i) })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = 2 * Math.PI; return e.Ellipse ? void e.warn("fabric.Ellipse is already defined.") : (e.Ellipse = e.util.createClass(e.Object, { type: "ellipse", rx: 0, ry: 0, cacheProperties: e.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (t) { this.callSuper("initialize", t), this.set("rx", t && t.rx || 0), this.set("ry", t && t.ry || 0) }, _set: function (t, e) { switch (this.callSuper("_set", t, e), t) { case "rx": this.rx = e, this.set("width", 2 * e); break; case "ry": this.ry = e, this.set("height", 2 * e) }return this }, getRx: function () { return this.get("rx") * this.get("scaleX") }, getRy: function () { return this.get("ry") * this.get("scaleY") }, toObject: function (t) { return this.callSuper("toObject", ["rx", "ry"].concat(t)) }, _toSVG: function () { return ["<ellipse ", "COMMON_PARTS", 'cx="0" cy="0" ', 'rx="', this.rx, '" ry="', this.ry, '" />\n'] }, _render: function (t) { t.beginPath(), t.save(), t.transform(1, 0, 0, this.ry / this.rx, 0, 0), t.arc(0, 0, this.rx, 0, i, !1), t.restore(), this._renderPaintInOrder(t) } }), e.Ellipse.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" ")), e.Ellipse.fromElement = function (t, i) { var r = e.parseAttributes(t, e.Ellipse.ATTRIBUTE_NAMES); r.left = (r.left || 0) - r.rx, r.top = (r.top || 0) - r.ry, i(new e.Ellipse(r)) }, void (e.Ellipse.fromObject = function (t, i) { e.Object._fromObject("Ellipse", t, i) })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend; return e.Rect ? void e.warn("fabric.Rect is already defined") : (e.Rect = e.util.createClass(e.Object, { stateProperties: e.Object.prototype.stateProperties.concat("rx", "ry"), type: "rect", rx: 0, ry: 0, cacheProperties: e.Object.prototype.cacheProperties.concat("rx", "ry"), initialize: function (t) { this.callSuper("initialize", t), this._initRxRy() }, _initRxRy: function () { this.rx && !this.ry ? this.ry = this.rx : this.ry && !this.rx && (this.rx = this.ry) }, _render: function (t) { var e = this.rx ? Math.min(this.rx, this.width / 2) : 0, i = this.ry ? Math.min(this.ry, this.height / 2) : 0, r = this.width, n = this.height, s = -this.width / 2, o = -this.height / 2, a = 0 !== e || 0 !== i, c = .4477152502; t.beginPath(), t.moveTo(s + e, o), t.lineTo(s + r - e, o), a && t.bezierCurveTo(s + r - c * e, o, s + r, o + c * i, s + r, o + i), t.lineTo(s + r, o + n - i), a && t.bezierCurveTo(s + r, o + n - c * i, s + r - c * e, o + n, s + r - e, o + n), t.lineTo(s + e, o + n), a && t.bezierCurveTo(s + c * e, o + n, s, o + n - c * i, s, o + n - i), t.lineTo(s, o + i), a && t.bezierCurveTo(s, o + c * i, s + c * e, o, s + e, o), t.closePath(), this._renderPaintInOrder(t) }, toObject: function (t) { return this.callSuper("toObject", ["rx", "ry"].concat(t)) }, _toSVG: function () { var t = -this.width / 2, e = -this.height / 2; return ["<rect ", "COMMON_PARTS", 'x="', t, '" y="', e, '" rx="', this.rx, '" ry="', this.ry, '" width="', this.width, '" height="', this.height, '" />\n'] } }), e.Rect.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" ")), e.Rect.fromElement = function (t, r, n) { if (!t) return r(null); n = n || {}; var s = e.parseAttributes(t, e.Rect.ATTRIBUTE_NAMES); s.left = s.left || 0, s.top = s.top || 0, s.height = s.height || 0, s.width = s.width || 0; var o = new e.Rect(i(n ? e.util.object.clone(n) : {}, s)); o.visible = o.visible && o.width > 0 && o.height > 0, r(o) }, void (e.Rect.fromObject = function (t, i) { return e.Object._fromObject("Rect", t, i) })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.util.array.min, n = e.util.array.max, s = e.util.toFixed, o = e.util.projectStrokeOnPoints; return e.Polyline ? void e.warn("fabric.Polyline is already defined") : (e.Polyline = e.util.createClass(e.Object, { type: "polyline", points: null, exactBoundingBox: !1, cacheProperties: e.Object.prototype.cacheProperties.concat("points"), initialize: function (t, e) { e = e || {}, this.points = t || [], this.callSuper("initialize", e), this._setPositionDimensions(e) }, _projectStrokeOnPoints: function () { return o(this.points, this, !0) }, _setPositionDimensions: function (t) { var e, i = this._calcDimensions(t), r = this.exactBoundingBox ? this.strokeWidth : 0; this.width = i.width - r, this.height = i.height - r, t.fromSVG || (e = this.translateToGivenOrigin({ x: i.left - this.strokeWidth / 2 + r / 2, y: i.top - this.strokeWidth / 2 + r / 2 }, "left", "top", this.originX, this.originY)), "undefined" == typeof t.left && (this.left = t.fromSVG ? i.left : e.x), "undefined" == typeof t.top && (this.top = t.fromSVG ? i.top : e.y), this.pathOffset = { x: i.left + this.width / 2 + r / 2, y: i.top + this.height / 2 + r / 2 } }, _calcDimensions: function () { var t = this.exactBoundingBox ? this._projectStrokeOnPoints() : this.points, e = r(t, "x") || 0, i = r(t, "y") || 0, s = n(t, "x") || 0, o = n(t, "y") || 0, a = s - e, c = o - i; return { left: e, top: i, width: a, height: c } }, toObject: function (t) { return i(this.callSuper("toObject", t), { points: this.points.concat() }) }, _toSVG: function () { for (var t = [], i = this.pathOffset.x, r = this.pathOffset.y, n = e.Object.NUM_FRACTION_DIGITS, o = 0, a = this.points.length; a > o; o++)t.push(s(this.points[o].x - i, n), ",", s(this.points[o].y - r, n), " "); return ["<" + this.type + " ", "COMMON_PARTS", 'points="', t.join(""), '" />\n'] }, commonRender: function (t) { var e, i = this.points.length, r = this.pathOffset.x, n = this.pathOffset.y; if (!i || isNaN(this.points[i - 1].y)) return !1; t.beginPath(), t.moveTo(this.points[0].x - r, this.points[0].y - n); for (var s = 0; i > s; s++)e = this.points[s], t.lineTo(e.x - r, e.y - n); return !0 }, _render: function (t) { this.commonRender(t) && this._renderPaintInOrder(t) }, complexity: function () { return this.get("points").length } }), e.Polyline.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polyline.fromElementGenerator = function (t) { return function (r, n, s) { if (!r) return n(null); s || (s = {}); var o = e.parsePointsAttribute(r.getAttribute("points")), a = e.parseAttributes(r, e[t].ATTRIBUTE_NAMES); a.fromSVG = !0, n(new e[t](o, i(a, s))) } }, e.Polyline.fromElement = e.Polyline.fromElementGenerator("Polyline"), void (e.Polyline.fromObject = function (t, i) { return e.Object._fromObject("Polyline", t, i, "points") })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.projectStrokeOnPoints; return e.Polygon ? void e.warn("fabric.Polygon is already defined") : (e.Polygon = e.util.createClass(e.Polyline, { type: "polygon", _projectStrokeOnPoints: function () { return i(this.points, this) }, _render: function (t) { this.commonRender(t) && (t.closePath(), this._renderPaintInOrder(t)) } }), e.Polygon.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(), e.Polygon.fromElement = e.Polyline.fromElementGenerator("Polygon"), void (e.Polygon.fromObject = function (t, i) { e.Object._fromObject("Polygon", t, i, "points") })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.array.min, r = e.util.array.max, n = e.util.object.extend, s = e.util.object.clone, a = e.util.toFixed; return e.Path ? void e.warn("fabric.Path is already defined") : (e.Path = e.util.createClass(e.Object, { type: "path", path: null, cacheProperties: e.Object.prototype.cacheProperties.concat("path", "fillRule"), stateProperties: e.Object.prototype.stateProperties.concat("path"), initialize: function (t, e) { e = s(e || {}), delete e.path, this.callSuper("initialize", e), this._setPath(t || [], e) }, _setPath: function (t, i) { this.path = e.util.makePathSimpler(Array.isArray(t) ? t : e.util.parsePath(t)), e.Polyline.prototype._setPositionDimensions.call(this, i || {}) }, _renderPathCommands: function (t) { var e, i = 0, r = 0, n = 0, s = 0, a = 0, o = 0, c = -this.pathOffset.x, h = -this.pathOffset.y; t.beginPath(); for (var l = 0, u = this.path.length; u > l; ++l)switch (e = this.path[l], e[0]) { case "L": n = e[1], s = e[2], t.lineTo(n + c, s + h); break; case "M": n = e[1], s = e[2], i = n, r = s, t.moveTo(n + c, s + h); break; case "C": n = e[5], s = e[6], a = e[3], o = e[4], t.bezierCurveTo(e[1] + c, e[2] + h, a + c, o + h, n + c, s + h); break; case "Q": t.quadraticCurveTo(e[1] + c, e[2] + h, e[3] + c, e[4] + h), n = e[3], s = e[4], a = e[1], o = e[2]; break; case "z": case "Z": n = i, s = r, t.closePath() } }, _render: function (t) { this._renderPathCommands(t), this._renderPaintInOrder(t) }, toString: function () { return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>" }, toObject: function (t) { return n(this.callSuper("toObject", t), { path: this.path.map(function (t) { return t.slice() }) }) }, toDatalessObject: function (t) { var e = this.toObject(["sourcePath"].concat(t)); return e.sourcePath && delete e.path, e }, _toSVG: function () { var t = e.util.joinPath(this.path); return ["<path ", "COMMON_PARTS", 'd="', t, '" stroke-linecap="round" ', "/>\n"] }, _getOffsetTransform: function () { var t = e.Object.NUM_FRACTION_DIGITS; return " translate(" + a(-this.pathOffset.x, t) + ", " + a(-this.pathOffset.y, t) + ")" }, toClipPathSVG: function (t) { var e = this._getOffsetTransform(); return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(), { reviver: t, additionalTransform: e }) }, toSVG: function (t) { var e = this._getOffsetTransform(); return this._createBaseSVGMarkup(this._toSVG(), { reviver: t, additionalTransform: e }) }, complexity: function () { return this.path.length }, _calcDimensions: function () { for (var t, n, s = [], a = [], o = 0, c = 0, h = 0, l = 0, u = 0, f = this.path.length; f > u; ++u) { switch (t = this.path[u], t[0]) { case "L": h = t[1], l = t[2], n = []; break; case "M": h = t[1], l = t[2], o = h, c = l, n = []; break; case "C": n = e.util.getBoundsOfCurve(h, l, t[1], t[2], t[3], t[4], t[5], t[6]), h = t[5], l = t[6]; break; case "Q": n = e.util.getBoundsOfCurve(h, l, t[1], t[2], t[1], t[2], t[3], t[4]), h = t[3], l = t[4]; break; case "z": case "Z": h = o, l = c }n.forEach(function (t) { s.push(t.x), a.push(t.y) }), s.push(h), a.push(l) } var d = i(s) || 0, g = i(a) || 0, p = r(s) || 0, v = r(a) || 0, m = p - d, b = v - g; return { left: d, top: g, width: m, height: b } } }), e.Path.fromObject = function (t, i) { if ("string" == typeof t.sourcePath) { var r = t.sourcePath; e.loadSVGFromURL(r, function (e) { var r = e[0]; r.setOptions(t), i && i(r) }) } else e.Object._fromObject("Path", t, i, "path") }, e.Path.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat(["d"]), void (e.Path.fromElement = function (t, i, r) { var s = e.parseAttributes(t, e.Path.ATTRIBUTE_NAMES); s.fromSVG = !0, i(new e.Path(s.d, n(s, r))) })) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.array.min, r = e.util.array.max; e.Group || (e.Group = e.util.createClass(e.Object, e.Collection, { type: "group", strokeWidth: 0, subTargetCheck: !1, cacheProperties: [], useSetOnGroup: !1, initialize: function (t, e, i) { e = e || {}, this._objects = [], i && this.callSuper("initialize", e), this._objects = t || []; for (var r = this._objects.length; r--;)this._objects[r].group = this; if (i) this._updateObjectsACoords(); else { var n = e && e.centerPoint; void 0 !== e.originX && (this.originX = e.originX), void 0 !== e.originY && (this.originY = e.originY), n || this._calcBounds(), this._updateObjectsCoords(n), delete e.centerPoint, this.callSuper("initialize", e) } this.setCoords() }, _updateObjectsACoords: function () { for (var t = !0, e = this._objects.length; e--;)this._objects[e].setCoords(t) }, _updateObjectsCoords: function (t) { for (var t = t || this.getCenterPoint(), e = this._objects.length; e--;)this._updateObjectCoords(this._objects[e], t) }, _updateObjectCoords: function (t, e) { var i = t.left, r = t.top, n = !0; t.set({ left: i - e.x, top: r - e.y }), t.group = this, t.setCoords(n) }, toString: function () { return "#<fabric.Group: (" + this.complexity() + ")>" }, addWithUpdate: function (t) { var i = !!this.group; return this._restoreObjectsState(), e.util.resetObjectTransform(this), t && (i && e.util.removeTransformFromObject(t, this.group.calcTransformMatrix()), this._objects.push(t), t.group = this, t._set("canvas", this.canvas)), this._calcBounds(), this._updateObjectsCoords(), this.dirty = !0, i ? this.group.addWithUpdate() : this.setCoords(), this }, removeWithUpdate: function (t) { return this._restoreObjectsState(), e.util.resetObjectTransform(this), this.remove(t), this._calcBounds(), this._updateObjectsCoords(), this.setCoords(), this.dirty = !0, this }, _onObjectAdded: function (t) { this.dirty = !0, t.group = this, t._set("canvas", this.canvas) }, _onObjectRemoved: function (t) { this.dirty = !0, delete t.group }, _set: function (t, i) { var r = this._objects.length; if (this.useSetOnGroup) for (; r--;)this._objects[r].setOnGroup(t, i); if ("canvas" === t) for (; r--;)this._objects[r]._set(t, i); e.Object.prototype._set.call(this, t, i) }, toObject: function (t) { var i = this.includeDefaultValues, r = this._objects.filter(function (t) { return !t.excludeFromExport }).map(function (e) { var r = e.includeDefaultValues; e.includeDefaultValues = i; var n = e.toObject(t); return e.includeDefaultValues = r, n }), n = e.Object.prototype.toObject.call(this, t); return n.objects = r, n }, toDatalessObject: function (t) { var i, r = this.sourcePath; if (r) i = r; else { var n = this.includeDefaultValues; i = this._objects.map(function (e) { var i = e.includeDefaultValues; e.includeDefaultValues = n; var r = e.toDatalessObject(t); return e.includeDefaultValues = i, r }) } var s = e.Object.prototype.toDatalessObject.call(this, t); return s.objects = i, s }, render: function (t) { this._transformDone = !0, this.callSuper("render", t), this._transformDone = !1 }, shouldCache: function () { var t = e.Object.prototype.shouldCache.call(this); if (t) for (var i = 0, r = this._objects.length; r > i; i++)if (this._objects[i].willDrawShadow()) return this.ownCaching = !1, !1; return t }, willDrawShadow: function () { if (e.Object.prototype.willDrawShadow.call(this)) return !0; for (var t = 0, i = this._objects.length; i > t; t++)if (this._objects[t].willDrawShadow()) return !0; return !1 }, isOnACache: function () { return this.ownCaching || this.group && this.group.isOnACache() }, drawObject: function (t) { for (var e = 0, i = this._objects.length; i > e; e++)this._objects[e].render(t); this._drawClipPath(t, this.clipPath) }, isCacheDirty: function (t) { if (this.callSuper("isCacheDirty", t)) return !0; if (!this.statefullCache) return !1; for (var e = 0, i = this._objects.length; i > e; e++)if (this._objects[e].isCacheDirty(!0)) { if (this._cacheCanvas) { var r = this.cacheWidth / this.zoomX, n = this.cacheHeight / this.zoomY; this._cacheContext.clearRect(-r / 2, -n / 2, r, n) } return !0 } return !1 }, _restoreObjectsState: function () { var t = this.calcOwnMatrix(); return this._objects.forEach(function (i) { e.util.addTransformToObject(i, t), delete i.group, i.setCoords() }), this }, destroy: function () { return this._objects.forEach(function (t) { t.set("dirty", !0) }), this._restoreObjectsState() }, dispose: function () { this.callSuper("dispose"), this.forEachObject(function (t) { t.dispose && t.dispose() }), this._objects = [] }, toActiveSelection: function () { if (this.canvas) { var t = this._objects, i = this.canvas; this._objects = []; var r = this.toObject(); delete r.objects; var n = new e.ActiveSelection([]); return n.set(r), n.type = "activeSelection", i.remove(this), t.forEach(function (t) { t.group = n, t.dirty = !0, i.add(t) }), n.canvas = i, n._objects = t, i._activeObject = n, n.setCoords(), n } }, ungroupOnCanvas: function () { return this._restoreObjectsState() }, setObjectsCoords: function () { var t = !0; return this.forEachObject(function (e) { e.setCoords(t) }), this }, _calcBounds: function (t) { for (var e, i, r, n, s = [], o = [], a = ["tr", "br", "bl", "tl"], c = 0, h = this._objects.length, l = a.length; h > c; ++c) { for (e = this._objects[c], r = e.calcACoords(), n = 0; l > n; n++)i = a[n], s.push(r[i].x), o.push(r[i].y); e.aCoords = r } this._getBounds(s, o, t) }, _getBounds: function (t, n, s) { var o = new e.Point(i(t), i(n)), a = new e.Point(r(t), r(n)), c = o.y || 0, h = o.x || 0, l = a.x - o.x || 0, u = a.y - o.y || 0; this.width = l, this.height = u, s || this.setPositionByOrigin({ x: h, y: c }, "left", "top") }, _toSVG: function (t) { for (var e = ["<g ", "COMMON_PARTS", " >\n"], i = 0, r = this._objects.length; r > i; i++)e.push("		", this._objects[i].toSVG(t)); return e.push("</g>\n"), e }, getSvgStyles: function () { var t = "undefined" != typeof this.opacity && 1 !== this.opacity ? "opacity: " + this.opacity + ";" : "", e = this.visible ? "" : " visibility: hidden;"; return [t, this.getSvgFilter(), e].join("") }, toClipPathSVG: function (t) { for (var e = [], i = 0, r = this._objects.length; r > i; i++)e.push("	", this._objects[i].toClipPathSVG(t)); return this._createBaseClipPathSVGMarkup(e, { reviver: t }) } }), e.Group.fromObject = function (t, i) { var r = t.objects, n = e.util.object.clone(t, !0); return delete n.objects, "string" == typeof r ? void e.loadSVGFromURL(r, function (s) { var o = e.util.groupSVGElements(s, t, r); o.set(n), i && i(o) }) : void e.util.enlivenObjects(r, function (r) { var n = e.util.object.clone(t, !0); delete n.objects, e.util.enlivenObjectEnlivables(t, n, function () { i && i(new e.Group(r, n, !0)) }) }) }) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}); e.ActiveSelection || (e.ActiveSelection = e.util.createClass(e.Group, { type: "activeSelection", initialize: function (t, i) { i = i || {}, this._objects = t || []; for (var r = this._objects.length; r--;)this._objects[r].group = this; i.originX && (this.originX = i.originX), i.originY && (this.originY = i.originY), this._calcBounds(), this._updateObjectsCoords(), e.Object.prototype.initialize.call(this, i), this.setCoords() }, toGroup: function () { var t = this._objects.concat(); this._objects = []; var i = e.Object.prototype.toObject.call(this), r = new e.Group([]); if (delete i.type, r.set(i), t.forEach(function (t) { t.canvas.remove(t), t.group = r }), r._objects = t, !this.canvas) return r; var n = this.canvas; return n.add(r), n._activeObject = r, r.setCoords(), r }, onDeselect: function () { return this.destroy(), !1 }, toString: function () { return "#<fabric.ActiveSelection: (" + this.complexity() + ")>" }, shouldCache: function () { return !1 }, isOnACache: function () { return !1 }, _renderControls: function (t, e, i) { t.save(), t.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1, this.callSuper("_renderControls", t, e), i = i || {}, "undefined" == typeof i.hasControls && (i.hasControls = !1), i.forActiveSelection = !0; for (var r = 0, n = this._objects.length; n > r; r++)this._objects[r]._renderControls(t, i); t.restore() } }), e.ActiveSelection.fromObject = function (t, i) { e.util.enlivenObjects(t.objects, function (r) { delete t.objects, i && i(new e.ActiveSelection(r, t, !0)) }) }) }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = fabric.util.object.extend; return t.fabric || (t.fabric = {}), t.fabric.Image ? void fabric.warn("fabric.Image is already defined.") : (fabric.Image = fabric.util.createClass(fabric.Object, { type: "image", strokeWidth: 0, srcFromAttribute: !1, _lastScaleX: 1, _lastScaleY: 1, _filterScalingX: 1, _filterScalingY: 1, minimumScaleTrigger: .5, stateProperties: fabric.Object.prototype.stateProperties.concat("cropX", "cropY"), cacheProperties: fabric.Object.prototype.cacheProperties.concat("cropX", "cropY"), cacheKey: "", cropX: 0, cropY: 0, imageSmoothing: !0, initialize: function (t, e) { e || (e = {}), this.filters = [], this.cacheKey = "texture" + fabric.Object.__uid++, this.callSuper("initialize", e), this._initElement(t, e) }, getElement: function () { return this._element || {} }, setElement: function (t, e) { return this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._element = t, this._originalElement = t, this._initConfig(e), 0 !== this.filters.length && this.applyFilters(), this.resizeFilter && this.applyResizeFilters(), this }, removeTexture: function (t) { var e = fabric.filterBackend; e && e.evictCachesForKey && e.evictCachesForKey(t) }, dispose: function () { this.callSuper("dispose"), this.removeTexture(this.cacheKey), this.removeTexture(this.cacheKey + "_filtered"), this._cacheContext = void 0, ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach(function (t) { fabric.util.cleanUpJsdomNode(this[t]), this[t] = void 0 }.bind(this)) }, getCrossOrigin: function () { return this._originalElement && (this._originalElement.crossOrigin || null) }, getOriginalSize: function () { var t = this.getElement(); return { width: t.naturalWidth || t.width, height: t.naturalHeight || t.height } }, _stroke: function (t) { if (this.stroke && 0 !== this.strokeWidth) { var e = this.width / 2, i = this.height / 2; t.beginPath(), t.moveTo(-e, -i), t.lineTo(e, -i), t.lineTo(e, i), t.lineTo(-e, i), t.lineTo(-e, -i), t.closePath() } }, toObject: function (t) { var i = []; this.filters.forEach(function (t) { t && i.push(t.toObject()) }); var r = e(this.callSuper("toObject", ["cropX", "cropY"].concat(t)), { src: this.getSrc(), crossOrigin: this.getCrossOrigin(), filters: i }); return this.resizeFilter && (r.resizeFilter = this.resizeFilter.toObject()), r }, hasCrop: function () { return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height }, _toSVG: function () { var t, e = [], i = [], r = this._element, n = -this.width / 2, a = -this.height / 2, s = "", o = ""; if (!r) return []; if (this.hasCrop()) { var c = fabric.Object.__uid++; e.push('<clipPath id="imageCrop_' + c + '">\n', '	<rect x="' + n + '" y="' + a + '" width="' + this.width + '" height="' + this.height + '" />\n', "</clipPath>\n"), s = ' clip-path="url(#imageCrop_' + c + ')" ' } if (this.imageSmoothing || (o = '" image-rendering="optimizeSpeed'), i.push("	<image ", "COMMON_PARTS", 'xlink:href="', this.getSvgSrc(!0), '" x="', n - this.cropX, '" y="', a - this.cropY, '" width="', r.width || r.naturalWidth, '" height="', r.height || r.height, o, '"', s, "></image>\n"), this.stroke || this.strokeDashArray) { var l = this.fill; this.fill = null, t = ["	<rect ", 'x="', n, '" y="', a, '" width="', this.width, '" height="', this.height, '" style="', this.getSvgStyles(), '"/>\n'], this.fill = l } return e = "fill" !== this.paintFirst ? e.concat(t, i) : e.concat(i, t) }, getSrc: function (t) { var e = t ? this._element : this._originalElement; return e ? e.toDataURL ? e.toDataURL() : this.srcFromAttribute ? e.getAttribute("src") : e.src : this.src || "" }, setSrc: function (t, e, i) { return fabric.util.loadImage(t, function (t, r) { this.setElement(t, i), this._setWidthHeight(), e && e(this, r) }, this, i && i.crossOrigin), this }, toString: function () { return '#<fabric.Image: { src: "' + this.getSrc() + '" }>' }, applyResizeFilters: function () { var t = this.resizeFilter, e = this.minimumScaleTrigger, i = this.getTotalObjectScaling(), r = i.scaleX, n = i.scaleY, a = this._filteredEl || this._originalElement; if (this.group && this.set("dirty", !0), !t || r > e && n > e) return this._element = a, this._filterScalingX = 1, this._filterScalingY = 1, this._lastScaleX = r, void (this._lastScaleY = n); fabric.filterBackend || (fabric.filterBackend = fabric.initFilterBackend()); var s = fabric.util.createCanvasElement(), o = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, c = a.width, l = a.height; s.width = c, s.height = l, this._element = s, this._lastScaleX = t.scaleX = r, this._lastScaleY = t.scaleY = n, fabric.filterBackend.applyFilters([t], a, c, l, this._element, o), this._filterScalingX = s.width / this._originalElement.width, this._filterScalingY = s.height / this._originalElement.height }, applyFilters: function (t) { if (t = t || this.filters || [], t = t.filter(function (t) { return t && !t.isNeutralState() }), this.set("dirty", !0), this.removeTexture(this.cacheKey + "_filtered"), 0 === t.length) return this._element = this._originalElement, this._filteredEl = null, this._filterScalingX = 1, this._filterScalingY = 1, this; var e = this._originalElement, i = e.naturalWidth || e.width, r = e.naturalHeight || e.height; if (this._element === this._originalElement) { var n = fabric.util.createCanvasElement(); n.width = i, n.height = r, this._element = n, this._filteredEl = n } else this._element = this._filteredEl, this._filteredEl.getContext("2d").clearRect(0, 0, i, r), this._lastScaleX = 1, this._lastScaleY = 1; return fabric.filterBackend || (fabric.filterBackend = fabric.initFilterBackend()), fabric.filterBackend.applyFilters(t, this._originalElement, i, r, this._element, this.cacheKey), (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) && (this._filterScalingX = this._element.width / this._originalElement.width, this._filterScalingY = this._element.height / this._originalElement.height), this }, _render: function (t) { fabric.util.setImageSmoothing(t, this.imageSmoothing), this.isMoving !== !0 && this.resizeFilter && this._needsResize() && this.applyResizeFilters(), this._stroke(t), this._renderPaintInOrder(t) }, drawCacheOnCanvas: function (t) { fabric.util.setImageSmoothing(t, this.imageSmoothing), fabric.Object.prototype.drawCacheOnCanvas.call(this, t) }, shouldCache: function () { return this.needsItsOwnCache() }, _renderFill: function (t) { var e = this._element; if (e) { var i = this._filterScalingX, r = this._filterScalingY, n = this.width, a = this.height, s = Math.min, o = Math.max, c = o(this.cropX, 0), l = o(this.cropY, 0), h = e.naturalWidth || e.width, u = e.naturalHeight || e.height, f = c * i, d = l * r, g = s(n * i, h - f), p = s(a * r, u - d), m = -n / 2, v = -a / 2, b = s(n, h / i - c), y = s(a, u / r - l); e && t.drawImage(e, f, d, g, p, m, v, b, y) } }, _needsResize: function () { var t = this.getTotalObjectScaling(); return t.scaleX !== this._lastScaleX || t.scaleY !== this._lastScaleY }, _resetWidthHeight: function () { this.set(this.getOriginalSize()) }, _initElement: function (t, e) { this.setElement(fabric.util.getById(t), e), fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS) }, _initConfig: function (t) { t || (t = {}), this.setOptions(t), this._setWidthHeight(t) }, _initFilters: function (t, e) { t && t.length ? fabric.util.enlivenObjects(t, function (t) { e && e(t) }, "fabric.Image.filters") : e && e() }, _setWidthHeight: function (t) { t || (t = {}); var e = this.getElement(); this.width = t.width || e.naturalWidth || e.width || 0, this.height = t.height || e.naturalHeight || e.height || 0 }, parsePreserveAspectRatioAttribute: function () { var t, e = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), i = this._element.width, r = this._element.height, n = 1, a = 1, s = 0, o = 0, c = 0, l = 0, h = this.width, u = this.height, f = { width: h, height: u }; return !e || "none" === e.alignX && "none" === e.alignY ? (n = h / i, a = u / r) : ("meet" === e.meetOrSlice && (n = a = fabric.util.findScaleToFit(this._element, f), t = (h - i * n) / 2, "Min" === e.alignX && (s = -t), "Max" === e.alignX && (s = t), t = (u - r * a) / 2, "Min" === e.alignY && (o = -t), "Max" === e.alignY && (o = t)), "slice" === e.meetOrSlice && (n = a = fabric.util.findScaleToCover(this._element, f), t = i - h / n, "Mid" === e.alignX && (c = t / 2), "Max" === e.alignX && (c = t), t = r - u / a, "Mid" === e.alignY && (l = t / 2), "Max" === e.alignY && (l = t), i = h / n, r = u / a)), { width: i, height: r, scaleX: n, scaleY: a, offsetLeft: s, offsetTop: o, cropX: c, cropY: l } } }), fabric.Image.CSS_CANVAS = "canvas-img", fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc, fabric.Image.fromObject = function (t, e) { var i = fabric.util.object.clone(t); fabric.util.loadImage(i.src, function (t, r) { return r ? void (e && e(null, !0)) : void fabric.Image.prototype._initFilters.call(i, i.filters, function (r) { i.filters = r || [], fabric.Image.prototype._initFilters.call(i, [i.resizeFilter], function (r) { i.resizeFilter = r[0], fabric.util.enlivenObjectEnlivables(i, i, function () { var r = new fabric.Image(t, i); e(r, !1) }) }) }) }, null, i.crossOrigin) }, fabric.Image.fromURL = function (t, e, i) { fabric.util.loadImage(t, function (t, r) { e && e(new fabric.Image(t, i), r) }, null, i && i.crossOrigin) }, fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat("x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")), void (fabric.Image.fromElement = function (t, i, r) { var n = fabric.parseAttributes(t, fabric.Image.ATTRIBUTE_NAMES); fabric.Image.fromURL(n["xlink:href"], i, e(r ? fabric.util.object.clone(r) : {}, n)) })) }("undefined" != typeof exports ? exports : this); fabric.util.object.extend(fabric.Object.prototype, { _getAngleValueForStraighten: function () { var t = this.angle % 360; return t > 0 ? 90 * Math.round((t - 1) / 90) : 90 * Math.round(t / 90) }, straighten: function () { return this.rotate(this._getAngleValueForStraighten()) }, fxStraighten: function (t) { t = t || {}; var e = function () { }, i = t.onComplete || e, r = t.onChange || e, n = this; return fabric.util.animate({ target: this, startValue: this.get("angle"), endValue: this._getAngleValueForStraighten(), duration: this.FX_DURATION, onChange: function (t) { n.rotate(t), r() }, onComplete: function () { n.setCoords(), i() } }) } }), fabric.util.object.extend(fabric.StaticCanvas.prototype, { straightenObject: function (t) { return t.straighten(), this.requestRenderAll(), this }, fxStraightenObject: function (t) { return t.fxStraighten({ onChange: this.requestRenderAllBound }) } }); function resizeCanvasIfNeeded(t) { var e = t.targetCanvas, i = e.width, r = e.height, n = t.destinationWidth, a = t.destinationHeight; (i !== n || r !== a) && (e.width = n, e.height = a) } function copyGLTo2DDrawImage(t, e) { var i = t.canvas, r = e.targetCanvas, n = r.getContext("2d"); n.translate(0, r.height), n.scale(1, -1); var a = i.height - r.height; n.drawImage(i, 0, a, r.width, r.height, 0, 0, r.width, r.height) } function copyGLTo2DPutImageData(t, e) { var i = e.targetCanvas, r = i.getContext("2d"), n = e.destinationWidth, a = e.destinationHeight, o = n * a * 4, s = new Uint8Array(this.imageBuffer, 0, o), c = new Uint8ClampedArray(this.imageBuffer, 0, o); t.readPixels(0, 0, n, a, t.RGBA, t.UNSIGNED_BYTE, s); var l = new ImageData(c, n, a); r.putImageData(l, 0, 0) } !function () { "use strict"; function t(t, e) { var i = "precision " + e + " float;\nvoid main(){}", r = t.createShader(t.FRAGMENT_SHADER); return t.shaderSource(r, i), t.compileShader(r), t.getShaderParameter(r, t.COMPILE_STATUS) ? !0 : !1 } function e(t) { t && t.tileSize && (this.tileSize = t.tileSize), this.setupGLContext(this.tileSize, this.tileSize), this.captureGPUInfo() } fabric.isWebglSupported = function (e) { if (fabric.isLikelyNode) return !1; e = e || fabric.WebglFilterBackend.prototype.tileSize; var i = document.createElement("canvas"), r = i.getContext("webgl") || i.getContext("experimental-webgl"), n = !1; if (r) { fabric.maxTextureSize = r.getParameter(r.MAX_TEXTURE_SIZE), n = fabric.maxTextureSize >= e; for (var a = ["highp", "mediump", "lowp"], o = 0; 3 > o; o++)if (t(r, a[o])) { fabric.webGlPrecision = a[o]; break } } return this.isSupported = n, n }, fabric.WebglFilterBackend = e, e.prototype = { tileSize: 2048, resources: {}, setupGLContext: function (t, e) { this.dispose(), this.createWebGLCanvas(t, e), this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]), this.chooseFastestCopyGLTo2DMethod(t, e) }, chooseFastestCopyGLTo2DMethod: function (t, e) { var i, r = "undefined" != typeof window.performance; try { new ImageData(1, 1), i = !0 } catch (n) { i = !1 } var a = "undefined" != typeof ArrayBuffer, o = "undefined" != typeof Uint8ClampedArray; if (r && i && a && o) { var s = fabric.util.createCanvasElement(), c = new ArrayBuffer(t * e * 4); if (fabric.forceGLPutImageData) return this.imageBuffer = c, void (this.copyGLTo2D = copyGLTo2DPutImageData); var l, h, u, f = { imageBuffer: c, destinationWidth: t, destinationHeight: e, targetCanvas: s }; s.width = t, s.height = e, l = window.performance.now(), copyGLTo2DDrawImage.call(f, this.gl, f), h = window.performance.now() - l, l = window.performance.now(), copyGLTo2DPutImageData.call(f, this.gl, f), u = window.performance.now() - l, h > u ? (this.imageBuffer = c, this.copyGLTo2D = copyGLTo2DPutImageData) : this.copyGLTo2D = copyGLTo2DDrawImage } }, createWebGLCanvas: function (t, e) { var i = fabric.util.createCanvasElement(); i.width = t, i.height = e; var r = { alpha: !0, premultipliedAlpha: !1, depth: !1, stencil: !1, antialias: !1 }, n = i.getContext("webgl", r); n || (n = i.getContext("experimental-webgl", r)), n && (n.clearColor(0, 0, 0, 0), this.canvas = i, this.gl = n) }, applyFilters: function (t, e, i, r, n, a) { var o, s = this.gl; a && (o = this.getCachedTexture(a, e)); var c = { originalWidth: e.width || e.originalWidth, originalHeight: e.height || e.originalHeight, sourceWidth: i, sourceHeight: r, destinationWidth: i, destinationHeight: r, context: s, sourceTexture: this.createTexture(s, i, r, !o && e), targetTexture: this.createTexture(s, i, r), originalTexture: o || this.createTexture(s, i, r, !o && e), passes: t.length, webgl: !0, aPosition: this.aPosition, programCache: this.programCache, pass: 0, filterBackend: this, targetCanvas: n }, l = s.createFramebuffer(); return s.bindFramebuffer(s.FRAMEBUFFER, l), t.forEach(function (t) { t && t.applyTo(c) }), resizeCanvasIfNeeded(c), this.copyGLTo2D(s, c), s.bindTexture(s.TEXTURE_2D, null), s.deleteTexture(c.sourceTexture), s.deleteTexture(c.targetTexture), s.deleteFramebuffer(l), n.getContext("2d").setTransform(1, 0, 0, 1, 0, 0), c }, dispose: function () { this.canvas && (this.canvas = null, this.gl = null), this.clearWebGLCaches() }, clearWebGLCaches: function () { this.programCache = {}, this.textureCache = {} }, createTexture: function (t, e, i, r) { var n = t.createTexture(); return t.bindTexture(t.TEXTURE_2D, n), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), r ? t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, r) : t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, e, i, 0, t.RGBA, t.UNSIGNED_BYTE, null), n }, getCachedTexture: function (t, e) { if (this.textureCache[t]) return this.textureCache[t]; var i = this.createTexture(this.gl, e.width, e.height, e); return this.textureCache[t] = i, i }, evictCachesForKey: function (t) { this.textureCache[t] && (this.gl.deleteTexture(this.textureCache[t]), delete this.textureCache[t]) }, copyGLTo2D: copyGLTo2DDrawImage, captureGPUInfo: function () { if (this.gpuInfo) return this.gpuInfo; var t = this.gl, e = { renderer: "", vendor: "" }; if (!t) return e; var i = t.getExtension("WEBGL_debug_renderer_info"); if (i) { var r = t.getParameter(i.UNMASKED_RENDERER_WEBGL), n = t.getParameter(i.UNMASKED_VENDOR_WEBGL); r && (e.renderer = r.toLowerCase()), n && (e.vendor = n.toLowerCase()) } return this.gpuInfo = e, e } } }(); !function () { "use strict"; function t() { } var e = function () { }; fabric.Canvas2dFilterBackend = t, t.prototype = { evictCachesForKey: e, dispose: e, clearWebGLCaches: e, resources: {}, applyFilters: function (t, e, i, r, n) { var a = n.getContext("2d"); a.drawImage(e, 0, 0, i, r); var o = a.getImageData(0, 0, i, r), s = a.getImageData(0, 0, i, r), c = { sourceWidth: i, sourceHeight: r, imageData: o, originalEl: e, originalImageData: s, canvasEl: n, ctx: a, filterBackend: this }; return t.forEach(function (t) { t.applyTo(c) }), (c.imageData.width !== i || c.imageData.height !== r) && (n.width = c.imageData.width, n.height = c.imageData.height), a.putImageData(c.imageData, 0, 0), c } } }(); fabric.Image = fabric.Image || {}, fabric.Image.filters = fabric.Image.filters || {}, fabric.Image.filters.BaseFilter = fabric.util.createClass({ type: "BaseFilter", vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}", fragmentSource: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}", initialize: function (t) { t && this.setOptions(t) }, setOptions: function (t) { for (var e in t) this[e] = t[e] }, createProgram: function (t, e, i) { e = e || this.fragmentSource, i = i || this.vertexSource, "highp" !== fabric.webGlPrecision && (e = e.replace(/precision highp float/g, "precision " + fabric.webGlPrecision + " float")); var r = t.createShader(t.VERTEX_SHADER); if (t.shaderSource(r, i), t.compileShader(r), !t.getShaderParameter(r, t.COMPILE_STATUS)) throw new Error("Vertex shader compile error for " + this.type + ": " + t.getShaderInfoLog(r)); var n = t.createShader(t.FRAGMENT_SHADER); if (t.shaderSource(n, e), t.compileShader(n), !t.getShaderParameter(n, t.COMPILE_STATUS)) throw new Error("Fragment shader compile error for " + this.type + ": " + t.getShaderInfoLog(n)); var o = t.createProgram(); if (t.attachShader(o, r), t.attachShader(o, n), t.linkProgram(o), !t.getProgramParameter(o, t.LINK_STATUS)) throw new Error('Shader link error for "${this.type}" ' + t.getProgramInfoLog(o)); var a = this.getAttributeLocations(t, o), s = this.getUniformLocations(t, o) || {}; return s.uStepW = t.getUniformLocation(o, "uStepW"), s.uStepH = t.getUniformLocation(o, "uStepH"), { program: o, attributeLocations: a, uniformLocations: s } }, getAttributeLocations: function (t, e) { return { aPosition: t.getAttribLocation(e, "aPosition") } }, getUniformLocations: function () { return {} }, sendAttributeData: function (t, e, i) { var r = e.aPosition, n = t.createBuffer(); t.bindBuffer(t.ARRAY_BUFFER, n), t.enableVertexAttribArray(r), t.vertexAttribPointer(r, 2, t.FLOAT, !1, 0, 0), t.bufferData(t.ARRAY_BUFFER, i, t.STATIC_DRAW) }, _setupFrameBuffer: function (t) { var e, i, r = t.context; t.passes > 1 ? (e = t.destinationWidth, i = t.destinationHeight, (t.sourceWidth !== e || t.sourceHeight !== i) && (r.deleteTexture(t.targetTexture), t.targetTexture = t.filterBackend.createTexture(r, e, i)), r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, t.targetTexture, 0)) : (r.bindFramebuffer(r.FRAMEBUFFER, null), r.finish()) }, _swapTextures: function (t) { t.passes--, t.pass++; var e = t.targetTexture; t.targetTexture = t.sourceTexture, t.sourceTexture = e }, isNeutralState: function () { var t = this.mainParameter, e = fabric.Image.filters[this.type].prototype; if (t) { if (Array.isArray(e[t])) { for (var i = e[t].length; i--;)if (this[t][i] !== e[t][i]) return !1; return !0 } return e[t] === this[t] } return !1 }, applyTo: function (t) { t.webgl ? (this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t) }, retrieveShader: function (t) { return t.programCache.hasOwnProperty(this.type) || (t.programCache[this.type] = this.createProgram(t.context)), t.programCache[this.type] }, applyToWebGL: function (t) { var e = t.context, i = this.retrieveShader(t); 0 === t.pass && t.originalTexture ? e.bindTexture(e.TEXTURE_2D, t.originalTexture) : e.bindTexture(e.TEXTURE_2D, t.sourceTexture), e.useProgram(i.program), this.sendAttributeData(e, i.attributeLocations, t.aPosition), e.uniform1f(i.uniformLocations.uStepW, 1 / t.sourceWidth), e.uniform1f(i.uniformLocations.uStepH, 1 / t.sourceHeight), this.sendUniformData(e, i.uniformLocations), e.viewport(0, 0, t.destinationWidth, t.destinationHeight), e.drawArrays(e.TRIANGLE_STRIP, 0, 4) }, bindAdditionalTexture: function (t, e, i) { t.activeTexture(i), t.bindTexture(t.TEXTURE_2D, e), t.activeTexture(t.TEXTURE0) }, unbindAdditionalTexture: function (t, e) { t.activeTexture(e), t.bindTexture(t.TEXTURE_2D, null), t.activeTexture(t.TEXTURE0) }, getMainParameter: function () { return this[this.mainParameter] }, setMainParameter: function (t) { this[this.mainParameter] = t }, sendUniformData: function () { }, createHelpLayer: function (t) { if (!t.helpLayer) { var e = document.createElement("canvas"); e.width = t.sourceWidth, e.height = t.sourceHeight, t.helpLayer = e } }, toObject: function () { var t = { type: this.type }, e = this.mainParameter; return e && (t[e] = this[e]), t }, toJSON: function () { return this.toObject() } }), fabric.Image.filters.BaseFilter.fromObject = function (t, e) { var i = new fabric.Image.filters[t.type](t); return e && e(i), i }; !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.ColorMatrix = r(i.BaseFilter, { type: "ColorMatrix", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}", matrix: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], mainParameter: "matrix", colorsOnly: !0, initialize: function (t) { this.callSuper("initialize", t), this.matrix = this.matrix.slice(0) }, applyTo2d: function (t) { var e, i, r, n, o, a = t.imageData, s = a.data, c = s.length, l = this.matrix, h = this.colorsOnly; for (o = 0; c > o; o += 4)e = s[o], i = s[o + 1], r = s[o + 2], h ? (s[o] = e * l[0] + i * l[1] + r * l[2] + 255 * l[4], s[o + 1] = e * l[5] + i * l[6] + r * l[7] + 255 * l[9], s[o + 2] = e * l[10] + i * l[11] + r * l[12] + 255 * l[14]) : (n = s[o + 3], s[o] = e * l[0] + i * l[1] + r * l[2] + n * l[3] + 255 * l[4], s[o + 1] = e * l[5] + i * l[6] + r * l[7] + n * l[8] + 255 * l[9], s[o + 2] = e * l[10] + i * l[11] + r * l[12] + n * l[13] + 255 * l[14], s[o + 3] = e * l[15] + i * l[16] + r * l[17] + n * l[18] + 255 * l[19]) }, getUniformLocations: function (t, e) { return { uColorMatrix: t.getUniformLocation(e, "uColorMatrix"), uConstants: t.getUniformLocation(e, "uConstants") } }, sendUniformData: function (t, e) { var i = this.matrix, r = [i[0], i[1], i[2], i[3], i[5], i[6], i[7], i[8], i[10], i[11], i[12], i[13], i[15], i[16], i[17], i[18]], n = [i[4], i[9], i[14], i[19]]; t.uniformMatrix4fv(e.uColorMatrix, !1, r), t.uniform4fv(e.uConstants, n) } }), e.Image.filters.ColorMatrix.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Brightness = r(i.BaseFilter, { type: "Brightness", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}", brightness: 0, mainParameter: "brightness", applyTo2d: function (t) { if (0 !== this.brightness) { var e, i = t.imageData, r = i.data, n = r.length, o = Math.round(255 * this.brightness); for (e = 0; n > e; e += 4)r[e] = r[e] + o, r[e + 1] = r[e + 1] + o, r[e + 2] = r[e + 2] + o } }, getUniformLocations: function (t, e) { return { uBrightness: t.getUniformLocation(e, "uBrightness") } }, sendUniformData: function (t, e) { t.uniform1f(e.uBrightness, this.brightness) } }), e.Image.filters.Brightness.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Convolute = n(r.BaseFilter, { type: "Convolute", opaque: !1, matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0], fragmentSource: { Convolute_3_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_3_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}", Convolute_5_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_5_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}", Convolute_7_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_7_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}", Convolute_9_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}", Convolute_9_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}" }, retrieveShader: function (t) { var e = Math.sqrt(this.matrix.length), i = this.type + "_" + e + "_" + (this.opaque ? 1 : 0), r = this.fragmentSource[i]; return t.programCache.hasOwnProperty(i) || (t.programCache[i] = this.createProgram(t.context, r)), t.programCache[i] }, applyTo2d: function (t) { var e, i, r, n, o, a, s, c, l, h, u, f, d, g = t.imageData, p = g.data, m = this.matrix, v = Math.round(Math.sqrt(m.length)), y = Math.floor(v / 2), x = g.width, b = g.height, _ = t.ctx.createImageData(x, b), C = _.data, S = this.opaque ? 1 : 0; for (u = 0; b > u; u++)for (h = 0; x > h; h++) { for (o = 4 * (u * x + h), e = 0, i = 0, r = 0, n = 0, d = 0; v > d; d++)for (f = 0; v > f; f++)s = u + d - y, a = h + f - y, 0 > s || s >= b || 0 > a || a >= x || (c = 4 * (s * x + a), l = m[d * v + f], e += p[c] * l, i += p[c + 1] * l, r += p[c + 2] * l, S || (n += p[c + 3] * l)); C[o] = e, C[o + 1] = i, C[o + 2] = r, C[o + 3] = S ? p[o + 3] : n } t.imageData = _ }, getUniformLocations: function (t, e) { return { uMatrix: t.getUniformLocation(e, "uMatrix"), uOpaque: t.getUniformLocation(e, "uOpaque"), uHalfSize: t.getUniformLocation(e, "uHalfSize"), uSize: t.getUniformLocation(e, "uSize") } }, sendUniformData: function (t, e) { t.uniform1fv(e.uMatrix, this.matrix) }, toObject: function () { return i(this.callSuper("toObject"), { opaque: this.opaque, matrix: this.matrix }) } }), e.Image.filters.Convolute.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Grayscale = r(i.BaseFilter, { type: "Grayscale", fragmentSource: { average: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}", lightness: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}", luminosity: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}" }, mode: "average", mainParameter: "mode", applyTo2d: function (t) { var e, i, r = t.imageData, n = r.data, a = n.length, s = this.mode; for (e = 0; a > e; e += 4)"average" === s ? i = (n[e] + n[e + 1] + n[e + 2]) / 3 : "lightness" === s ? i = (Math.min(n[e], n[e + 1], n[e + 2]) + Math.max(n[e], n[e + 1], n[e + 2])) / 2 : "luminosity" === s && (i = .21 * n[e] + .72 * n[e + 1] + .07 * n[e + 2]), n[e] = i, n[e + 1] = i, n[e + 2] = i }, retrieveShader: function (t) { var e = this.type + "_" + this.mode; if (!t.programCache.hasOwnProperty(e)) { var i = this.fragmentSource[this.mode]; t.programCache[e] = this.createProgram(t.context, i) } return t.programCache[e] }, getUniformLocations: function (t, e) { return { uMode: t.getUniformLocation(e, "uMode") } }, sendUniformData: function (t, e) { var i = 1; t.uniform1i(e.uMode, i) }, isNeutralState: function () { return !1 } }), e.Image.filters.Grayscale.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Invert = r(i.BaseFilter, { type: "Invert", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}", invert: !0, mainParameter: "invert", applyTo2d: function (t) { var e, i = t.imageData, r = i.data, n = r.length; for (e = 0; n > e; e += 4)r[e] = 255 - r[e], r[e + 1] = 255 - r[e + 1], r[e + 2] = 255 - r[e + 2] }, isNeutralState: function () { return !this.invert }, getUniformLocations: function (t, e) { return { uInvert: t.getUniformLocation(e, "uInvert") } }, sendUniformData: function (t, e) { t.uniform1i(e.uInvert, this.invert) } }), e.Image.filters.Invert.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.Noise = n(r.BaseFilter, { type: "Noise", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}", mainParameter: "noise", noise: 0, applyTo2d: function (t) { if (0 !== this.noise) { var e, i, r = t.imageData, n = r.data, a = n.length, s = this.noise; for (e = 0, a = n.length; a > e; e += 4)i = (.5 - Math.random()) * s, n[e] += i, n[e + 1] += i, n[e + 2] += i } }, getUniformLocations: function (t, e) { return { uNoise: t.getUniformLocation(e, "uNoise"), uSeed: t.getUniformLocation(e, "uSeed") } }, sendUniformData: function (t, e) { t.uniform1f(e.uNoise, this.noise / 255), t.uniform1f(e.uSeed, Math.random()) }, toObject: function () { return i(this.callSuper("toObject"), { noise: this.noise }) } }), e.Image.filters.Noise.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass; i.Pixelate = r(i.BaseFilter, { type: "Pixelate", blocksize: 4, mainParameter: "blocksize", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}", applyTo2d: function (t) { var e, i, r, n, a, s, o, c, l, h, u, f = t.imageData, d = f.data, g = f.height, p = f.width; for (i = 0; g > i; i += this.blocksize)for (r = 0; p > r; r += this.blocksize)for (e = 4 * i * p + 4 * r, n = d[e], a = d[e + 1], s = d[e + 2], o = d[e + 3], h = Math.min(i + this.blocksize, g), u = Math.min(r + this.blocksize, p), c = i; h > c; c++)for (l = r; u > l; l++)e = 4 * c * p + 4 * l, d[e] = n, d[e + 1] = a, d[e + 2] = s, d[e + 3] = o }, isNeutralState: function () { return 1 === this.blocksize }, getUniformLocations: function (t, e) { return { uBlocksize: t.getUniformLocation(e, "uBlocksize"), uStepW: t.getUniformLocation(e, "uStepW"), uStepH: t.getUniformLocation(e, "uStepH") } }, sendUniformData: function (t, e) { t.uniform1f(e.uBlocksize, this.blocksize) } }), e.Image.filters.Pixelate.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.extend, r = e.Image.filters, n = e.util.createClass; r.RemoveColor = n(r.BaseFilter, { type: "RemoveColor", color: "#FFFFFF", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}", distance: .02, useAlpha: !1, applyTo2d: function (t) { var i, r, n, s, a = t.imageData, o = a.data, c = 255 * this.distance, l = new e.Color(this.color).getSource(), h = [l[0] - c, l[1] - c, l[2] - c], u = [l[0] + c, l[1] + c, l[2] + c]; for (i = 0; i < o.length; i += 4)r = o[i], n = o[i + 1], s = o[i + 2], r > h[0] && n > h[1] && s > h[2] && r < u[0] && n < u[1] && s < u[2] && (o[i + 3] = 0) }, getUniformLocations: function (t, e) { return { uLow: t.getUniformLocation(e, "uLow"), uHigh: t.getUniformLocation(e, "uHigh") } }, sendUniformData: function (t, i) { var r = new e.Color(this.color).getSource(), n = parseFloat(this.distance), s = [0 + r[0] / 255 - n, 0 + r[1] / 255 - n, 0 + r[2] / 255 - n, 1], a = [r[0] / 255 + n, r[1] / 255 + n, r[2] / 255 + n, 1]; t.uniform4fv(i.uLow, s), t.uniform4fv(i.uHigh, a) }, toObject: function () { return i(this.callSuper("toObject"), { color: this.color, distance: this.distance }) } }), e.Image.filters.RemoveColor.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, r = e.util.createClass, n = { Brownie: [.5997, .34553, -.27082, 0, .186, -.0377, .86095, .15059, 0, -.1449, .24113, -.07441, .44972, 0, -.02965, 0, 0, 0, 1, 0], Vintage: [.62793, .32021, -.03965, 0, .03784, .02578, .64411, .03259, 0, .02926, .0466, -.08512, .52416, 0, .02023, 0, 0, 0, 1, 0], Kodachrome: [1.12855, -.39673, -.03992, 0, .24991, -.16404, 1.08352, -.05498, 0, .09698, -.16786, -.56034, 1.60148, 0, .13972, 0, 0, 0, 1, 0], Technicolor: [1.91252, -.85453, -.09155, 0, .04624, -.30878, 1.76589, -.10601, 0, -.27589, -.2311, -.75018, 1.84759, 0, .12137, 0, 0, 0, 1, 0], Polaroid: [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0], Sepia: [.393, .769, .189, 0, 0, .349, .686, .168, 0, 0, .272, .534, .131, 0, 0, 0, 0, 0, 1, 0], BlackWhite: [1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 1.5, 1.5, 1.5, 0, -1, 0, 0, 0, 1, 0] }; for (var s in n) i[s] = r(i.ColorMatrix, { type: s, matrix: n[s], mainParameter: !1, colorsOnly: !0 }), e.Image.filters[s].fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric, i = e.Image.filters, r = e.util.createClass; i.BlendColor = r(i.BaseFilter, { type: "BlendColor", color: "#F95C63", mode: "multiply", alpha: 1, fragmentSource: { multiply: "gl_FragColor.rgb *= uColor.rgb;\n", screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n", add: "gl_FragColor.rgb += uColor.rgb;\n", diff: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n", subtract: "gl_FragColor.rgb -= uColor.rgb;\n", lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n", darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n", exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n", overlay: "if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n", tint: "gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n" }, buildSource: function (t) { return "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n" + this.fragmentSource[t] + "}\n}" }, retrieveShader: function (t) { var e, i = this.type + "_" + this.mode; return t.programCache.hasOwnProperty(i) || (e = this.buildSource(this.mode), t.programCache[i] = this.createProgram(t.context, e)), t.programCache[i] }, applyTo2d: function (t) { var i, r, n, s, a, o, c, l = t.imageData, h = l.data, u = h.length, f = 1 - this.alpha; c = new e.Color(this.color).getSource(), i = c[0] * this.alpha, r = c[1] * this.alpha, n = c[2] * this.alpha; for (var d = 0; u > d; d += 4)switch (s = h[d], a = h[d + 1], o = h[d + 2], this.mode) { case "multiply": h[d] = s * i / 255, h[d + 1] = a * r / 255, h[d + 2] = o * n / 255; break; case "screen": h[d] = 255 - (255 - s) * (255 - i) / 255, h[d + 1] = 255 - (255 - a) * (255 - r) / 255, h[d + 2] = 255 - (255 - o) * (255 - n) / 255; break; case "add": h[d] = s + i, h[d + 1] = a + r, h[d + 2] = o + n; break; case "diff": case "difference": h[d] = Math.abs(s - i), h[d + 1] = Math.abs(a - r), h[d + 2] = Math.abs(o - n); break; case "subtract": h[d] = s - i, h[d + 1] = a - r, h[d + 2] = o - n; break; case "darken": h[d] = Math.min(s, i), h[d + 1] = Math.min(a, r), h[d + 2] = Math.min(o, n); break; case "lighten": h[d] = Math.max(s, i), h[d + 1] = Math.max(a, r), h[d + 2] = Math.max(o, n); break; case "overlay": h[d] = 128 > i ? 2 * s * i / 255 : 255 - 2 * (255 - s) * (255 - i) / 255, h[d + 1] = 128 > r ? 2 * a * r / 255 : 255 - 2 * (255 - a) * (255 - r) / 255, h[d + 2] = 128 > n ? 2 * o * n / 255 : 255 - 2 * (255 - o) * (255 - n) / 255; break; case "exclusion": h[d] = i + s - 2 * i * s / 255, h[d + 1] = r + a - 2 * r * a / 255, h[d + 2] = n + o - 2 * n * o / 255; break; case "tint": h[d] = i + s * f, h[d + 1] = r + a * f, h[d + 2] = n + o * f } }, getUniformLocations: function (t, e) { return { uColor: t.getUniformLocation(e, "uColor") } }, sendUniformData: function (t, i) { var r = new e.Color(this.color).getSource(); r[0] = this.alpha * r[0] / 255, r[1] = this.alpha * r[1] / 255, r[2] = this.alpha * r[2] / 255, r[3] = this.alpha, t.uniform4fv(i.uColor, r) }, toObject: function () { return { type: this.type, color: this.color, mode: this.mode, alpha: this.alpha } } }), e.Image.filters.BlendColor.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric, i = e.Image.filters, r = e.util.createClass; i.BlendImage = r(i.BaseFilter, { type: "BlendImage", image: null, mode: "multiply", alpha: 1, vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}", fragmentSource: { multiply: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}", mask: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}" }, retrieveShader: function (t) { var e = this.type + "_" + this.mode, i = this.fragmentSource[this.mode]; return t.programCache.hasOwnProperty(e) || (t.programCache[e] = this.createProgram(t.context, i)), t.programCache[e] }, applyToWebGL: function (t) { var e = t.context, i = this.createTexture(t.filterBackend, this.image); this.bindAdditionalTexture(e, i, e.TEXTURE1), this.callSuper("applyToWebGL", t), this.unbindAdditionalTexture(e, e.TEXTURE1) }, createTexture: function (t, e) { return t.getCachedTexture(e.cacheKey, e._element) }, calculateMatrix: function () { var t = this.image, e = t._element.width, i = t._element.height; return [1 / t.scaleX, 0, 0, 0, 1 / t.scaleY, 0, -t.left / e, -t.top / i, 1] }, applyTo2d: function (t) { var i, r, n, s, a, o, c, l, h, u, f, d = t.imageData, p = t.filterBackend.resources, g = d.data, m = g.length, v = d.width, y = d.height, b = this.image; p.blendImage || (p.blendImage = e.util.createCanvasElement()), h = p.blendImage, u = h.getContext("2d"), h.width !== v || h.height !== y ? (h.width = v, h.height = y) : u.clearRect(0, 0, v, y), u.setTransform(b.scaleX, 0, 0, b.scaleY, b.left, b.top), u.drawImage(b._element, 0, 0, v, y), f = u.getImageData(0, 0, v, y).data; for (var x = 0; m > x; x += 4)switch (a = g[x], o = g[x + 1], c = g[x + 2], l = g[x + 3], i = f[x], r = f[x + 1], n = f[x + 2], s = f[x + 3], this.mode) { case "multiply": g[x] = a * i / 255, g[x + 1] = o * r / 255, g[x + 2] = c * n / 255, g[x + 3] = l * s / 255; break; case "mask": g[x + 3] = s } }, getUniformLocations: function (t, e) { return { uTransformMatrix: t.getUniformLocation(e, "uTransformMatrix"), uImage: t.getUniformLocation(e, "uImage") } }, sendUniformData: function (t, e) { var i = this.calculateMatrix(); t.uniform1i(e.uImage, 1), t.uniformMatrix3fv(e.uTransformMatrix, !1, i) }, toObject: function () { return { type: this.type, image: this.image && this.image.toObject(), mode: this.mode, alpha: this.alpha } } }), e.Image.filters.BlendImage.fromObject = function (t, i) { e.Image.fromObject(t.image, function (r) { var n = e.util.object.clone(t); n.image = r, i(new e.Image.filters.BlendImage(n)) }) } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = Math.pow, r = Math.floor, n = Math.sqrt, s = Math.abs, a = Math.round, o = Math.sin, c = Math.ceil, l = e.Image.filters, h = e.util.createClass; l.Resize = h(l.BaseFilter, { type: "Resize", resizeType: "hermite", scaleX: 1, scaleY: 1, lanczosLobes: 3, getUniformLocations: function (t, e) { return { uDelta: t.getUniformLocation(e, "uDelta"), uTaps: t.getUniformLocation(e, "uTaps") } }, sendUniformData: function (t, e) { t.uniform2fv(e.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]), t.uniform1fv(e.uTaps, this.taps) }, retrieveShader: function (t) { var e = this.getFilterWindow(), i = this.type + "_" + e; if (!t.programCache.hasOwnProperty(i)) { var r = this.generateShader(e); t.programCache[i] = this.createProgram(t.context, r) } return t.programCache[i] }, getFilterWindow: function () { var t = this.tempScale; return Math.ceil(this.lanczosLobes / t) }, getTaps: function () { for (var t = this.lanczosCreate(this.lanczosLobes), e = this.tempScale, i = this.getFilterWindow(), r = new Array(i), n = 1; i >= n; n++)r[n - 1] = t(n * e); return r }, generateShader: function (t) { for (var t, e = new Array(t), i = this.fragmentSourceTOP, r = 1; t >= r; r++)e[r - 1] = r + ".0 * uDelta"; return i += "uniform float uTaps[" + t + "];\n", i += "void main() {\n", i += "  vec4 color = texture2D(uTexture, vTexCoord);\n", i += "  float sum = 1.0;\n", e.forEach(function (t, e) { i += "  color += texture2D(uTexture, vTexCoord + " + t + ") * uTaps[" + e + "];\n", i += "  color += texture2D(uTexture, vTexCoord - " + t + ") * uTaps[" + e + "];\n", i += "  sum += 2.0 * uTaps[" + e + "];\n" }), i += "  gl_FragColor = color / sum;\n", i += "}" }, fragmentSourceTOP: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n", applyTo: function (t) { t.webgl ? (t.passes++, this.width = t.sourceWidth, this.horizontal = !0, this.dW = Math.round(this.width * this.scaleX), this.dH = t.sourceHeight, this.tempScale = this.dW / this.width, this.taps = this.getTaps(), t.destinationWidth = this.dW, this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t), t.sourceWidth = t.destinationWidth, this.height = t.sourceHeight, this.horizontal = !1, this.dH = Math.round(this.height * this.scaleY), this.tempScale = this.dH / this.height, this.taps = this.getTaps(), t.destinationHeight = this.dH, this._setupFrameBuffer(t), this.applyToWebGL(t), this._swapTextures(t), t.sourceHeight = t.destinationHeight) : this.applyTo2d(t) }, isNeutralState: function () { return 1 === this.scaleX && 1 === this.scaleY }, lanczosCreate: function (t) { return function (e) { if (e >= t || -t >= e) return 0; if (1.1920929e-7 > e && e > -1.1920929e-7) return 1; e *= Math.PI; var i = e / t; return o(e) / e * o(i) / i } }, applyTo2d: function (t) { var e = t.imageData, i = this.scaleX, r = this.scaleY; this.rcpScaleX = 1 / i, this.rcpScaleY = 1 / r; var n, s = e.width, o = e.height, c = a(s * i), l = a(o * r); "sliceHack" === this.resizeType ? n = this.sliceByTwo(t, s, o, c, l) : "hermite" === this.resizeType ? n = this.hermiteFastResize(t, s, o, c, l) : "bilinear" === this.resizeType ? n = this.bilinearFiltering(t, s, o, c, l) : "lanczos" === this.resizeType && (n = this.lanczosResize(t, s, o, c, l)), t.imageData = n }, sliceByTwo: function (t, i, n, s, a) { var o, c, l = t.imageData, h = .5, u = !1, f = !1, d = i * h, p = n * h, g = e.filterBackend.resources, m = 0, v = 0, y = i, b = 0; for (g.sliceByTwo || (g.sliceByTwo = document.createElement("canvas")), o = g.sliceByTwo, (o.width < 1.5 * i || o.height < n) && (o.width = 1.5 * i, o.height = n), c = o.getContext("2d"), c.clearRect(0, 0, 1.5 * i, n), c.putImageData(l, 0, 0), s = r(s), a = r(a); !u || !f;)i = d, n = p, s < r(d * h) ? d = r(d * h) : (d = s, u = !0), a < r(p * h) ? p = r(p * h) : (p = a, f = !0), c.drawImage(o, m, v, i, n, y, b, d, p), m = y, v = b, b += p; return c.getImageData(m, v, s, a) }, lanczosResize: function (t, e, a, o, l) { function h(t) { var c, T, w, O, E, k, L, M, A, P, D; for (S.x = (t + .5) * g, C.x = r(S.x), c = 0; l > c; c++) { for (S.y = (c + .5) * m, C.y = r(S.y), E = 0, k = 0, L = 0, M = 0, A = 0, T = C.x - b; T <= C.x + b; T++)if (!(0 > T || T >= e)) { P = r(1e3 * s(T - S.x)), _[P] || (_[P] = {}); for (var I = C.y - x; I <= C.y + x; I++)0 > I || I >= a || (D = r(1e3 * s(I - S.y)), _[P][D] || (_[P][D] = p(n(i(P * v, 2) + i(D * y, 2)) / 1e3)), w = _[P][D], w > 0 && (O = 4 * (I * e + T), E += w, k += w * u[O], L += w * u[O + 1], M += w * u[O + 2], A += w * u[O + 3])) } O = 4 * (c * o + t), d[O] = k / E, d[O + 1] = L / E, d[O + 2] = M / E, d[O + 3] = A / E } return ++t < o ? h(t) : f } var u = t.imageData.data, f = t.ctx.createImageData(o, l), d = f.data, p = this.lanczosCreate(this.lanczosLobes), g = this.rcpScaleX, m = this.rcpScaleY, v = 2 / this.rcpScaleX, y = 2 / this.rcpScaleY, b = c(g * this.lanczosLobes / 2), x = c(m * this.lanczosLobes / 2), _ = {}, S = {}, C = {}; return h(0) }, bilinearFiltering: function (t, e, i, n, s) { var a, o, c, l, h, u, f, d, p, g, m, v, y, b = 0, x = this.rcpScaleX, _ = this.rcpScaleY, S = 4 * (e - 1), C = t.imageData, T = C.data, w = t.ctx.createImageData(n, s), O = w.data; for (f = 0; s > f; f++)for (d = 0; n > d; d++)for (h = r(x * d), u = r(_ * f), p = x * d - h, g = _ * f - u, y = 4 * (u * e + h), m = 0; 4 > m; m++)a = T[y + m], o = T[y + 4 + m], c = T[y + S + m], l = T[y + S + 4 + m], v = a * (1 - p) * (1 - g) + o * p * (1 - g) + c * g * (1 - p) + l * p * g, O[b++] = v; return w }, hermiteFastResize: function (t, e, i, a, o) { for (var l = this.rcpScaleX, h = this.rcpScaleY, u = c(l / 2), f = c(h / 2), d = t.imageData, p = d.data, g = t.ctx.createImageData(a, o), m = g.data, v = 0; o > v; v++)for (var y = 0; a > y; y++) { for (var b = 4 * (y + v * a), x = 0, _ = 0, S = 0, C = 0, T = 0, w = 0, O = 0, E = (v + .5) * h, k = r(v * h); (v + 1) * h > k; k++)for (var L = s(E - (k + .5)) / f, M = (y + .5) * l, A = L * L, P = r(y * l); (y + 1) * l > P; P++) { var D = s(M - (P + .5)) / u, I = n(A + D * D); I > 1 && -1 > I || (x = 2 * I * I * I - 3 * I * I + 1, x > 0 && (D = 4 * (P + k * e), O += x * p[D + 3], S += x, p[D + 3] < 255 && (x = x * p[D + 3] / 250), C += x * p[D], T += x * p[D + 1], w += x * p[D + 2], _ += x)) } m[b] = C / _, m[b + 1] = T / _, m[b + 2] = w / _, m[b + 3] = O / S } return g }, toObject: function () { return { type: this.type, scaleX: this.scaleX, scaleY: this.scaleY, resizeType: this.resizeType, lanczosLobes: this.lanczosLobes } } }), e.Image.filters.Resize.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, n = e.util.createClass; i.Contrast = n(i.BaseFilter, { type: "Contrast", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}", contrast: 0, mainParameter: "contrast", applyTo2d: function (t) { if (0 !== this.contrast) { var e, i, n = t.imageData, r = n.data, i = r.length, s = Math.floor(255 * this.contrast), a = 259 * (s + 255) / (255 * (259 - s)); for (e = 0; i > e; e += 4)r[e] = a * (r[e] - 128) + 128, r[e + 1] = a * (r[e + 1] - 128) + 128, r[e + 2] = a * (r[e + 2] - 128) + 128 } }, getUniformLocations: function (t, e) { return { uContrast: t.getUniformLocation(e, "uContrast") } }, sendUniformData: function (t, e) { t.uniform1f(e.uContrast, this.contrast) } }), e.Image.filters.Contrast.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, n = e.util.createClass; i.Saturation = n(i.BaseFilter, { type: "Saturation", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}", saturation: 0, mainParameter: "saturation", applyTo2d: function (t) { if (0 !== this.saturation) { var e, i, n = t.imageData, r = n.data, s = r.length, a = -this.saturation; for (e = 0; s > e; e += 4)i = Math.max(r[e], r[e + 1], r[e + 2]), r[e] += i !== r[e] ? (i - r[e]) * a : 0, r[e + 1] += i !== r[e + 1] ? (i - r[e + 1]) * a : 0, r[e + 2] += i !== r[e + 2] ? (i - r[e + 2]) * a : 0 } }, getUniformLocations: function (t, e) { return { uSaturation: t.getUniformLocation(e, "uSaturation") } }, sendUniformData: function (t, e) { t.uniform1f(e.uSaturation, -this.saturation) } }), e.Image.filters.Saturation.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, n = e.util.createClass; i.Blur = n(i.BaseFilter, { type: "Blur", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}", blur: 0, mainParameter: "blur", applyTo: function (t) { t.webgl ? (this.aspectRatio = t.sourceWidth / t.sourceHeight, t.passes++, this._setupFrameBuffer(t), this.horizontal = !0, this.applyToWebGL(t), this._swapTextures(t), this._setupFrameBuffer(t), this.horizontal = !1, this.applyToWebGL(t), this._swapTextures(t)) : this.applyTo2d(t) }, applyTo2d: function (t) { t.imageData = this.simpleBlur(t) }, simpleBlur: function (t) { var i, n, r = t.filterBackend.resources, s = t.imageData.width, a = t.imageData.height; r.blurLayer1 || (r.blurLayer1 = e.util.createCanvasElement(), r.blurLayer2 = e.util.createCanvasElement()), i = r.blurLayer1, n = r.blurLayer2, (i.width !== s || i.height !== a) && (n.width = i.width = s, n.height = i.height = a); var o, c, h, l, f = i.getContext("2d"), u = n.getContext("2d"), d = 15, p = .06 * this.blur * .5; for (f.putImageData(t.imageData, 0, 0), u.clearRect(0, 0, s, a), l = -d; d >= l; l++)o = (Math.random() - .5) / 4, c = l / d, h = p * c * s + o, u.globalAlpha = 1 - Math.abs(c), u.drawImage(i, h, o), f.drawImage(n, 0, 0), u.globalAlpha = 1, u.clearRect(0, 0, n.width, n.height); for (l = -d; d >= l; l++)o = (Math.random() - .5) / 4, c = l / d, h = p * c * a + o, u.globalAlpha = 1 - Math.abs(c), u.drawImage(i, o, h), f.drawImage(n, 0, 0), u.globalAlpha = 1, u.clearRect(0, 0, n.width, n.height); t.ctx.drawImage(i, 0, 0); var g = t.ctx.getImageData(0, 0, i.width, i.height); return f.globalAlpha = 1, f.clearRect(0, 0, i.width, i.height), g }, getUniformLocations: function (t, e) { return { delta: t.getUniformLocation(e, "uDelta") } }, sendUniformData: function (t, e) { var i = this.chooseRightDelta(); t.uniform2fv(e.delta, i) }, chooseRightDelta: function () { var t, e = 1, i = [0, 0]; return this.horizontal ? this.aspectRatio > 1 && (e = 1 / this.aspectRatio) : this.aspectRatio < 1 && (e = this.aspectRatio), t = e * this.blur * .12, this.horizontal ? i[0] = t : i[1] = t, i } }), i.Blur.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, n = e.util.createClass; i.Gamma = n(i.BaseFilter, { type: "Gamma", fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}", gamma: [1, 1, 1], mainParameter: "gamma", initialize: function (t) { this.gamma = [1, 1, 1], i.BaseFilter.prototype.initialize.call(this, t) }, applyTo2d: function (t) { var e, i = t.imageData, n = i.data, r = this.gamma, s = n.length, a = 1 / r[0], o = 1 / r[1], h = 1 / r[2]; for (this.rVals || (this.rVals = new Uint8Array(256), this.gVals = new Uint8Array(256), this.bVals = new Uint8Array(256)), e = 0, s = 256; s > e; e++)this.rVals[e] = 255 * Math.pow(e / 255, a), this.gVals[e] = 255 * Math.pow(e / 255, o), this.bVals[e] = 255 * Math.pow(e / 255, h); for (e = 0, s = n.length; s > e; e += 4)n[e] = this.rVals[n[e]], n[e + 1] = this.gVals[n[e + 1]], n[e + 2] = this.bVals[n[e + 2]] }, getUniformLocations: function (t, e) { return { uGamma: t.getUniformLocation(e, "uGamma") } }, sendUniformData: function (t, e) { t.uniform3fv(e.uGamma, this.gamma) } }), e.Image.filters.Gamma.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, n = e.util.createClass; i.Composed = n(i.BaseFilter, { type: "Composed", subFilters: [], initialize: function (t) { this.callSuper("initialize", t), this.subFilters = this.subFilters.slice(0) }, applyTo: function (t) { t.passes += this.subFilters.length - 1, this.subFilters.forEach(function (e) { e.applyTo(t) }) }, toObject: function () { return e.util.object.extend(this.callSuper("toObject"), { subFilters: this.subFilters.map(function (t) { return t.toObject() }) }) }, isNeutralState: function () { return !this.subFilters.some(function (t) { return !t.isNeutralState() }) } }), e.Image.filters.Composed.fromObject = function (t, i) { var n = t.subFilters || [], r = n.map(function (t) { return new e.Image.filters[t.type](t) }), s = new e.Image.filters.Composed({ subFilters: r }); return i && i(s), s } }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.Image.filters, n = e.util.createClass; i.HueRotation = n(i.ColorMatrix, { type: "HueRotation", rotation: 0, mainParameter: "rotation", calculateMatrix: function () { var t = this.rotation * Math.PI, i = e.util.cos(t), n = e.util.sin(t), r = 1 / 3, s = Math.sqrt(r) * n, a = 1 - i; this.matrix = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], this.matrix[0] = i + a / 3, this.matrix[1] = r * a - s, this.matrix[2] = r * a + s, this.matrix[5] = r * a + s, this.matrix[6] = i + r * a, this.matrix[7] = r * a - s, this.matrix[10] = r * a - s, this.matrix[11] = r * a + s, this.matrix[12] = i + r * a }, isNeutralState: function (t) { return this.calculateMatrix(), i.BaseFilter.prototype.isNeutralState.call(this, t) }, applyTo: function (t) { this.calculateMatrix(), i.BaseFilter.prototype.applyTo.call(this, t) } }), e.Image.filters.HueRotation.fromObject = e.Image.filters.BaseFilter.fromObject }("undefined" != typeof exports ? exports : this); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}), i = e.util.object.clone; if (e.Text) return void e.warn("fabric.Text is already defined"); var n = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide pathAlign".split(" "); e.Text = e.util.createClass(e.Object, { _dimensionAffectingProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "lineHeight", "text", "charSpacing", "textAlign", "styles", "path", "pathStartOffset", "pathSide", "pathAlign"], _reNewline: /\r?\n/, _reSpacesAndTabs: /[ \t\r]/g, _reSpaceAndTab: /[ \t\r]/, _reWords: /\S+/g, type: "text", fontSize: 40, fontWeight: "normal", fontFamily: "Times New Roman", underline: !1, overline: !1, linethrough: !1, textAlign: "left", fontStyle: "normal", lineHeight: 1.16, superscript: { size: .6, baseline: -.35 }, subscript: { size: .6, baseline: .11 }, textBackgroundColor: "", stateProperties: e.Object.prototype.stateProperties.concat(n), cacheProperties: e.Object.prototype.cacheProperties.concat(n), stroke: null, shadow: null, path: null, pathStartOffset: 0, pathSide: "left", pathAlign: "baseline", _fontSizeFraction: .222, offsets: { underline: .1, linethrough: -.315, overline: -.88 }, _fontSizeMult: 1.13, charSpacing: 0, styles: null, _measuringContext: null, deltaY: 0, direction: "ltr", _styleProperties: ["stroke", "strokeWidth", "fill", "fontFamily", "fontSize", "fontWeight", "fontStyle", "underline", "overline", "linethrough", "deltaY", "textBackgroundColor"], __charBounds: [], CACHE_FONT_SIZE: 400, MIN_TEXT_WIDTH: 2, initialize: function (t, e) { this.styles = e ? e.styles || {} : {}, this.text = t, this.__skipDimension = !0, this.callSuper("initialize", e), this.path && this.setPathInfo(), this.__skipDimension = !1, this.initDimensions(), this.setCoords(), this.setupState({ propertySet: "_dimensionAffectingProps" }) }, setPathInfo: function () { var t = this.path; t && (t.segmentsInfo = e.util.getPathSegmentsInfo(t.path)) }, getMeasuringContext: function () { return e._measuringContext || (e._measuringContext = this.canvas && this.canvas.contextCache || e.util.createCanvasElement().getContext("2d")), e._measuringContext }, _splitText: function () { var t = this._splitTextIntoLines(this.text); return this.textLines = t.lines, this._textLines = t.graphemeLines, this._unwrappedTextLines = t._unwrappedLines, this._text = t.graphemeText, t }, initDimensions: function () { this.__skipDimension || (this._splitText(), this._clearCache(), this.path ? (this.width = this.path.width, this.height = this.path.height) : (this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH, this.height = this.calcTextHeight()), -1 !== this.textAlign.indexOf("justify") && this.enlargeSpaces(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, enlargeSpaces: function () { for (var t, e, i, n, r, s, a, o = 0, h = this._textLines.length; h > o; o++)if (("justify" === this.textAlign || o !== h - 1 && !this.isEndOfWrapping(o)) && (n = 0, r = this._textLines[o], e = this.getLineWidth(o), e < this.width && (a = this.textLines[o].match(this._reSpacesAndTabs)))) { i = a.length, t = (this.width - e) / i; for (var c = 0, l = r.length; l >= c; c++)s = this.__charBounds[o][c], this._reSpaceAndTab.test(r[c]) ? (s.width += t, s.kernedWidth += t, s.left += n, n += t) : s.left += n } }, isEndOfWrapping: function (t) { return t === this._textLines.length - 1 }, missingNewlineOffset: function () { return 1 }, toString: function () { return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>' }, _getCacheCanvasDimensions: function () { var t = this.callSuper("_getCacheCanvasDimensions"), e = this.fontSize; return t.width += e * t.zoomX, t.height += e * t.zoomY, t }, _render: function (t) { var e = this.path; e && !e.isNotVisible() && e._render(t), this._setTextStyles(t), this._renderTextLinesBackground(t), this._renderTextDecoration(t, "underline"), this._renderText(t), this._renderTextDecoration(t, "overline"), this._renderTextDecoration(t, "linethrough") }, _renderText: function (t) { "stroke" === this.paintFirst ? (this._renderTextStroke(t), this._renderTextFill(t)) : (this._renderTextFill(t), this._renderTextStroke(t)) }, _setTextStyles: function (t, e, i) { if (t.textBaseline = "alphabetical", this.path) switch (this.pathAlign) { case "center": t.textBaseline = "middle"; break; case "ascender": t.textBaseline = "top"; break; case "descender": t.textBaseline = "bottom" }t.font = this._getFontDeclaration(e, i) }, calcTextWidth: function () { for (var t = this.getLineWidth(0), e = 1, i = this._textLines.length; i > e; e++) { var n = this.getLineWidth(e); n > t && (t = n) } return t }, _renderTextLine: function (t, e, i, n, r, s) { this._renderChars(t, e, i, n, r, s) }, _renderTextLinesBackground: function (t) { if (this.textBackgroundColor || this.styleHas("textBackgroundColor")) { for (var e, i, n, r, s, a, o, h = t.fillStyle, c = this._getLeftOffset(), l = this._getTopOffset(), f = 0, u = 0, d = this.path, p = 0, g = this._textLines.length; g > p; p++)if (e = this.getHeightOfLine(p), this.textBackgroundColor || this.styleHas("textBackgroundColor", p)) { n = this._textLines[p], i = this._getLineLeftOffset(p), u = 0, f = 0, r = this.getValueOfPropertyAt(p, 0, "textBackgroundColor"); for (var v = 0, y = n.length; y > v; v++)s = this.__charBounds[p][v], a = this.getValueOfPropertyAt(p, v, "textBackgroundColor"), d ? (t.save(), t.translate(s.renderLeft, s.renderTop), t.rotate(s.angle), t.fillStyle = a, a && t.fillRect(-s.width / 2, -e / this.lineHeight * (1 - this._fontSizeFraction), s.width, e / this.lineHeight), t.restore()) : a !== r ? (o = c + i + f, "rtl" === this.direction && (o = this.width - o - u), t.fillStyle = r, r && t.fillRect(o, l, u, e / this.lineHeight), f = s.left, u = s.width, r = a) : u += s.kernedWidth; a && !d && (o = c + i + f, "rtl" === this.direction && (o = this.width - o - u), t.fillStyle = a, t.fillRect(o, l, u, e / this.lineHeight)), l += e } else l += e; t.fillStyle = h, this._removeShadow(t) } }, getFontCache: function (t) { var i = t.fontFamily.toLowerCase(); e.charWidthsCache[i] || (e.charWidthsCache[i] = {}); var n = e.charWidthsCache[i], r = t.fontStyle.toLowerCase() + "_" + (t.fontWeight + "").toLowerCase(); return n[r] || (n[r] = {}), n[r] }, _measureChar: function (t, e, i, n) { var r, s, a, o, h = this.getFontCache(e), c = this._getFontDeclaration(e), l = this._getFontDeclaration(n), f = i + t, u = c === l, d = e.fontSize / this.CACHE_FONT_SIZE; if (i && void 0 !== h[i] && (a = h[i]), void 0 !== h[t] && (o = r = h[t]), u && void 0 !== h[f] && (s = h[f], o = s - a), void 0 === r || void 0 === a || void 0 === s) { var p = this.getMeasuringContext(); this._setTextStyles(p, e, !0) } return void 0 === r && (o = r = p.measureText(t).width, h[t] = r), void 0 === a && u && i && (a = p.measureText(i).width, h[i] = a), u && void 0 === s && (s = p.measureText(f).width, h[f] = s, o = s - a), { width: r * d, kernedWidth: o * d } }, getHeightOfChar: function (t, e) { return this.getValueOfPropertyAt(t, e, "fontSize") }, measureLine: function (t) { var e = this._measureLine(t); return 0 !== this.charSpacing && (e.width -= this._getWidthOfCharSpacing()), e.width < 0 && (e.width = 0), e }, _measureLine: function (t) { var i, n, r, s, a, o, h = 0, c = this._textLines[t], l = 0, f = new Array(c.length), u = 0, d = this.path, p = "right" === this.pathSide; for (this.__charBounds[t] = f, i = 0; i < c.length; i++)n = c[i], s = this._getGraphemeBox(n, t, i, r), f[i] = s, h += s.kernedWidth, r = n; if (f[i] = { left: s ? s.left + s.width : 0, width: 0, kernedWidth: 0, height: this.fontSize }, d) { switch (o = d.segmentsInfo[d.segmentsInfo.length - 1].length, a = e.util.getPointOnPath(d.path, 0, d.segmentsInfo), a.x += d.pathOffset.x, a.y += d.pathOffset.y, this.textAlign) { case "left": u = p ? o - h : 0; break; case "center": u = (o - h) / 2; break; case "right": u = p ? 0 : o - h }for (u += this.pathStartOffset * (p ? -1 : 1), i = p ? c.length - 1 : 0; p ? i >= 0 : i < c.length; p ? i-- : i++)s = f[i], u > o ? u %= o : 0 > u && (u += o), this._setGraphemeOnPath(u, s, a), u += s.kernedWidth } return { width: h, numOfSpaces: l } }, _setGraphemeOnPath: function (t, i, n) { var r = t + i.kernedWidth / 2, s = this.path, a = e.util.getPointOnPath(s.path, r, s.segmentsInfo); i.renderLeft = a.x - n.x, i.renderTop = a.y - n.y, i.angle = a.angle + ("right" === this.pathSide ? Math.PI : 0) }, _getGraphemeBox: function (t, e, i, n, r) { var s, a = this.getCompleteStyleDeclaration(e, i), o = n ? this.getCompleteStyleDeclaration(e, i - 1) : {}, h = this._measureChar(t, a, n, o), c = h.kernedWidth, l = h.width; 0 !== this.charSpacing && (s = this._getWidthOfCharSpacing(), l += s, c += s); var f = { width: l, left: 0, height: a.fontSize, kernedWidth: c, deltaY: a.deltaY }; if (i > 0 && !r) { var u = this.__charBounds[e][i - 1]; f.left = u.left + u.width + h.kernedWidth - h.width } return f }, getHeightOfLine: function (t) { if (this.__lineHeights[t]) return this.__lineHeights[t]; for (var e = this._textLines[t], i = this.getHeightOfChar(t, 0), n = 1, r = e.length; r > n; n++)i = Math.max(this.getHeightOfChar(t, n), i); return this.__lineHeights[t] = i * this.lineHeight * this._fontSizeMult }, calcTextHeight: function () { for (var t, e = 0, i = 0, n = this._textLines.length; n > i; i++)t = this.getHeightOfLine(i), e += i === n - 1 ? t / this.lineHeight : t; return e }, _getLeftOffset: function () { return "ltr" === this.direction ? -this.width / 2 : this.width / 2 }, _getTopOffset: function () { return -this.height / 2 }, _renderTextCommon: function (t, e) { t.save(); for (var i = 0, n = this._getLeftOffset(), r = this._getTopOffset(), s = 0, a = this._textLines.length; a > s; s++) { var o = this.getHeightOfLine(s), h = o / this.lineHeight, c = this._getLineLeftOffset(s); this._renderTextLine(e, t, this._textLines[s], n + c, r + i + h, s), i += o } t.restore() }, _renderTextFill: function (t) { (this.fill || this.styleHas("fill")) && this._renderTextCommon(t, "fillText") }, _renderTextStroke: function (t) { (this.stroke && 0 !== this.strokeWidth || !this.isEmptyStyles()) && (this.shadow && !this.shadow.affectStroke && this._removeShadow(t), t.save(), this._setLineDash(t, this.strokeDashArray), t.beginPath(), this._renderTextCommon(t, "strokeText"), t.closePath(), t.restore()) }, _renderChars: function (t, i, n, r, s, a) { var o, h, c, l, f, u = this.getHeightOfLine(a), d = -1 !== this.textAlign.indexOf("justify"), p = "", g = 0, v = this.path, y = !d && 0 === this.charSpacing && this.isEmptyStyles(a) && !v, _ = "ltr" === this.direction, m = "ltr" === this.direction ? 1 : -1, x = i.canvas.getAttribute("dir"); if (i.save(), x !== this.direction && (i.canvas.setAttribute("dir", _ ? "ltr" : "rtl"), i.direction = _ ? "ltr" : "rtl", i.textAlign = _ ? "left" : "right"), s -= u * this._fontSizeFraction / this.lineHeight, y) return this._renderChar(t, i, a, 0, n.join(""), r, s, u), void i.restore(); for (var b = 0, S = n.length - 1; S >= b; b++)l = b === S || this.charSpacing || v, p += n[b], c = this.__charBounds[a][b], 0 === g ? (r += m * (c.kernedWidth - c.width), g += c.width) : g += c.kernedWidth, d && !l && this._reSpaceAndTab.test(n[b]) && (l = !0), l || (o = o || this.getCompleteStyleDeclaration(a, b), h = this.getCompleteStyleDeclaration(a, b + 1), l = e.util.hasStyleChanged(o, h, !1)), l && (v ? (i.save(), i.translate(c.renderLeft, c.renderTop), i.rotate(c.angle), this._renderChar(t, i, a, b, p, -g / 2, 0, u), i.restore()) : (f = r, this._renderChar(t, i, a, b, p, f, s, u)), p = "", o = h, r += m * g, g = 0); i.restore() }, _applyPatternGradientTransformText: function (t) { var i, n = e.util.createCanvasElement(), r = this.width + this.strokeWidth, s = this.height + this.strokeWidth; return n.width = r, n.height = s, i = n.getContext("2d"), i.beginPath(), i.moveTo(0, 0), i.lineTo(r, 0), i.lineTo(r, s), i.lineTo(0, s), i.closePath(), i.translate(r / 2, s / 2), i.fillStyle = t.toLive(i), this._applyPatternGradientTransform(i, t), i.fill(), i.createPattern(n, "no-repeat") }, handleFiller: function (t, e, i) { var n, r; return i.toLive ? "percentage" === i.gradientUnits || i.gradientTransform || i.patternTransform ? (n = -this.width / 2, r = -this.height / 2, t.translate(n, r), t[e] = this._applyPatternGradientTransformText(i), { offsetX: n, offsetY: r }) : (t[e] = i.toLive(t, this), this._applyPatternGradientTransform(t, i)) : (t[e] = i, { offsetX: 0, offsetY: 0 }) }, _setStrokeStyles: function (t, e) { return t.lineWidth = e.strokeWidth, t.lineCap = this.strokeLineCap, t.lineDashOffset = this.strokeDashOffset, t.lineJoin = this.strokeLineJoin, t.miterLimit = this.strokeMiterLimit, this.handleFiller(t, "strokeStyle", e.stroke) }, _setFillStyles: function (t, e) { return this.handleFiller(t, "fillStyle", e.fill) }, _renderChar: function (t, e, i, n, r, s, a) { var o, h, c = this._getStyleDeclaration(i, n), l = this.getCompleteStyleDeclaration(i, n), f = "fillText" === t && l.fill, u = "strokeText" === t && l.stroke && l.strokeWidth; (u || f) && (e.save(), f && (o = this._setFillStyles(e, l)), u && (h = this._setStrokeStyles(e, l)), e.font = this._getFontDeclaration(l), c && c.textBackgroundColor && this._removeShadow(e), c && c.deltaY && (a += c.deltaY), f && e.fillText(r, s - o.offsetX, a - o.offsetY), u && e.strokeText(r, s - h.offsetX, a - h.offsetY), e.restore()) }, setSuperscript: function (t, e) { return this._setScript(t, e, this.superscript) }, setSubscript: function (t, e) { return this._setScript(t, e, this.subscript) }, _setScript: function (t, e, i) { var n = this.get2DCursorLocation(t, !0), r = this.getValueOfPropertyAt(n.lineIndex, n.charIndex, "fontSize"), s = this.getValueOfPropertyAt(n.lineIndex, n.charIndex, "deltaY"), a = { fontSize: r * i.size, deltaY: s + r * i.baseline }; return this.setSelectionStyles(a, t, e), this }, _getLineLeftOffset: function (t) { var e, i = this.getLineWidth(t), n = this.width - i, r = this.textAlign, s = this.direction, a = 0, e = this.isEndOfWrapping(t); return "justify" === r || "justify-center" === r && !e || "justify-right" === r && !e || "justify-left" === r && !e ? 0 : ("center" === r && (a = n / 2), "right" === r && (a = n), "justify-center" === r && (a = n / 2), "justify-right" === r && (a = n), "rtl" === s && (a -= n), a) }, _clearCache: function () { this.__lineWidths = [], this.__lineHeights = [], this.__charBounds = [] }, _shouldClearDimensionCache: function () { var t = this._forceClearCache; return t || (t = this.hasStateChanged("_dimensionAffectingProps")), t && (this.dirty = !0, this._forceClearCache = !1), t }, getLineWidth: function (t) { if (void 0 !== this.__lineWidths[t]) return this.__lineWidths[t]; var e = this.measureLine(t), i = e.width; return this.__lineWidths[t] = i, i }, _getWidthOfCharSpacing: function () { return 0 !== this.charSpacing ? this.fontSize * this.charSpacing / 1e3 : 0 }, getValueOfPropertyAt: function (t, e, i) { var n = this._getStyleDeclaration(t, e); return n && "undefined" != typeof n[i] ? n[i] : this[i] }, _renderTextDecoration: function (t, e) { if (this[e] || this.styleHas(e)) { for (var i, n, r, s, a, o, h, c, l, f, u, d, p, g, v, y, _ = this._getLeftOffset(), m = this._getTopOffset(), x = this.path, b = this._getWidthOfCharSpacing(), S = this.offsets[e], C = 0, T = this._textLines.length; T > C; C++)if (i = this.getHeightOfLine(C), this[e] || this.styleHas(e, C)) { h = this._textLines[C], g = i / this.lineHeight, s = this._getLineLeftOffset(C), f = 0, u = 0, c = this.getValueOfPropertyAt(C, 0, e), y = this.getValueOfPropertyAt(C, 0, "fill"), l = m + g * (1 - this._fontSizeFraction), n = this.getHeightOfChar(C, 0), a = this.getValueOfPropertyAt(C, 0, "deltaY"); for (var O = 0, w = h.length; w > O; O++)if (d = this.__charBounds[C][O], p = this.getValueOfPropertyAt(C, O, e), v = this.getValueOfPropertyAt(C, O, "fill"), r = this.getHeightOfChar(C, O), o = this.getValueOfPropertyAt(C, O, "deltaY"), x && p && v) t.save(), t.fillStyle = y, t.translate(d.renderLeft, d.renderTop), t.rotate(d.angle), t.fillRect(-d.kernedWidth / 2, S * r + o, d.kernedWidth, this.fontSize / 15), t.restore(); else if ((p !== c || v !== y || r !== n || o !== a) && u > 0) { var k = _ + s + f; "rtl" === this.direction && (k = this.width - k - u), c && y && (t.fillStyle = y, t.fillRect(k, l + S * n + a, u, this.fontSize / 15)), f = d.left, u = d.width, c = p, y = v, n = r, a = o } else u += d.kernedWidth; var k = _ + s + f; "rtl" === this.direction && (k = this.width - k - u), t.fillStyle = v, p && v && t.fillRect(k, l + S * n + a, u - b, this.fontSize / 15), m += i } else m += i; this._removeShadow(t) } }, _getFontDeclaration: function (t, i) { var n = t || this, r = this.fontFamily, s = e.Text.genericFonts.indexOf(r.toLowerCase()) > -1, a = void 0 === r || r.indexOf("'") > -1 || r.indexOf(",") > -1 || r.indexOf('"') > -1 || s ? n.fontFamily : '"' + n.fontFamily + '"'; return [e.isLikelyNode ? n.fontWeight : n.fontStyle, e.isLikelyNode ? n.fontStyle : n.fontWeight, i ? this.CACHE_FONT_SIZE + "px" : n.fontSize + "px", a].join(" ") }, render: function (t) { this.visible && (!this.canvas || !this.canvas.skipOffscreen || this.group || this.isOnScreen()) && (this._shouldClearDimensionCache() && this.initDimensions(), this.callSuper("render", t)) }, _splitTextIntoLines: function (t) { for (var i = t.split(this._reNewline), n = new Array(i.length), r = ["\n"], s = [], a = 0; a < i.length; a++)n[a] = e.util.string.graphemeSplit(i[a]), s = s.concat(n[a], r); return s.pop(), { _unwrappedLines: n, lines: i, graphemeText: s, graphemeLines: n } }, toObject: function (t) { var i = n.concat(t), r = this.callSuper("toObject", i); return r.styles = e.util.stylesToArray(this.styles, this.text), r.path && (r.path = this.path.toObject()), r }, set: function (t, e) { this.callSuper("set", t, e); var i = !1, n = !1; if ("object" == typeof t) for (var r in t) "path" === r && this.setPathInfo(), i = i || -1 !== this._dimensionAffectingProps.indexOf(r), n = n || "path" === r; else i = -1 !== this._dimensionAffectingProps.indexOf(t), n = "path" === t; return n && this.setPathInfo(), i && (this.initDimensions(), this.setCoords()), this }, complexity: function () { return 1 } }), e.Text.ATTRIBUTE_NAMES = e.SHARED_ATTRIBUTES.concat("x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")), e.Text.DEFAULT_SVG_FONT_SIZE = 16, e.Text.fromElement = function (t, n, r) { if (!t) return n(null); var s = e.parseAttributes(t, e.Text.ATTRIBUTE_NAMES), a = s.textAnchor || "left"; if (r = e.util.object.extend(r ? i(r) : {}, s), r.top = r.top || 0, r.left = r.left || 0, s.textDecoration) { var o = s.textDecoration; -1 !== o.indexOf("underline") && (r.underline = !0), -1 !== o.indexOf("overline") && (r.overline = !0), -1 !== o.indexOf("line-through") && (r.linethrough = !0), delete r.textDecoration } "dx" in s && (r.left += s.dx), "dy" in s && (r.top += s.dy), "fontSize" in r || (r.fontSize = e.Text.DEFAULT_SVG_FONT_SIZE); var h = ""; "textContent" in t ? h = t.textContent : "firstChild" in t && null !== t.firstChild && "data" in t.firstChild && null !== t.firstChild.data && (h = t.firstChild.data), h = h.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " "); var c = r.strokeWidth; r.strokeWidth = 0; var l = new e.Text(h, r), f = l.getScaledHeight() / l.height, u = (l.height + l.strokeWidth) * l.lineHeight - l.height, d = u * f, p = l.getScaledHeight() + d, g = 0; "center" === a && (g = l.getScaledWidth() / 2), "right" === a && (g = l.getScaledWidth()), l.set({ left: l.left - g, top: l.top - (p - l.fontSize * (.07 + l._fontSizeFraction)) / l.lineHeight, strokeWidth: "undefined" != typeof c ? c : 1 }), n(l) }, e.Text.fromObject = function (t, n) { var r = i(t), s = t.path; return delete r.path, e.Object._fromObject("Text", r, function (i) { i.styles = e.util.stylesFromArray(t.styles, t.text), s ? e.Object._fromObject("Path", s, function (t) { i.set("path", t), n(i) }, "path") : n(i) }, "text") }, e.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"], e.util.createAccessors && e.util.createAccessors(e.Text) }("undefined" != typeof exports ? exports : this); !function () { fabric.util.object.extend(fabric.Text.prototype, { isEmptyStyles: function (t) { if (!this.styles) return !0; if ("undefined" != typeof t && !this.styles[t]) return !0; var e = "undefined" == typeof t ? this.styles : { line: this.styles[t] }; for (var i in e) for (var r in e[i]) for (var n in e[i][r]) return !1; return !0 }, styleHas: function (t, e) { if (!this.styles || !t || "" === t) return !1; if ("undefined" != typeof e && !this.styles[e]) return !1; var i = "undefined" == typeof e ? this.styles : { 0: this.styles[e] }; for (var r in i) for (var n in i[r]) if ("undefined" != typeof i[r][n][t]) return !0; return !1 }, cleanStyle: function (t) { if (!this.styles || !t || "" === t) return !1; var e, i, r, n = this.styles, s = 0, a = !0, o = 0; for (var c in n) { e = 0; for (var h in n[c]) { var r = n[c][h], l = r.hasOwnProperty(t); s++, l ? (i ? r[t] !== i && (a = !1) : i = r[t], r[t] === this[t] && delete r[t]) : a = !1, 0 !== Object.keys(r).length ? e++ : delete n[c][h] } 0 === e && delete n[c] } for (var u = 0; u < this._textLines.length; u++)o += this._textLines[u].length; a && s === o && (this[t] = i, this.removeStyle(t)) }, removeStyle: function (t) { if (this.styles && t && "" !== t) { var e, i, r, n = this.styles; for (i in n) { e = n[i]; for (r in e) delete e[r][t], 0 === Object.keys(e[r]).length && delete e[r]; 0 === Object.keys(e).length && delete n[i] } } }, _extendStyles: function (t, e) { var i = this.get2DCursorLocation(t); this._getLineStyle(i.lineIndex) || this._setLineStyle(i.lineIndex), this._getStyleDeclaration(i.lineIndex, i.charIndex) || this._setStyleDeclaration(i.lineIndex, i.charIndex, {}), fabric.util.object.extend(this._getStyleDeclaration(i.lineIndex, i.charIndex), e) }, get2DCursorLocation: function (t, e) { "undefined" == typeof t && (t = this.selectionStart); for (var i = e ? this._unwrappedTextLines : this._textLines, r = i.length, n = 0; r > n; n++) { if (t <= i[n].length) return { lineIndex: n, charIndex: t }; t -= i[n].length + this.missingNewlineOffset(n) } return { lineIndex: n - 1, charIndex: i[n - 1].length < t ? i[n - 1].length : t } }, getSelectionStyles: function (t, e, i) { "undefined" == typeof t && (t = this.selectionStart || 0), "undefined" == typeof e && (e = this.selectionEnd || t); for (var r = [], n = t; e > n; n++)r.push(this.getStyleAtPosition(n, i)); return r }, getStyleAtPosition: function (t, e) { var i = this.get2DCursorLocation(t), r = e ? this.getCompleteStyleDeclaration(i.lineIndex, i.charIndex) : this._getStyleDeclaration(i.lineIndex, i.charIndex); return r || {} }, setSelectionStyles: function (t, e, i) { "undefined" == typeof e && (e = this.selectionStart || 0), "undefined" == typeof i && (i = this.selectionEnd || e); for (var r = e; i > r; r++)this._extendStyles(r, t); return this._forceClearCache = !0, this }, _getStyleDeclaration: function (t, e) { var i = this.styles && this.styles[t]; return i ? i[e] : null }, getCompleteStyleDeclaration: function (t, e) { for (var i, r = this._getStyleDeclaration(t, e) || {}, n = {}, s = 0; s < this._styleProperties.length; s++)i = this._styleProperties[s], n[i] = "undefined" == typeof r[i] ? this[i] : r[i]; return n }, _setStyleDeclaration: function (t, e, i) { this.styles[t][e] = i }, _deleteStyleDeclaration: function (t, e) { delete this.styles[t][e] }, _getLineStyle: function (t) { return !!this.styles[t] }, _setLineStyle: function (t) { this.styles[t] = {} }, _deleteLineStyle: function (t) { delete this.styles[t] } }) }(); !function () { function t(t) { t.textDecoration && (t.textDecoration.indexOf("underline") > -1 && (t.underline = !0), t.textDecoration.indexOf("line-through") > -1 && (t.linethrough = !0), t.textDecoration.indexOf("overline") > -1 && (t.overline = !0), delete t.textDecoration) } fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, { type: "i-text", selectionStart: 0, selectionEnd: 0, selectionColor: "rgba(17,119,255,0.3)", isEditing: !1, editable: !0, editingBorderColor: "rgba(102,153,255,0.25)", cursorWidth: 2, cursorColor: "", cursorDelay: 1e3, cursorDuration: 600, caching: !0, hiddenTextareaContainer: null, _reSpace: /\s|\n/, _currentCursorOpacity: 0, _selectionDirection: null, _abortCursorAnimation: !1, __widthOfSpace: [], inCompositionMode: !1, initialize: function (t, e) { this.callSuper("initialize", t, e), this.initBehavior() }, setSelectionStart: function (t) { t = Math.max(t, 0), this._updateAndFire("selectionStart", t) }, setSelectionEnd: function (t) { t = Math.min(t, this.text.length), this._updateAndFire("selectionEnd", t) }, _updateAndFire: function (t, e) { this[t] !== e && (this._fireSelectionChanged(), this[t] = e), this._updateTextarea() }, _fireSelectionChanged: function () { this.fire("selection:changed"), this.canvas && this.canvas.fire("text:selection:changed", { target: this }) }, initDimensions: function () { this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this.callSuper("initDimensions") }, render: function (t) { this.clearContextTop(), this.callSuper("render", t), this.cursorOffsetCache = {}, this.renderCursorOrSelection() }, _render: function (t) { this.callSuper("_render", t) }, clearContextTop: function (t) { if (this.isEditing && this.canvas && this.canvas.contextTop) { var e = this.canvas.contextTop, i = this.canvas.viewportTransform; e.save(), e.transform(i[0], i[1], i[2], i[3], i[4], i[5]), this.transform(e), this._clearTextArea(e), t || e.restore() } }, renderCursorOrSelection: function () { if (this.isEditing && this.canvas && this.canvas.contextTop) { var t = this._getCursorBoundaries(), e = this.canvas.contextTop; this.clearContextTop(!0), this.selectionStart === this.selectionEnd ? this.renderCursor(t, e) : this.renderSelection(t, e), e.restore() } }, _clearTextArea: function (t) { var e = this.width + 4, i = this.height + 4; t.clearRect(-e / 2, -i / 2, e, i) }, _getCursorBoundaries: function (t) { "undefined" == typeof t && (t = this.selectionStart); var e = this._getLeftOffset(), i = this._getTopOffset(), r = this._getCursorBoundariesOffsets(t); return { left: e, top: i, leftOffset: r.left, topOffset: r.top } }, _getCursorBoundariesOffsets: function (t) { if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) return this.cursorOffsetCache; var e, i, r, n, s = 0, a = 0, o = this.get2DCursorLocation(t); r = o.charIndex, i = o.lineIndex; for (var c = 0; i > c; c++)s += this.getHeightOfLine(c); e = this._getLineLeftOffset(i); var h = this.__charBounds[i][r]; return h && (a = h.left), 0 !== this.charSpacing && r === this._textLines[i].length && (a -= this._getWidthOfCharSpacing()), n = { top: s, left: e + (a > 0 ? a : 0) }, "rtl" === this.direction && (n.left *= -1), this.cursorOffsetCache = n, this.cursorOffsetCache }, renderCursor: function (t, e) { var i = this.get2DCursorLocation(), r = i.lineIndex, n = i.charIndex > 0 ? i.charIndex - 1 : 0, s = this.getValueOfPropertyAt(r, n, "fontSize"), a = this.scaleX * this.canvas.getZoom(), o = this.cursorWidth / a, c = t.topOffset, h = this.getValueOfPropertyAt(r, n, "deltaY"); c += (1 - this._fontSizeFraction) * this.getHeightOfLine(r) / this.lineHeight - s * (1 - this._fontSizeFraction), this.inCompositionMode && this.renderSelection(t, e), e.fillStyle = this.cursorColor || this.getValueOfPropertyAt(r, n, "fill"), e.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity, e.fillRect(t.left + t.leftOffset - o / 2, c + t.top + h, o, s) }, renderSelection: function (t, e) { for (var i = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, r = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, n = -1 !== this.textAlign.indexOf("justify"), s = this.get2DCursorLocation(i), a = this.get2DCursorLocation(r), o = s.lineIndex, c = a.lineIndex, h = s.charIndex < 0 ? 0 : s.charIndex, l = a.charIndex < 0 ? 0 : a.charIndex, u = o; c >= u; u++) { var f = this._getLineLeftOffset(u) || 0, d = this.getHeightOfLine(u), p = 0, v = 0, g = 0; if (u === o && (v = this.__charBounds[o][h].left), u >= o && c > u) g = n && !this.isEndOfWrapping(u) ? this.width : this.getLineWidth(u) || 5; else if (u === c) if (0 === l) g = this.__charBounds[c][l].left; else { var b = this._getWidthOfCharSpacing(); g = this.__charBounds[c][l - 1].left + this.__charBounds[c][l - 1].width - b } p = d, (this.lineHeight < 1 || u === c && this.lineHeight > 1) && (d /= this.lineHeight); var m = t.left + f + v, y = g - v, _ = d, x = 0; this.inCompositionMode ? (e.fillStyle = this.compositionColor || "black", _ = 1, x = d) : e.fillStyle = this.selectionColor, "rtl" === this.direction && (m = this.width - m - y), e.fillRect(m, t.top + t.topOffset + x, y, _), t.topOffset += p } }, getCurrentCharFontSize: function () { var t = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(t.l, t.c, "fontSize") }, getCurrentCharColor: function () { var t = this._getCurrentCharIndex(); return this.getValueOfPropertyAt(t.l, t.c, "fill") }, _getCurrentCharIndex: function () { var t = this.get2DCursorLocation(this.selectionStart, !0), e = t.charIndex > 0 ? t.charIndex - 1 : 0; return { l: t.lineIndex, c: e } } }), fabric.IText.fromObject = function (e, i) { if (e.styles = fabric.util.stylesFromArray(e.styles, e.text), t(e), e.styles) for (var r in e.styles) for (var n in e.styles[r]) t(e.styles[r][n]); fabric.Object._fromObject("IText", e, i, "text") } }(); !function () { var t = fabric.util.object.clone; fabric.util.object.extend(fabric.IText.prototype, { initBehavior: function () { this.initAddedHandler(), this.initRemovedHandler(), this.initCursorSelectionHandlers(), this.initDoubleClickSimulation(), this.mouseMoveHandler = this.mouseMoveHandler.bind(this) }, onDeselect: function () { this.isEditing && this.exitEditing(), this.selected = !1 }, initAddedHandler: function () { var t = this; this.on("added", function () { var e = t.canvas; e && (e._hasITextHandlers || (e._hasITextHandlers = !0, t._initCanvasHandlers(e)), e._iTextInstances = e._iTextInstances || [], e._iTextInstances.push(t)) }) }, initRemovedHandler: function () { var t = this; this.on("removed", function () { var e = t.canvas; e && (e._iTextInstances = e._iTextInstances || [], fabric.util.removeFromArray(e._iTextInstances, t), 0 === e._iTextInstances.length && (e._hasITextHandlers = !1, t._removeCanvasHandlers(e))) }) }, _initCanvasHandlers: function (t) { t._mouseUpITextHandler = function () { t._iTextInstances && t._iTextInstances.forEach(function (t) { t.__isMousedown = !1 }) }, t.on("mouse:up", t._mouseUpITextHandler) }, _removeCanvasHandlers: function (t) { t.off("mouse:up", t._mouseUpITextHandler) }, _tick: function () { this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete") }, _animateCursor: function (t, e, i, r) { var n; return n = { isAborted: !1, abort: function () { this.isAborted = !0 } }, t.animate("_currentCursorOpacity", e, { duration: i, onComplete: function () { n.isAborted || t[r]() }, onChange: function () { t.canvas && t.selectionStart === t.selectionEnd && t.renderCursorOrSelection() }, abort: function () { return n.isAborted } }), n }, _onTickComplete: function () { var t = this; this._cursorTimeout1 && clearTimeout(this._cursorTimeout1), this._cursorTimeout1 = setTimeout(function () { t._currentTickCompleteState = t._animateCursor(t, 0, this.cursorDuration / 2, "_tick") }, 100) }, initDelayedCursor: function (t) { var e = this, i = t ? 0 : this.cursorDelay; this.abortCursorAnimation(), this._currentCursorOpacity = 1, this._cursorTimeout2 = setTimeout(function () { e._tick() }, i) }, abortCursorAnimation: function () { var t = this._currentTickState || this._currentTickCompleteState, e = this.canvas; this._currentTickState && this._currentTickState.abort(), this._currentTickCompleteState && this._currentTickCompleteState.abort(), clearTimeout(this._cursorTimeout1), clearTimeout(this._cursorTimeout2), this._currentCursorOpacity = 0, t && e && e.clearContext(e.contextTop || e.contextContainer) }, selectAll: function () { return this.selectionStart = 0, this.selectionEnd = this._text.length, this._fireSelectionChanged(), this._updateTextarea(), this }, getSelectedText: function () { return this._text.slice(this.selectionStart, this.selectionEnd).join("") }, findWordBoundaryLeft: function (t) { var e = 0, i = t - 1; if (this._reSpace.test(this._text[i])) for (; this._reSpace.test(this._text[i]);)e++, i--; for (; /\S/.test(this._text[i]) && i > -1;)e++, i--; return t - e }, findWordBoundaryRight: function (t) { var e = 0, i = t; if (this._reSpace.test(this._text[i])) for (; this._reSpace.test(this._text[i]);)e++, i++; for (; /\S/.test(this._text[i]) && i < this._text.length;)e++, i++; return t + e }, findLineBoundaryLeft: function (t) { for (var e = 0, i = t - 1; !/\n/.test(this._text[i]) && i > -1;)e++, i--; return t - e }, findLineBoundaryRight: function (t) { for (var e = 0, i = t; !/\n/.test(this._text[i]) && i < this._text.length;)e++, i++; return t + e }, searchWordBoundary: function (t, e) { for (var i = this._text, r = this._reSpace.test(i[t]) ? t - 1 : t, n = i[r], s = fabric.reNonWord; !s.test(n) && r > 0 && r < i.length;)r += e, n = i[r]; return s.test(n) && (r += 1 === e ? 0 : 1), r }, selectWord: function (t) { t = t || this.selectionStart; var e = this.searchWordBoundary(t, -1), i = this.searchWordBoundary(t, 1); this.selectionStart = e, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection() }, selectLine: function (t) { t = t || this.selectionStart; var e = this.findLineBoundaryLeft(t), i = this.findLineBoundaryRight(t); return this.selectionStart = e, this.selectionEnd = i, this._fireSelectionChanged(), this._updateTextarea(), this }, enterEditing: function (t) { return !this.isEditing && this.editable ? (this.canvas && (this.canvas.calcOffset(), this.exitEditingOnOthers(this.canvas)), this.isEditing = !0, this.initHiddenTextarea(t), this.hiddenTextarea.focus(), this.hiddenTextarea.value = this.text, this._updateTextarea(), this._saveEditingProps(), this._setEditingProps(), this._textBeforeEdit = this.text, this._tick(), this.fire("editing:entered"), this._fireSelectionChanged(), this.canvas ? (this.canvas.fire("text:editing:entered", { target: this }), this.initMouseMoveHandler(), this.canvas.requestRenderAll(), this) : this) : void 0 }, exitEditingOnOthers: function (t) { t._iTextInstances && t._iTextInstances.forEach(function (t) { t.selected = !1, t.isEditing && t.exitEditing() }) }, initMouseMoveHandler: function () { this.canvas.on("mouse:move", this.mouseMoveHandler) }, mouseMoveHandler: function (t) { if (this.__isMousedown && this.isEditing) { var e = this.getSelectionStartFromPointer(t.e), i = this.selectionStart, r = this.selectionEnd; (e === this.__selectionStartOnMouseDown && i !== r || i !== e && r !== e) && (e > this.__selectionStartOnMouseDown ? (this.selectionStart = this.__selectionStartOnMouseDown, this.selectionEnd = e) : (this.selectionStart = e, this.selectionEnd = this.__selectionStartOnMouseDown), (this.selectionStart !== i || this.selectionEnd !== r) && (this.restartCursorIfNeeded(), this._fireSelectionChanged(), this._updateTextarea(), this.renderCursorOrSelection())) } }, _setEditingProps: function () { this.hoverCursor = "text", this.canvas && (this.canvas.defaultCursor = this.canvas.moveCursor = "text"), this.borderColor = this.editingBorderColor, this.hasControls = this.selectable = !1, this.lockMovementX = this.lockMovementY = !0 }, fromStringToGraphemeSelection: function (t, e, i) { var r = i.slice(0, t), n = fabric.util.string.graphemeSplit(r).length; if (t === e) return { selectionStart: n, selectionEnd: n }; var s = i.slice(t, e), a = fabric.util.string.graphemeSplit(s).length; return { selectionStart: n, selectionEnd: n + a } }, fromGraphemeToStringSelection: function (t, e, i) { var r = i.slice(0, t), n = r.join("").length; if (t === e) return { selectionStart: n, selectionEnd: n }; var s = i.slice(t, e), a = s.join("").length; return { selectionStart: n, selectionEnd: n + a } }, _updateTextarea: function () { if (this.cursorOffsetCache = {}, this.hiddenTextarea) { if (!this.inCompositionMode) { var t = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text); this.hiddenTextarea.selectionStart = t.selectionStart, this.hiddenTextarea.selectionEnd = t.selectionEnd } this.updateTextareaPosition() } }, updateFromTextArea: function () { if (this.hiddenTextarea) { this.cursorOffsetCache = {}, this.text = this.hiddenTextarea.value, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()); var t = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value); this.selectionEnd = this.selectionStart = t.selectionEnd, this.inCompositionMode || (this.selectionStart = t.selectionStart), this.updateTextareaPosition() } }, updateTextareaPosition: function () { if (this.selectionStart === this.selectionEnd) { var t = this._calcTextareaPosition(); this.hiddenTextarea.style.left = t.left, this.hiddenTextarea.style.top = t.top } }, _calcTextareaPosition: function () { if (!this.canvas) return { x: 1, y: 1 }; var t = this.inCompositionMode ? this.compositionStart : this.selectionStart, e = this._getCursorBoundaries(t), i = this.get2DCursorLocation(t), r = i.lineIndex, n = i.charIndex, s = this.getValueOfPropertyAt(r, n, "fontSize") * this.lineHeight, a = e.leftOffset, o = this.calcTransformMatrix(), c = { x: e.left + a, y: e.top + e.topOffset + s }, h = this.canvas.getRetinaScaling(), l = this.canvas.upperCanvasEl, f = l.width / h, u = l.height / h, d = f - s, p = u - s, v = l.clientWidth / f, g = l.clientHeight / u; return c = fabric.util.transformPoint(c, o), c = fabric.util.transformPoint(c, this.canvas.viewportTransform), c.x *= v, c.y *= g, c.x < 0 && (c.x = 0), c.x > d && (c.x = d), c.y < 0 && (c.y = 0), c.y > p && (c.y = p), c.x += this.canvas._offset.left, c.y += this.canvas._offset.top, { left: c.x + "px", top: c.y + "px", fontSize: s + "px", charHeight: s } }, _saveEditingProps: function () { this._savedProps = { hasControls: this.hasControls, borderColor: this.borderColor, lockMovementX: this.lockMovementX, lockMovementY: this.lockMovementY, hoverCursor: this.hoverCursor, selectable: this.selectable, defaultCursor: this.canvas && this.canvas.defaultCursor, moveCursor: this.canvas && this.canvas.moveCursor } }, _restoreEditingProps: function () { this._savedProps && (this.hoverCursor = this._savedProps.hoverCursor, this.hasControls = this._savedProps.hasControls, this.borderColor = this._savedProps.borderColor, this.selectable = this._savedProps.selectable, this.lockMovementX = this._savedProps.lockMovementX, this.lockMovementY = this._savedProps.lockMovementY, this.canvas && (this.canvas.defaultCursor = this._savedProps.defaultCursor, this.canvas.moveCursor = this._savedProps.moveCursor)) }, exitEditing: function () { var t = this._textBeforeEdit !== this.text, e = this.hiddenTextarea; return this.selected = !1, this.isEditing = !1, this.selectionEnd = this.selectionStart, e && (e.blur && e.blur(), e.parentNode && e.parentNode.removeChild(e)), this.hiddenTextarea = null, this.abortCursorAnimation(), this._restoreEditingProps(), this._currentCursorOpacity = 0, this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this.fire("editing:exited"), t && this.fire("modified"), this.canvas && (this.canvas.off("mouse:move", this.mouseMoveHandler), this.canvas.fire("text:editing:exited", { target: this }), t && this.canvas.fire("object:modified", { target: this })), this }, _removeExtraneousStyles: function () { for (var t in this.styles) this._textLines[t] || delete this.styles[t] }, removeStyleFromTo: function (t, e) { var i, r, n = this.get2DCursorLocation(t, !0), s = this.get2DCursorLocation(e, !0), a = n.lineIndex, o = n.charIndex, c = s.lineIndex, h = s.charIndex; if (a !== c) { if (this.styles[a]) for (i = o; i < this._unwrappedTextLines[a].length; i++)delete this.styles[a][i]; if (this.styles[c]) for (i = h; i < this._unwrappedTextLines[c].length; i++)r = this.styles[c][i], r && (this.styles[a] || (this.styles[a] = {}), this.styles[a][o + i - h] = r); for (i = a + 1; c >= i; i++)delete this.styles[i]; this.shiftLineStyles(c, a - c) } else if (this.styles[a]) { r = this.styles[a]; var l, f, u = h - o; for (i = o; h > i; i++)delete r[i]; for (f in this.styles[a]) l = parseInt(f, 10), l >= h && (r[l - u] = r[f], delete r[f]) } }, shiftLineStyles: function (e, i) { var r = t(this.styles); for (var n in this.styles) { var s = parseInt(n, 10); s > e && (this.styles[s + i] = r[s], r[s - i] || delete this.styles[s]) } }, restartCursorIfNeeded: function () { (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) && this.initDelayedCursor() }, insertNewlineStyleObject: function (e, i, r, n) { var s, a = {}, o = !1, c = this._unwrappedTextLines[e].length === i; r || (r = 1), this.shiftLineStyles(e, r), this.styles[e] && (s = this.styles[e][0 === i ? i : i - 1]); for (var h in this.styles[e]) { var l = parseInt(h, 10); l >= i && (o = !0, a[l - i] = this.styles[e][h], c && 0 === i || delete this.styles[e][h]) } var f = !1; for (o && !c && (this.styles[e + r] = a, f = !0), f && r--; r > 0;)n && n[r - 1] ? this.styles[e + r] = { 0: t(n[r - 1]) } : s ? this.styles[e + r] = { 0: t(s) } : delete this.styles[e + r], r--; this._forceClearCache = !0 }, insertCharStyleObject: function (e, i, r, n) { this.styles || (this.styles = {}); var s = this.styles[e], a = s ? t(s) : {}; r || (r = 1); for (var o in a) { var c = parseInt(o, 10); c >= i && (s[c + r] = a[c], a[c - r] || delete s[c]) } if (this._forceClearCache = !0, n) for (; r--;)Object.keys(n[r]).length && (this.styles[e] || (this.styles[e] = {}), this.styles[e][i + r] = t(n[r])); else if (s) for (var h = s[i ? i - 1 : 1]; h && r--;)this.styles[e][i + r] = t(h) }, insertNewStyleBlock: function (t, e, i) { for (var r = this.get2DCursorLocation(e, !0), n = [0], s = 0, a = 0; a < t.length; a++)"\n" === t[a] ? (s++, n[s] = 0) : n[s]++; n[0] > 0 && (this.insertCharStyleObject(r.lineIndex, r.charIndex, n[0], i), i = i && i.slice(n[0] + 1)), s && this.insertNewlineStyleObject(r.lineIndex, r.charIndex + n[0], s); for (var a = 1; s > a; a++)n[a] > 0 ? this.insertCharStyleObject(r.lineIndex + a, 0, n[a], i) : i && this.styles[r.lineIndex + a] && i[0] && (this.styles[r.lineIndex + a][0] = i[0]), i = i && i.slice(n[a] + 1); n[a] > 0 && this.insertCharStyleObject(r.lineIndex + a, 0, n[a], i) }, setSelectionStartEndWithShift: function (t, e, i) { t >= i ? (e === t ? this._selectionDirection = "left" : "right" === this._selectionDirection && (this._selectionDirection = "left", this.selectionEnd = t), this.selectionStart = i) : i > t && e > i ? "right" === this._selectionDirection ? this.selectionEnd = i : this.selectionStart = i : (e === t ? this._selectionDirection = "right" : "left" === this._selectionDirection && (this._selectionDirection = "right", this.selectionStart = e), this.selectionEnd = i) }, setSelectionInBoundaries: function () { var t = this.text.length; this.selectionStart > t ? this.selectionStart = t : this.selectionStart < 0 && (this.selectionStart = 0), this.selectionEnd > t ? this.selectionEnd = t : this.selectionEnd < 0 && (this.selectionEnd = 0) } }) }(); fabric.util.object.extend(fabric.IText.prototype, { initDoubleClickSimulation: function () { this.__lastClickTime = +new Date, this.__lastLastClickTime = +new Date, this.__lastPointer = {}, this.on("mousedown", this.onMouseDown) }, onMouseDown: function (t) { if (this.canvas) { this.__newClickTime = +new Date; var e = t.pointer; this.isTripleClick(e) && (this.fire("tripleclick", t), this._stopEvent(t.e)), this.__lastLastClickTime = this.__lastClickTime, this.__lastClickTime = this.__newClickTime, this.__lastPointer = e, this.__lastIsEditing = this.isEditing, this.__lastSelected = this.selected } }, isTripleClick: function (t) { return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === t.x && this.__lastPointer.y === t.y }, _stopEvent: function (t) { t.preventDefault && t.preventDefault(), t.stopPropagation && t.stopPropagation() }, initCursorSelectionHandlers: function () { this.initMousedownHandler(), this.initMouseupHandler(), this.initClicks() }, doubleClickHandler: function (t) { this.isEditing && this.selectWord(this.getSelectionStartFromPointer(t.e)) }, tripleClickHandler: function (t) { this.isEditing && this.selectLine(this.getSelectionStartFromPointer(t.e)) }, initClicks: function () { this.on("mousedblclick", this.doubleClickHandler), this.on("tripleclick", this.tripleClickHandler) }, _mouseDownHandler: function (t) { !this.canvas || !this.editable || t.e.button && 1 !== t.e.button || (this.__isMousedown = !0, this.selected && (this.inCompositionMode = !1, this.setCursorByClick(t.e)), this.isEditing && (this.__selectionStartOnMouseDown = this.selectionStart, this.selectionStart === this.selectionEnd && this.abortCursorAnimation(), this.renderCursorOrSelection())) }, _mouseDownHandlerBefore: function (t) { !this.canvas || !this.editable || t.e.button && 1 !== t.e.button || (this.selected = this === this.canvas._activeObject) }, initMousedownHandler: function () { this.on("mousedown", this._mouseDownHandler), this.on("mousedown:before", this._mouseDownHandlerBefore) }, initMouseupHandler: function () { this.on("mouseup", this.mouseUpHandler) }, mouseUpHandler: function (t) { if (this.__isMousedown = !1, !(!this.editable || this.group || t.transform && t.transform.actionPerformed || t.e.button && 1 !== t.e.button)) { if (this.canvas) { var e = this.canvas._activeObject; if (e && e !== this) return } this.__lastSelected && !this.__corner ? (this.selected = !1, this.__lastSelected = !1, this.enterEditing(t.e), this.selectionStart === this.selectionEnd ? this.initDelayedCursor(!0) : this.renderCursorOrSelection()) : this.selected = !0 } }, setCursorByClick: function (t) { var e = this.getSelectionStartFromPointer(t), i = this.selectionStart, r = this.selectionEnd; t.shiftKey ? this.setSelectionStartEndWithShift(i, r, e) : (this.selectionStart = e, this.selectionEnd = e), this.isEditing && (this._fireSelectionChanged(), this._updateTextarea()) }, getSelectionStartFromPointer: function (t) { for (var e, i, r = this.getLocalPointer(t), n = 0, a = 0, s = 0, o = 0, c = 0, h = 0, l = this._textLines.length; l > h && s <= r.y; h++)s += this.getHeightOfLine(h) * this.scaleY, c = h, h > 0 && (o += this._textLines[h - 1].length + this.missingNewlineOffset(h - 1)); e = this._getLineLeftOffset(c), a = e * this.scaleX, i = this._textLines[c], "rtl" === this.direction && (r.x = this.width * this.scaleX - r.x + a); for (var f = 0, u = i.length; u > f && (n = a, a += this.__charBounds[c][f].kernedWidth * this.scaleX, a <= r.x); f++)o++; return this._getNewSelectionStartFromOffset(r, n, a, o, u) }, _getNewSelectionStartFromOffset: function (t, e, i, r, n) { var a = t.x - e, s = i - t.x, o = s > a || 0 > s ? 0 : 1, c = r + o; return this.flipX && (c = n - c), c > this._text.length && (c = this._text.length), c } }); fabric.util.object.extend(fabric.IText.prototype, { initHiddenTextarea: function () { this.hiddenTextarea = fabric.document.createElement("textarea"), this.hiddenTextarea.setAttribute("autocapitalize", "off"), this.hiddenTextarea.setAttribute("autocorrect", "off"), this.hiddenTextarea.setAttribute("autocomplete", "off"), this.hiddenTextarea.setAttribute("spellcheck", "false"), this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", ""), this.hiddenTextarea.setAttribute("wrap", "off"); var t = this._calcTextareaPosition(); this.hiddenTextarea.style.cssText = "position: absolute; top: " + t.top + "; left: " + t.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; paddingｰtop: " + t.fontSize + ";", this.hiddenTextareaContainer ? this.hiddenTextareaContainer.appendChild(this.hiddenTextarea) : fabric.document.body.appendChild(this.hiddenTextarea), fabric.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this)), fabric.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this)), fabric.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this)), fabric.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this)), fabric.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this)), fabric.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this)), fabric.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this)), fabric.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this)), fabric.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this)), !this._clickHandlerInitialized && this.canvas && (fabric.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this)), this._clickHandlerInitialized = !0) }, keysMap: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorRight", 36: "moveCursorLeft", 37: "moveCursorLeft", 38: "moveCursorUp", 39: "moveCursorRight", 40: "moveCursorDown" }, keysMapRtl: { 9: "exitEditing", 27: "exitEditing", 33: "moveCursorUp", 34: "moveCursorDown", 35: "moveCursorLeft", 36: "moveCursorRight", 37: "moveCursorRight", 38: "moveCursorUp", 39: "moveCursorLeft", 40: "moveCursorDown" }, ctrlKeysMapUp: { 67: "copy", 88: "cut" }, ctrlKeysMapDown: { 65: "selectAll" }, onClick: function () { this.hiddenTextarea && this.hiddenTextarea.focus() }, onKeyDown: function (t) { if (this.isEditing) { var e = "rtl" === this.direction ? this.keysMapRtl : this.keysMap; if (t.keyCode in e) this[e[t.keyCode]](t); else { if (!(t.keyCode in this.ctrlKeysMapDown && (t.ctrlKey || t.metaKey))) return; this[this.ctrlKeysMapDown[t.keyCode]](t) } t.stopImmediatePropagation(), t.preventDefault(), t.keyCode >= 33 && t.keyCode <= 40 ? (this.inCompositionMode = !1, this.clearContextTop(), this.renderCursorOrSelection()) : this.canvas && this.canvas.requestRenderAll() } }, onKeyUp: function (t) { return !this.isEditing || this._copyDone || this.inCompositionMode ? void (this._copyDone = !1) : void (t.keyCode in this.ctrlKeysMapUp && (t.ctrlKey || t.metaKey) && (this[this.ctrlKeysMapUp[t.keyCode]](t), t.stopImmediatePropagation(), t.preventDefault(), this.canvas && this.canvas.requestRenderAll())) }, onInput: function (t) { var e = this.fromPaste; if (this.fromPaste = !1, t && t.stopPropagation(), this.isEditing) { var i, r, s, n, a, o = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, c = this._text.length, h = o.length, l = h - c, f = this.selectionStart, d = this.selectionEnd, u = f !== d; if ("" === this.hiddenTextarea.value) return this.styles = {}, this.updateFromTextArea(), this.fire("changed"), void (this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll())); var p = this.fromStringToGraphemeSelection(this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value), b = f > p.selectionStart; u ? (i = this._text.slice(f, d), l += d - f) : c > h && (i = b ? this._text.slice(d + l, d) : this._text.slice(f, f - l)), r = o.slice(p.selectionEnd - l, p.selectionEnd), i && i.length && (r.length && (s = this.getSelectionStyles(f, f + 1, !1), s = r.map(function () { return s[0] })), u ? (n = f, a = d) : b ? (n = d - i.length, a = d) : (n = d, a = d + i.length), this.removeStyleFromTo(n, a)), r.length && (e && r.join("") === fabric.copiedText && !fabric.disableStyleCopyPaste && (s = fabric.copiedTextStyle), this.insertNewStyleBlock(r, f, s)), this.updateFromTextArea(), this.fire("changed"), this.canvas && (this.canvas.fire("text:changed", { target: this }), this.canvas.requestRenderAll()) } }, onCompositionStart: function () { this.inCompositionMode = !0 }, onCompositionEnd: function () { this.inCompositionMode = !1 }, onCompositionUpdate: function (t) { this.compositionStart = t.target.selectionStart, this.compositionEnd = t.target.selectionEnd, this.updateTextareaPosition() }, copy: function () { this.selectionStart !== this.selectionEnd && (fabric.copiedText = this.getSelectedText(), fabric.copiedTextStyle = fabric.disableStyleCopyPaste ? null : this.getSelectionStyles(this.selectionStart, this.selectionEnd, !0), this._copyDone = !0) }, paste: function () { this.fromPaste = !0 }, _getClipboardData: function (t) { return t && t.clipboardData || fabric.window.clipboardData }, _getWidthBeforeCursor: function (t, e) { var i, r = this._getLineLeftOffset(t); return e > 0 && (i = this.__charBounds[t][e - 1], r += i.left + i.width), r }, getDownCursorOffset: function (t, e) { var i = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(i), s = r.lineIndex; if (s === this._textLines.length - 1 || t.metaKey || 34 === t.keyCode) return this._text.length - i; var n = r.charIndex, a = this._getWidthBeforeCursor(s, n), o = this._getIndexOnLine(s + 1, a), c = this._textLines[s].slice(n); return c.length + o + 1 + this.missingNewlineOffset(s) }, _getSelectionForOffset: function (t, e) { return t.shiftKey && this.selectionStart !== this.selectionEnd && e ? this.selectionEnd : this.selectionStart }, getUpCursorOffset: function (t, e) { var i = this._getSelectionForOffset(t, e), r = this.get2DCursorLocation(i), s = r.lineIndex; if (0 === s || t.metaKey || 33 === t.keyCode) return -i; var n = r.charIndex, a = this._getWidthBeforeCursor(s, n), o = this._getIndexOnLine(s - 1, a), c = this._textLines[s].slice(0, n), h = this.missingNewlineOffset(s - 1); return -this._textLines[s - 1].length + o - c.length + (1 - h) }, _getIndexOnLine: function (t, e) { for (var i, r, s = this._textLines[t], n = this._getLineLeftOffset(t), a = n, o = 0, c = 0, h = s.length; h > c; c++)if (i = this.__charBounds[t][c].width, a += i, a > e) { r = !0; var l = a - i, f = a, d = Math.abs(l - e), u = Math.abs(f - e); o = d > u ? c : c - 1; break } return r || (o = s.length - 1), o }, moveCursorDown: function (t) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorUpOrDown("Down", t) }, moveCursorUp: function (t) { (0 !== this.selectionStart || 0 !== this.selectionEnd) && this._moveCursorUpOrDown("Up", t) }, _moveCursorUpOrDown: function (t, e) { var i = "get" + t + "CursorOffset", r = this[i](e, "right" === this._selectionDirection); e.shiftKey ? this.moveCursorWithShift(r) : this.moveCursorWithoutShift(r), 0 !== r && (this.setSelectionInBoundaries(), this.abortCursorAnimation(), this._currentCursorOpacity = 1, this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorWithShift: function (t) { var e = "left" === this._selectionDirection ? this.selectionStart + t : this.selectionEnd + t; return this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, e), 0 !== t }, moveCursorWithoutShift: function (t) { return 0 > t ? (this.selectionStart += t, this.selectionEnd = this.selectionStart) : (this.selectionEnd += t, this.selectionStart = this.selectionEnd), 0 !== t }, moveCursorLeft: function (t) { (0 !== this.selectionStart || 0 !== this.selectionEnd) && this._moveCursorLeftOrRight("Left", t) }, _move: function (t, e, i) { var r; if (t.altKey) r = this["findWordBoundary" + i](this[e]); else { if (!t.metaKey && 35 !== t.keyCode && 36 !== t.keyCode) return this[e] += "Left" === i ? -1 : 1, !0; r = this["findLineBoundary" + i](this[e]) } return void 0 !== typeof r && this[e] !== r ? (this[e] = r, !0) : void 0 }, _moveLeft: function (t, e) { return this._move(t, e, "Left") }, _moveRight: function (t, e) { return this._move(t, e, "Right") }, moveCursorLeftWithoutShift: function (t) { var e = !0; return this._selectionDirection = "left", this.selectionEnd === this.selectionStart && 0 !== this.selectionStart && (e = this._moveLeft(t, "selectionStart")), this.selectionEnd = this.selectionStart, e }, moveCursorLeftWithShift: function (t) { return "right" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveLeft(t, "selectionEnd") : 0 !== this.selectionStart ? (this._selectionDirection = "left", this._moveLeft(t, "selectionStart")) : void 0 }, moveCursorRight: function (t) { this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length || this._moveCursorLeftOrRight("Right", t) }, _moveCursorLeftOrRight: function (t, e) { var i = "moveCursor" + t + "With"; this._currentCursorOpacity = 1, i += e.shiftKey ? "Shift" : "outShift", this[i](e) && (this.abortCursorAnimation(), this.initDelayedCursor(), this._fireSelectionChanged(), this._updateTextarea()) }, moveCursorRightWithShift: function (t) { return "left" === this._selectionDirection && this.selectionStart !== this.selectionEnd ? this._moveRight(t, "selectionStart") : this.selectionEnd !== this._text.length ? (this._selectionDirection = "right", this._moveRight(t, "selectionEnd")) : void 0 }, moveCursorRightWithoutShift: function (t) { var e = !0; return this._selectionDirection = "right", this.selectionStart === this.selectionEnd ? (e = this._moveRight(t, "selectionStart"), this.selectionEnd = this.selectionStart) : this.selectionStart = this.selectionEnd, e }, removeChars: function (t, e) { "undefined" == typeof e && (e = t + 1), this.removeStyleFromTo(t, e), this._text.splice(t, e - t), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() }, insertChars: function (t, e, i, r) { "undefined" == typeof r && (r = i), r > i && this.removeStyleFromTo(i, r); var s = fabric.util.string.graphemeSplit(t); this.insertNewStyleBlock(s, i, e), this._text = [].concat(this._text.slice(0, i), s, this._text.slice(r)), this.text = this._text.join(""), this.set("dirty", !0), this._shouldClearDimensionCache() && (this.initDimensions(), this.setCoords()), this._removeExtraneousStyles() } }); !function () { var t = fabric.util.toFixed, e = /  +/g; fabric.util.object.extend(fabric.Text.prototype, { _toSVG: function () { var t = this._getSVGLeftTopOffsets(), e = this._getSVGTextAndBg(t.textTop, t.textLeft); return this._wrapSVGTextAndBg(e) }, toSVG: function (t) { return this._createBaseSVGMarkup(this._toSVG(), { reviver: t, noStyle: !0, withShadow: !0 }) }, _getSVGLeftTopOffsets: function () { return { textLeft: -this.width / 2, textTop: -this.height / 2, lineTop: this.getHeightOfLine(0) } }, _wrapSVGTextAndBg: function (t) { var e = !0, r = this.getSvgTextDecoration(this); return [t.textBgRects.join(""), '		<text xml:space="preserve" ', this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "", this.fontSize ? 'font-size="' + this.fontSize + '" ' : "", this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "", this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "", r ? 'text-decoration="' + r + '" ' : "", 'style="', this.getSvgStyles(e), '"', this.addPaintOrder(), " >", t.textSpans.join(""), "</text>\n"] }, _getSVGTextAndBg: function (t, e) { var r, i = [], a = [], n = t; this._setSVGBg(a); for (var s = 0, o = this._textLines.length; o > s; s++)r = this._getLineLeftOffset(s), (this.textBackgroundColor || this.styleHas("textBackgroundColor", s)) && this._setSVGTextLineBg(a, s, e + r, n), this._setSVGTextLineText(i, s, e + r, n), n += this.getHeightOfLine(s); return { textSpans: i, textBgRects: a } }, _createTextCharSpan: function (r, i, a, n) { var s = r !== r.trim() || r.match(e), o = this.getSvgSpanStyles(i, s), c = o ? 'style="' + o + '"' : "", l = i.deltaY, h = "", f = fabric.Object.NUM_FRACTION_DIGITS; return l && (h = ' dy="' + t(l, f) + '" '), ['<tspan x="', t(a, f), '" y="', t(n, f), '" ', h, c, ">", fabric.util.string.escapeXml(r), "</tspan>"].join("") }, _setSVGTextLineText: function (t, e, r, i) { var a, n, s, o, c, l = this.getHeightOfLine(e), h = -1 !== this.textAlign.indexOf("justify"), f = "", u = 0, d = this._textLines[e]; i += l * (1 - this._fontSizeFraction) / this.lineHeight; for (var b = 0, p = d.length - 1; p >= b; b++)c = b === p || this.charSpacing, f += d[b], s = this.__charBounds[e][b], 0 === u ? (r += s.kernedWidth - s.width, u += s.width) : u += s.kernedWidth, h && !c && this._reSpaceAndTab.test(d[b]) && (c = !0), c || (a = a || this.getCompleteStyleDeclaration(e, b), n = this.getCompleteStyleDeclaration(e, b + 1), c = fabric.util.hasStyleChanged(a, n, !0)), c && (o = this._getStyleDeclaration(e, b) || {}, t.push(this._createTextCharSpan(f, o, r, i)), f = "", a = n, r += u, u = 0) }, _pushTextBgRect: function (e, r, i, a, n, s) { var o = fabric.Object.NUM_FRACTION_DIGITS; e.push("		<rect ", this._getFillAttributes(r), ' x="', t(i, o), '" y="', t(a, o), '" width="', t(n, o), '" height="', t(s, o), '"></rect>\n') }, _setSVGTextLineBg: function (t, e, r, i) { for (var a, n, s = this._textLines[e], o = this.getHeightOfLine(e) / this.lineHeight, c = 0, l = 0, h = this.getValueOfPropertyAt(e, 0, "textBackgroundColor"), f = 0, u = s.length; u > f; f++)a = this.__charBounds[e][f], n = this.getValueOfPropertyAt(e, f, "textBackgroundColor"), n !== h ? (h && this._pushTextBgRect(t, h, r + l, i, c, o), l = a.left, c = a.width, h = n) : c += a.kernedWidth; n && this._pushTextBgRect(t, n, r + l, i, c, o) }, _getFillAttributes: function (t) { var e = t && "string" == typeof t ? new fabric.Color(t) : ""; return e && e.getSource() && 1 !== e.getAlpha() ? 'opacity="' + e.getAlpha() + '" fill="' + e.setAlpha(1).toRgb() + '"' : 'fill="' + t + '"' }, _getSVGLineTopOffset: function (t) { for (var e = 0, r = 0, i = 0; t > i; i++)e += this.getHeightOfLine(i); return r = this.getHeightOfLine(i), { lineTop: e, offset: (this._fontSizeMult - this._fontSizeFraction) * r / (this.lineHeight * this._fontSizeMult) } }, getSvgStyles: function (t) { var e = fabric.Object.prototype.getSvgStyles.call(this, t); return e + " white-space: pre;" } }) }(); !function (t) { "use strict"; var e = t.fabric || (t.fabric = {}); e.Textbox = e.util.createClass(e.IText, e.Observable, { type: "textbox", minWidth: 20, dynamicMinWidth: 2, __cachedLines: null, lockScalingFlip: !0, noScaleCache: !1, _dimensionAffectingProps: e.Text.prototype._dimensionAffectingProps.concat("width"), _wordJoiners: /[ \t\r]/, splitByGrapheme: !1, initDimensions: function () { this.__skipDimension || (this.isEditing && this.initDelayedCursor(), this.clearContextTop(), this._clearCache(), this.dynamicMinWidth = 0, this._styleMap = this._generateStyleMap(this._splitText()), this.dynamicMinWidth > this.width && this._set("width", this.dynamicMinWidth), -1 !== this.textAlign.indexOf("justify") && this.enlargeSpaces(), this.height = this.calcTextHeight(), this.saveState({ propertySet: "_dimensionAffectingProps" })) }, _generateStyleMap: function (t) { for (var e = 0, i = 0, r = 0, n = {}, s = 0; s < t.graphemeLines.length; s++)"\n" === t.graphemeText[r] && s > 0 ? (i = 0, r++, e++) : !this.splitByGrapheme && this._reSpaceAndTab.test(t.graphemeText[r]) && s > 0 && (i++, r++), n[s] = { line: e, offset: i }, r += t.graphemeLines[s].length, i += t.graphemeLines[s].length; return n }, styleHas: function (t, i) { if (this._styleMap && !this.isWrapping) { var r = this._styleMap[i]; r && (i = r.line) } return e.Text.prototype.styleHas.call(this, t, i) }, isEmptyStyles: function (t) { if (!this.styles) return !0; var e, i, r = 0, n = t + 1, s = !1, a = this._styleMap[t], o = this._styleMap[t + 1]; a && (t = a.line, r = a.offset), o && (n = o.line, s = n === t, e = o.offset), i = "undefined" == typeof t ? this.styles : { line: this.styles[t] }; for (var c in i) for (var h in i[c]) if (h >= r && (!s || e > h)) for (var l in i[c][h]) return !1; return !0 }, _getStyleDeclaration: function (t, e) { if (this._styleMap && !this.isWrapping) { var i = this._styleMap[t]; if (!i) return null; t = i.line, e = i.offset + e } return this.callSuper("_getStyleDeclaration", t, e) }, _setStyleDeclaration: function (t, e, i) { var r = this._styleMap[t]; t = r.line, e = r.offset + e, this.styles[t][e] = i }, _deleteStyleDeclaration: function (t, e) { var i = this._styleMap[t]; t = i.line, e = i.offset + e, delete this.styles[t][e] }, _getLineStyle: function (t) { var e = this._styleMap[t]; return !!this.styles[e.line] }, _setLineStyle: function (t) { var e = this._styleMap[t]; this.styles[e.line] = {} }, _wrapText: function (t, e) { var i, r = []; for (this.isWrapping = !0, i = 0; i < t.length; i++)r = r.concat(this._wrapLine(t[i], i, e)); return this.isWrapping = !1, r }, _measureWord: function (t, e, i) { var r, n = 0, s = !0; i = i || 0; for (var a = 0, o = t.length; o > a; a++) { var c = this._getGraphemeBox(t[a], e, a + i, r, s); n += c.kernedWidth, r = t[a] } return n }, _wrapLine: function (t, i, r, n) { var s = 0, a = this.splitByGrapheme, o = [], c = [], h = a ? e.util.string.graphemeSplit(t) : t.split(this._wordJoiners), l = "", f = 0, u = a ? "" : " ", d = 0, p = 0, b = 0, g = !0, v = this._getWidthOfCharSpacing(), n = n || 0; 0 === h.length && h.push([]), r -= n; for (var m = 0; m < h.length; m++)l = a ? h[m] : e.util.string.graphemeSplit(h[m]), d = this._measureWord(l, i, f), f += l.length, s += p + d - v, s > r && !g ? (o.push(c), c = [], s = d, g = !0) : s += v, g || a || c.push(u), c = c.concat(l), p = a ? 0 : this._measureWord([u], i, f), f++, g = !1, d > b && (b = d); return m && o.push(c), b + n > this.dynamicMinWidth && (this.dynamicMinWidth = b - v + n), o }, isEndOfWrapping: function (t) { return this._styleMap[t + 1] ? this._styleMap[t + 1].line !== this._styleMap[t].line ? !0 : !1 : !0 }, missingNewlineOffset: function (t) { return this.splitByGrapheme ? this.isEndOfWrapping(t) ? 1 : 0 : 1 }, _splitTextIntoLines: function (t) { for (var i = e.Text.prototype._splitTextIntoLines.call(this, t), r = this._wrapText(i.lines, this.width), n = new Array(r.length), s = 0; s < r.length; s++)n[s] = r[s].join(""); return i.lines = n, i.graphemeLines = r, i }, getMinWidth: function () { return Math.max(this.minWidth, this.dynamicMinWidth) }, _removeExtraneousStyles: function () { var t = {}; for (var e in this._styleMap) this._textLines[e] && (t[this._styleMap[e].line] = 1); for (var e in this.styles) t[e] || delete this.styles[e] }, toObject: function (t) { return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(t)) } }), e.Textbox.fromObject = function (t, i) { return t.styles = e.util.stylesFromArray(t.styles, t.text), e.Object._fromObject("Textbox", t, i, "text") } }("undefined" != typeof exports ? exports : this); !function () { var r = fabric.controlsUtils, n = r.scaleSkewCursorStyleHandler, t = r.scaleCursorStyleHandler, e = r.scalingEqually, a = r.scalingYOrSkewingX, o = r.scalingXOrSkewingY, l = r.scaleOrSkewActionName, c = fabric.Object.prototype.controls; if (c.ml = new fabric.Control({ x: -.5, y: 0, cursorStyleHandler: n, actionHandler: o, getActionName: l }), c.mr = new fabric.Control({ x: .5, y: 0, cursorStyleHandler: n, actionHandler: o, getActionName: l }), c.mb = new fabric.Control({ x: 0, y: .5, cursorStyleHandler: n, actionHandler: a, getActionName: l }), c.mt = new fabric.Control({ x: 0, y: -.5, cursorStyleHandler: n, actionHandler: a, getActionName: l }), c.tl = new fabric.Control({ x: -.5, y: -.5, cursorStyleHandler: t, actionHandler: e }), c.tr = new fabric.Control({ x: .5, y: -.5, cursorStyleHandler: t, actionHandler: e }), c.bl = new fabric.Control({ x: -.5, y: .5, cursorStyleHandler: t, actionHandler: e }), c.br = new fabric.Control({ x: .5, y: .5, cursorStyleHandler: t, actionHandler: e }), c.mtr = new fabric.Control({ x: 0, y: -.5, actionHandler: r.rotationWithSnapping, cursorStyleHandler: r.rotationStyleHandler, offsetY: -40, withConnection: !0, actionName: "rotate" }), fabric.Textbox) { var i = fabric.Textbox.prototype.controls = {}; i.mtr = c.mtr, i.tr = c.tr, i.br = c.br, i.tl = c.tl, i.bl = c.bl, i.mt = c.mt, i.mb = c.mb, i.mr = new fabric.Control({ x: .5, y: 0, actionHandler: r.changeWidth, cursorStyleHandler: n, actionName: "resizing" }), i.ml = new fabric.Control({ x: -.5, y: 0, actionHandler: r.changeWidth, cursorStyleHandler: n, actionName: "resizing" }) } }(); !function () { fabric.Object.ENLIVEN_PROPS.push("eraser"); var t = fabric.Object.prototype._drawClipPath, r = fabric.Object.prototype.needsItsOwnCache, e = fabric.Object.prototype.toObject, a = fabric.Object.prototype.getSvgCommons, i = fabric.Object.prototype._createBaseClipPathSVGMarkup, s = fabric.Object.prototype._createBaseSVGMarkup; fabric.Object.prototype.cacheProperties.push("eraser"), fabric.Object.prototype.stateProperties.push("eraser"), fabric.util.object.extend(fabric.Object.prototype, { erasable: !0, eraser: void 0, needsItsOwnCache: function () { return r.call(this) || !!this.eraser }, _drawClipPath: function (r, e) { if (t.call(this, r, e), this.eraser) { var a = this._getNonTransformedDimensions(); this.eraser.isType("eraser") && this.eraser.set({ width: a.x, height: a.y }), t.call(this, r, this.eraser) } }, toObject: function (t) { var r = e.call(this, ["erasable"].concat(t)); return this.eraser && !this.eraser.excludeFromExport && (r.eraser = this.eraser.toObject(t)), r }, getSvgCommons: function () { return a.call(this) + (this.eraser ? 'mask="url(#' + this.eraser.clipPathId + ')" ' : "") }, _createEraserSVGMarkup: function (t) { return this.eraser ? (this.eraser.clipPathId = "MASK_" + fabric.Object.__uid++, ['<mask id="', this.eraser.clipPathId, '" >', this.eraser.toSVG(t), "</mask>", "\n"].join("")) : "" }, _createBaseClipPathSVGMarkup: function (t, r) { return [this._createEraserSVGMarkup(r && r.reviver), i.call(this, t, r)].join("") }, _createBaseSVGMarkup: function (t, r) { return [this._createEraserSVGMarkup(r && r.reviver), s.call(this, t, r)].join("") } }); var n = fabric.Group.prototype._restoreObjectsState; fabric.util.object.extend(fabric.Group.prototype, { _addEraserPathToObjects: function (t) { this._objects.forEach(function (r) { fabric.EraserBrush.prototype._addPathToObjectEraser.call(fabric.EraserBrush.prototype, r, t) }) }, applyEraserToObjects: function () { var t = this, r = this.eraser; if (r) { delete this.eraser; var e = t.calcTransformMatrix(); r.clone(function (r) { var a = t.clipPath; r.getObjects("path").forEach(function (r) { var i = fabric.util.multiplyTransformMatrices(e, r.calcTransformMatrix()); fabric.util.applyTransformToObject(r, i), a ? a.clone(function (a) { var i = fabric.EraserBrush.prototype.applyClipPathToPath.call(fabric.EraserBrush.prototype, r, a, e); t._addEraserPathToObjects(i) }, ["absolutePositioned", "inverted"]) : t._addEraserPathToObjects(r) }) }) } }, _restoreObjectsState: function () { return this.erasable === !0 && this.applyEraserToObjects(), n.call(this) } }), fabric.Eraser = fabric.util.createClass(fabric.Group, { type: "eraser", originX: "center", originY: "center", drawObject: function (t) { t.save(), t.fillStyle = "black", t.fillRect(-this.width / 2, -this.height / 2, this.width, this.height), t.restore(), this.callSuper("drawObject", t) }, _getBounds: function () { }, _toSVG: function (t) { var r = ["<g ", "COMMON_PARTS", " >\n"], e = -this.width / 2, a = -this.height / 2, i = ["<rect ", 'fill="white" ', 'x="', e, '" y="', a, '" width="', this.width, '" height="', this.height, '" />\n'].join(""); r.push("		", i); for (var s = 0, n = this._objects.length; n > s; s++)r.push("		", this._objects[s].toSVG(t)); return r.push("</g>\n"), r } }), fabric.Eraser.fromObject = function (t, r) { var e = t.objects; fabric.util.enlivenObjects(e, function (e) { var a = fabric.util.object.clone(t, !0); delete a.objects, fabric.util.enlivenObjectEnlivables(t, a, function () { r && r(new fabric.Eraser(e, a, !0)) }) }) }; var o = fabric.Canvas.prototype._renderOverlay; fabric.util.object.extend(fabric.Canvas.prototype, { isErasing: function () { return this.isDrawingMode && this.freeDrawingBrush && "eraser" === this.freeDrawingBrush.type && this.freeDrawingBrush._isErasing }, _renderOverlay: function (t) { o.call(this, t), this.isErasing() && !this.freeDrawingBrush.inverted && this.freeDrawingBrush._render() } }), fabric.EraserBrush = fabric.util.createClass(fabric.PencilBrush, { type: "eraser", inverted: !1, _isErasing: !1, _isErasable: function (t) { return t.erasable !== !1 }, _prepareCollectionTraversal: function (t, r, e) { t.forEachObject(function (a) { a.forEachObject && "deep" === a.erasable ? this._prepareCollectionTraversal(a, r, e) : !this.inverted && a.erasable && a.visible ? (a.visible = !1, t.dirty = !0, e.visibility.push(a), e.collection.push(t)) : this.inverted && a.visible && (a.erasable && a.eraser ? (a.eraser.inverted = !0, a.dirty = !0, t.dirty = !0, e.eraser.push(a), e.collection.push(t)) : (a.visible = !1, t.dirty = !0, e.visibility.push(a), e.collection.push(t))) }, this) }, preparePattern: function () { this._patternCanvas || (this._patternCanvas = fabric.util.createCanvasElement()); var t = this._patternCanvas; t.width = this.canvas.width, t.height = this.canvas.height; var r = t.getContext("2d"); if (this.canvas._isRetinaScaling()) { var e = this.canvas.getRetinaScaling(); this.canvas.__initRetinaScaling(e, t, r) } var a = this.canvas.backgroundImage, i = a && this._isErasable(a), s = this.canvas.overlayImage, n = s && this._isErasable(s); if (!this.inverted && (a && !i || this.canvas.backgroundColor)) i && (this.canvas.backgroundImage = void 0), this.canvas._renderBackground(r), i && (this.canvas.backgroundImage = a); else if (this.inverted && a && i) { var c = this.canvas.backgroundColor; this.canvas.backgroundColor = void 0, this.canvas._renderBackground(r), this.canvas.backgroundColor = c } r.save(), r.transform.apply(r, this.canvas.viewportTransform); var l = { visibility: [], eraser: [], collection: [] }; if (this._prepareCollectionTraversal(this.canvas, r, l), this.canvas._renderObjects(r, this.canvas._objects), l.visibility.forEach(function (t) { t.visible = !0 }), l.eraser.forEach(function (t) { t.eraser.inverted = !1, t.dirty = !0 }), l.collection.forEach(function (t) { t.dirty = !0 }), r.restore(), !this.inverted && (s && !n || this.canvas.overlayColor)) n && (this.canvas.overlayImage = void 0), o.call(this.canvas, r), n && (this.canvas.overlayImage = s); else if (this.inverted && s && n) { var c = this.canvas.overlayColor; this.canvas.overlayColor = void 0, o.call(this.canvas, r), this.canvas.overlayColor = c } }, _setBrushStyles: function (t) { this.callSuper("_setBrushStyles", t), t.strokeStyle = "black" }, _saveAndTransform: function (t) { this.callSuper("_saveAndTransform", t), this._setBrushStyles(t), t.globalCompositeOperation = t === this.canvas.getContext() ? "destination-out" : "source-over" }, needsFullRender: function () { return !0 }, onMouseDown: function (t, r) { this.canvas._isMainEvent(r.e) && (this._prepareForDrawing(t), this._captureDrawingPath(t), this.preparePattern(), this._isErasing = !0, this.canvas.fire("erasing:start"), this._render()) }, _render: function () { var t; this.inverted || (t = this.canvas.getContext(), this.callSuper("_render", t)), t = this.canvas.contextTop, this.canvas.clearContext(t), this.callSuper("_render", t), t.save(); var r = this.canvas.getRetinaScaling(), e = 1 / r; t.scale(e, e), t.globalCompositeOperation = "source-in", t.drawImage(this._patternCanvas, 0, 0), t.restore() }, createPath: function (t) { var r = this.callSuper("createPath", t); return r.globalCompositeOperation = this.inverted ? "source-over" : "destination-out", r.stroke = this.inverted ? "white" : "black", r }, applyClipPathToPath: function (t, r, e) { var a = fabric.util.invertTransform(t.calcTransformMatrix()), i = r.calcTransformMatrix(), s = r.absolutePositioned ? a : fabric.util.multiplyTransformMatrices(a, e); return r.absolutePositioned = !1, fabric.util.applyTransformToObject(r, fabric.util.multiplyTransformMatrices(s, i)), t.clipPath = t.clipPath ? fabric.util.mergeClipPaths(r, t.clipPath) : r, t }, clonePathWithClipPath: function (t, r, e) { var a = r.calcTransformMatrix(), i = r.clipPath, s = this; t.clone(function (t) { i.clone(function (r) { e(s.applyClipPathToPath(t, r, a)) }, ["absolutePositioned", "inverted"]) }) }, _addPathToObjectEraser: function (t, r) { var e = this; if (t.forEachObject && "deep" === t.erasable) { var a = t._objects.filter(function (t) { return t.erasable }); return void (a.length > 0 && t.clipPath ? this.clonePathWithClipPath(r, t, function (t) { a.forEach(function (r) { e._addPathToObjectEraser(r, t) }) }) : a.length > 0 && a.forEach(function (t) { e._addPathToObjectEraser(t, r) })) } var i = t.eraser; i || (i = new fabric.Eraser, t.eraser = i), r.clone(function (r) { var a = fabric.util.multiplyTransformMatrices(fabric.util.invertTransform(t.calcTransformMatrix()), r.calcTransformMatrix()); fabric.util.applyTransformToObject(r, a), i.addWithUpdate(r), t.set("dirty", !0), t.fire("erasing:end", { path: r }), t.group && Array.isArray(e.__subTargets) && e.__subTargets.push(t) }) }, applyEraserToCanvas: function (t) { var r = this.canvas, e = {}; return ["backgroundImage", "overlayImage"].forEach(function (a) { var i = r[a]; i && i.erasable && (this._addPathToObjectEraser(i, t), e[a] = i) }, this), e }, _finalizeAndAddPath: function () { var t = this.canvas.contextTop, r = this.canvas; t.closePath(), this.decimate && (this._points = this.decimatePoints(this._points, this.decimate)), r.clearContext(r.contextTop), this._isErasing = !1; var e = this._points && this._points.length > 1 ? this.convertPointsToSVGPath(this._points) : null; if (!e || this._isEmptySVGPath(e)) return r.fire("erasing:end"), void r.requestRenderAll(); var a = this.createPath(e); a.setCoords(), r.fire("before:path:created", { path: a }); var i = this.applyEraserToCanvas(a), s = this; this.__subTargets = []; var n = []; r.forEachObject(function (t) { t.erasable && t.intersectsWithObject(a, !0, !0) && (s._addPathToObjectEraser(t, a), n.push(t)) }), r.fire("erasing:end", { path: a, targets: n, subTargets: this.__subTargets, drawables: i }), delete this.__subTargets, r.requestRenderAll(), this._resetShadow(), r.fire("path:created", { path: a }) } }) }();